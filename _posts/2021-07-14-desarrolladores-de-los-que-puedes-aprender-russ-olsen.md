---
title: "Desarrolladores de los que puedes aprender: Russ Olsen"
date: 2021-07-14
author: Héctor Patricio
tags: devs ruby clojure
comments: true
excerpt: "Russ Olsen es un desarrollador de software conocido por sus libros sobre Ruby y Clojure y por las excelentes charlas que da. Veamos algunas de sus ideas y lo que podemos aprender de él."
header:
  overlay_image: https://res.cloudinary.com/hectorip/image/upload/c_scale,e_oil_paint:19,w_1280/v1626300098/60da357436deba0fd63a4689_ch2-getting-started-with-ruby_yrghl0.jpg
  teaser: https://res.cloudinary.com/hectorip/image/upload/e_oil_paint:13,w_300/v1626237333/slideslive_russ-olsen_explain-it_mejk2s.jpg
  overlay_filter: rgba(0, 0, 0, 0.5)
---

En este capítulo vamos a Hablar de [Russ Olsen](http://russolsen.com/), un desarrollador ahora de [Clojure](https://clojure.org/), pero bastante reconocido en el mundo de Ruby. Ha escrito varios libros y contribuye activamente a la comunidad mediante podcasts, presentaciones y charlas.

## Acerca de Russ

Russ trabaja como vicepresidente de [Cognitec](https://www.cognitect.com/), la empresa que está detrás de Clojure. Ha participado en proyectos que parecen bastante complejos, su Github muestra creación de compiladores, marshalling y otras cosas interesantes.

Según la biografía que se encuentra en [sitios de conferencias](https://gotocon.com/berlin-2015/speaker/Russ+Olsen) ha trabajado en motores de renderizado 3D, sistemas de consulta de bases de datos y sistema de flujos de trabajo, en pocas palabras, proyectos bastante complejos.

Russ es el autor de tres libros bastantes respetados:

- [Eloquent Ruby](https://www.amazon.com/Eloquent-Ruby-Addison-Wesley-Professional/dp/0321584104): acerca de cómo escribir Ruby idiomáticamente.
- [Design Patterns in Ruby](https://www.amazon.com/gp/product/B004YW6M6G/ref=dbs_a_def_rwt_hsch_vapi_tkin_p1_i2): la implementación de los patrones de diseño clásicos en Ruby.
- [Getting Clojure](https://pragprog.com/titles/roclojure/getting-clojure/): te enseña a programar en Clojure mientras te explica las ideas detrás de cada una de las caracerísticas del lenguaje, ya que es importante concer _la visión_ detrás del lenguaje.

## Las ideas de Russ

Russ tiene ideas muy pragmáticas para crear software, con un background de ingeniería mecánica. Vamos a hablar de algunas cosas que podemos aprender de él y aplicar directamente en nuestras carreras y proyectos.

1. Transmitir conocimiento es MUY IMPORTANTE para el desarrollo de software. Si no lo compartimos ponemos en riesgo el desarrollo del proyecto en el que estamos participando. Saber explicarlo de manera sencilla es una habilidad que todos debemos adquirir.

2. La programación funcional, como una serie de _restricciones, técnicas y habilidades_ que reorganizan la forma en que escribimos código, es una forma de crear código de mejor calidad y más mantenible.

3. **Trabajar con otras personas** es uno de los aspectos más importantes que tiene el desarrollo de software y saber organizarla y tratar con ellas es imperativo para llevar a los proyectos a buen término.

4. **Crear cosas que importen** y difíciles te inspirará para seguir creando y también a otras personas.

## Charlas y presentaciones

> "Ve y haz cosas difíciles." - Russ Olsen

Aquí tienes las tres charlas que Russ que pueden aportar a tu conocimiento y motivación para seguir creando software:

- [To the Moon](https://www.youtube.com/watch?v=l3XwpSKqNZw). Si vas a ver una charla de Russ Olsen, tiene que ser esta. Tiene nulo contenido técnico, pero te puede enseñar muchas cosas: cómo dar una charla entretenida, cómo contar una historia, métodos narrativos y cómo mantener enganchada a la audiencia. En ella cuenta las dificultades técnicas que se presentaron en el proyecto del **Apollo 11**, y como se solucionaron. La lección más importante de la charla es: hacer cosas difíciles como ingenieros de software te ayudará a creer más en ti y a inspirar a otros.

- [Eloquent Explanations](https://www.youtube.com/watch?v=80EE4mZmp3A): En esta charla Russ nos habla sobre lo importante que es comunicar claramente varios aspeectos de los sistemas que creamos, con la premisa fundamental de que el conocimiento es lo que nos permite crear el software que necesitamos. En [este hilo de Twitter](https://twitter.com/HectorIP/status/1414096122306498560) hicimos un resumen.

- [Functional Programming in 40 minutes](https://www.youtube.com/watch?v=0if71HOyVjY): Como puedes ver, Russ es un programador bastante versátil. En los últimos años se ha dedicado a programar en Clojure. Esta es una de las charlas que más me ayudó a comprender la programación funcional como idea más allá de las definiciones clásicas y que te dejan híper confundido. Si quieres aprender programación funcional, esta charla te puede ayudar a entenderla para empezar con una buena base.

Tiene varias charlas más que puedes buscar en [YouTube](https://www.youtube.com/results?search_query=russ+olsen), pero estas son las más importantes para mi, y parece que varias de ellas son la mismas que mencionamos aquí pero repetidas.

## Recursos para aprender más

- [Twitter de Russ](https://twitter.com/russolsen).
- Su [Github](https://github.com/russolsen/), tiene cosas interesantes, como la implementación del lenguaje [Forth](https://hackaday.com/2017/01/27/forth-the-hackers-language/) en Python y Clojure, una implementación de Transit (un formato de serialización) en Go y Julia.
- El blog de [Cognitect](https://www.cognitect.com/blog/)
- Este podcast en el que participó: [Get Smarter and Make Stuff](https://www.youtube.com/watch?v=gcs1t91X5LA)


## Preguntas que le hicimos

Además de investigar y aprender sobre las ideas de estos desarrolladores, creamos un cuestionario para hacérselos a todos los desarrolladores de esta serie, para que contesten la que puedan. Contactaremos directamente a cada uno y le haremos llegar las preguntas, con suerte nos contestaran.

Kevlin fue muy accesible y nos contestó casi todas las preguntas, disfruta las respuestas.

1. ¿Cómo fue tu camino de aprendizaje? **¿Cómo te hiciste así de bueno?**

No se si soy _tan_ bueno, pero mi camino ha sido una mezcla de interés apasionado experimentación, ignorancia, estudio,  ¡y suerte! Me introduje en la programación en la adolescencia pero no se me ocurrió hasta que dejé la universidad que el desarrollo de software podría ser una buena elección de trabajo o carrera.

As I was working, I was also drawn into the world of languages, techniques, paradigms, design, etc., reading a random assortment of books and articles that increased my interest and fascination. I started trying to communicate these ideas through articles, and relating my experiences as I worked on different systems and in different environments.

This eventually led to giving talks, running courses and visiting companies, which broadened my outlook, challenged some of my ideas and improved my ability to think on my feet.

2. What has been your **worst technical decision so far?** What constraints restrained it?

I'll choose a technical decision that is safely in the past — quarter of a century past, to be precise. I was working on a SCADA system in the energy sector. Our systems were embedded in electricity substations and had very low network bandwidth (only a few thousand bits per second). I helped define a binary protocol that was compact and not bandwidth hungry. In defining this protocol, we specifically decided not to worry about security in the protocol because, at that time, we didn't think anyone would be foolish enough to connect sensitive infrastructure, such as the electrical grid, to a public network, such as the internet.

It turns out that you should never underestimate how foolish people can be! Fortunately, this was later addressed by a few changes that switched to using SSL rather than running over raw sockets.

That said, although we missed one future trend, we caught others. We not only addressed the Y2K problem before most people were even aware of it; we also addressed the Year 2038 problem.

3. What is the worst advice you got?

Testing is not the responsibility of a developer.

4. What is the best advice you got?

Think about software development as the management of complexity.

5. In your experience, how important is the language we pick to develop our software? Why do you think we still arguing about the language?

It's important in that language choice is often architectural. If you're unsure about this, consider the cost and effort, the tooling, the skills, etc. of what it would take to change programming language in some or all of your codebase. Think about how much of your system would be affected, how staff would be affected, how other elements of your technical stack would be affected. And so on. Far from being a detail, the choice is more significant than many people realise.

Language, in whatever form, is a way in which we express ourselves. Language is also associated with culture and community. This is why we argue about it. Although many developers might think they are debating rationally about a language and its technical merits, they typically are not. Beneath the technical veneer of such arguments is something more human and less rational, something more social and personal. And that's why we continue to argue about language.

Of course, there are technical differences and there are objective points that can be made, but in truth this does not lie at the core of most discussions.

6. What is the most **unproductive technical arguing you have had?**

Probably about programming language!

7. What is something you could recommend to young developers still looking for their way?

Look at the history of programming, software architecture, development methodologies and so on. Software development has a history and most of the deep ideas can be found in it. Most of today's trends and choices are better understood by understanding the past rather than just looking at the present. Software development is more conservative than you might appreciate, and new ideas are rarely novel.

8. What are the ideas that we as the IT industry should overcome to improve as a community?

The idea that software development is a strictly neutral and technical activity independent of the considerations of people. The way we develop software and the way that it is used have ethical implications. We need to better recognise the spectrum of people who can and do create software and the responsibilities to people that use software. Software changes the world; we don't get to do that and say that how the world changes is not our problem.

9. What is the future of programming for the next ten years in your opinion? What should we learn to remain productive?

The next ten years are going to be a lot like the previous ten years. There will be new frameworks, new platforms, new programming languages, etc. and associated shifts in skills. Some people will get excited by new ideas that are actually not that new. Some people will predict the demise of programmers and software development as we know it. What will most likely happen is that the number of programmers will increase and software development will continue to evolve, mostly along the lines it is currently following. The world will continue to be increasingly reliant on software and developers.
## Conclusión

Una de las cosas que aprender al ver la carrera de Russ es su flexibilidad y adaptabilidad. Russ era un gran nombre en el mundo de **Rails y Ruby**, pero ahora está en el mundo de Clojure y tiene una de las mejores explicaciones para aprender programación funcional.

Además, el pragmatismo que demuestra en los consejos que da, es algo que podemos aprender a aplicar: **resolver el problema es mucho más importante que sonar rimbombantes y asombrar a todos con las palabras tan bonitas que usamos**.

El último punto que quiero resaltar tiene que ver con la capacidad que tiene de contar historias, explicar progresivamente y dar charlas entretenidas. La comunicación es uno de los aspectos más importantes en el desarrollo de software, y mientras mejores seamos e eso, más podremos avanzar en nuestra carrera.

