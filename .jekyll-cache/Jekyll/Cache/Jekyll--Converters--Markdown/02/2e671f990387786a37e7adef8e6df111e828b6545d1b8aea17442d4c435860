I"w$<p>En este art√≠culo hablaremos primero de la importancia de aprender <strong>principios</strong>: qu√© son, qu√© ventajas tienen y c√≥mo aplicarlos.</p>

<p>Hallar√°s una explicaci√≥n b√°sica de cada principio y su importancia, pero cada principio tendr√° un post extenso explicando sus aplicaciones, forma de implementarlo y ejemplos pr√°cticos, un s√≥lo art√≠culo no es suficiente para explicarlos cuando se podr√≠a escribir un libro sobre cada principio.</p>

<p>Ponle atenci√≥n a los primeros dos üòâ. Pero antes hablemos de lo que es un principio en general.</p>

<h2 id="qu√©-es-un-principio">¬øQu√© es un principio?</h2>

<p>Un principio se puede entender como una gu√≠a de comportamiento amplia aplicable a muchas situaciones. En general un principio no te dice que hacer exactamente, sino que te da pistas de cu√°l es la acci√≥n correcta a trav√©s de una gran cantidad de situaciones, los detalles est√°n a cargo de ti mismo.</p>

<p>En ciencia un principio tambi√©n se pueden entender como una ley o una verdad que se puede aplicar en una muchas situaciones.</p>

<p>Hablando de <strong>principios de dise√±o de software</strong>, puedes pensar en ellos como en un faro que te gu√≠a a trav√©s de la oscuridad de los requerimientos del problema üòõ. A diferencia de los <a href="/2019/02/23/patrones-de-diseno-que-son-y-cuando-usarlos">patrones de dise√±o</a>, no establecen los pasos necesarios para aplicarlos, ni siquiera la situaciones en las que se aplican, de hecho, se pueden crear varios patrones y reglas bas√°ndonos en ellos.</p>

<p>Ahora hablemos de los m√°s relevantes.</p>

<h2 id="algunos-principios-de-dise√±o-de-software">Algunos principios de Dise√±o de Software</h2>

<p>Los siguientes principios de dise√±o son de los que m√°s escuchar√°s a lo largo de tu carrera. Aqu√≠ presentamos una s√≠ntesis de lo que tratan pero cada uno tendr√° su propio art√≠culo extenso explicando ejemplos de c√≥mo podemos aplicarlos.</p>

<h3 id="dont-repeat-yourself-no-te-repitas">Don‚Äôt Repeat Yourself (No te repitas)</h3>

<p>Este principio (conocido como DRY) se explica por s√≠ mismo: <strong>debes evitar al m√°ximo grado posible la repetici√≥n de c√≥digo</strong>. Partiendo de este principio se han creado un mont√≥n de maneras de reutilizar lo que ya hemos programado, si no pi√©nsalo un poco: funciones, m√≥dulos, bibliotecas, clases, prototipos, herencia, composici√≥n, macros, saltos (goto).</p>

<p>Estas son s√≥lo algunas maneras de evitar la repetici√≥n, claro, cada una de las estrategias anteriores lo logra a su manera y a√±ade otras ventajas y desventajas.</p>

<p><strong>¬øPor qu√© es importante?</strong> Existen varias razones:</p>

<ul>
  <li><em>Hace el c√≥digo m√°s mantenible</em>. Evitar la repetici√≥n de c√≥digo permite que si alguna vez cambia la funcionalidad que est√°s repitiendo, no lo tengas que hacer en todos los lugares en los que lo repetiste.</li>
  <li><em>Reduce el tama√±o del c√≥digo</em>. Esto lo hace m√°s legible y entendible, porque hay menos c√≥digo que entender. Los procesos para evitar la repetic√≥n implican nombrar el pedazo de c√≥digo que est√°s reutilizando para identificarlo, esto hace el c√≥digo m√°s legible si lo nombraste bien.</li>
  <li><em>Ahorra tiempo</em>. Al tener pedazos de c√≥digo disponibles para reutilizarlos, en el futuro est√°s m√°s preparado para lograr lo mismo en menos tiempo.</li>
</ul>

<h3 id="kiss">KISS</h3>

<p><strong>‚ÄúKeep it simple[,] stupid‚Äù</strong>: hay discrepancias sobre si esta frase significa: ‚ÄúD√©jalo simple, est√∫pido‚Äù o ‚ÄúMantenlo est√∫pidamente simple‚Äù. Este principio establece que el c√≥digo, el dise√±o, la documentaci√≥n, todo lo relacionado con el software, debe ser tan simple como sea posible.</p>

<p>Los programadores tendemos a complicar las cosas. Nos piden un formulario sencillo y queremos hacer un generador de formularios que soporte este y todos los formularios en el futuro. No tenemos ni 100 usuarios y ya queremos usar Kubernetes. Necesitamos un simple binding de datos y queremos meter Angular 7, Ionic 3 y 250 librer√≠as m√°s.</p>

<p>Este principio establece que:</p>
<ul>
  <li>Nuestro software en general deber√≠a tener tan pocos componentes (y por lo tanto l√≠neas) como sea posible.</li>
  <li>No deber√≠amos tener funcionalidades que no se ocupen actualmente <em>‚Äúpor si en el futuro se ocupan‚Äù</em>.</li>
  <li>La documentaci√≥n debe tener la informaci√≥n <strong>estrictamente necesaria</strong>.</li>
  <li>El c√≥digo debe ser <strong>lo m√°s obvio y sencillo posible</strong>. Se deben evitar esas l√≠neas que s√≥lo sirven para presumir lo inteligente que eres.</li>
  <li>El dise√±o debe mantener la estructura simple, siempre que se pueda.</li>
</ul>

<p><strong>¬øPor qu√© es importante?</strong> Las siguientes son algunas de las razones que justifican la existencia de este principio:</p>
<ul>
  <li><strong>Proyectos m√°s mantenibles</strong>. Hay mucho menos que explicar al mantener las cosas simples. El c√≥digo es m√°s f√°cil de mantener y actualizar.</li>
  <li><strong>menos documentaci√≥n</strong>. Hay menos cosas raras que documentar al hacer el c√≥digo f√°cil, sin trucos de listillos que nadie entiende.</li>
  <li><strong>Debugging m√°s r√°pido</strong>. Al reducir la complejidad se pueden encontrar los errores m√°s r√°pidamente.</li>
  <li><strong>Mayor rendimiento econ√≥mico</strong>. Los tres efectos anteriores permiten que la inversi√≥n econ√≥mica inicial en el c√≥digo creado tenga mayores rendimientos.</li>
</ul>

<p>Estes es uno de los principios m√°s dif√≠ciles de aplicar, si no es que el <em>m√°s dif√≠cil</em>. Hacer algo simple para los dem√°s requiere de pensar las cosas el tiempo suficiente, de tener la experiencia t√©cnica necesaria para evitar intentar matar una mosca con un ca√±√≥n (o investigar y tener la capacidad de aprender). A final de cuentas <strong>la simplicidad es la √∫ltima sofisticaci√≥n</strong>.</p>

<p>Los principios que vienen est√°n fundamentados sobre estos dos principios.</p>

<h3 id="principios-solid">Principios SOLID</h3>

<p>Si te dedicas a programar, llegado cierto punto vas a encontrar estos principios mencionados lo suficiente como para que tengas que aprender que significan.</p>

<p>SOLID es un acr√≥nimo que engloba el nombre de 5 principios, originalmente dirigidos a la programaci√≥n orientada a objetos, pero que son aplicables a muchas otras cosas.</p>

<p>Los 5 principios son:</p>

<ol>
  <li>
    <p><strong>Single Responsibility</strong>. Una entidad de software deber√≠a tener una sola responsabilidad, esto tambi√©n se puede interpretar como ‚Äútener una y s√≥lo una raz√≥n para cambiar.‚Äù. En pocas palabras, tu componente/funci√≥n/clase deber√≠a hacer muy bien una sola cosa.</p>
  </li>
  <li>
    <p><strong>Open/Closed</strong>. Una entidad de software (este principio est√° dirigido a las clases), deber√≠a estar abierto a extensi√≥n (crecer sus funcionalidades con otras entidades externas) pero cerrado a modificaci√≥n.</p>
  </li>
  <li>
    <p><strong>Liskov Substitution</strong>. El principio de susbstituci√≥n de Liskov habla de interfaces: si una entidad de software usa una clase, este debe ser capaz de usar clases derivadas de esta. Esto es muy parecido a la progrmaci√≥n por contrato, en el que se establecen las interfaces antes de la implementaci√≥n.</p>
  </li>
  <li>
    <p><strong>Interface Segregation</strong>. Los clientes (las entidade de software) que usan una entidad de software (una clase, originalmente), no deber√≠an estar obligados a depender de m√©todos que no usan. Para resolver esto, interfaces de gran tama√±o se deben <em>segregar</em>, es decir, romper en otras m√°s peque√±as.</p>
  </li>
  <li>
    <p><strong>Dependency Inversion</strong>. El principio de Inversi√≥n de Dependencias establece que los m√≥dulos de alto nivel, es decir, los m√°s cercanos a las ideas humanas de lo que debe hacer el software, no deben depender de los de bajo nivel (los m√°s cercanos a la implementaci√≥n de los detalles para la computadora). Ambos deber√≠an depender de las abstracciones del problema (en general, interfaces). Adem√°s los detalles de implementaci√≥n deben depender de las abastracciones tambi√©n. Se llama as√≠ porque en general la gente lo piensa al rev√©s.</p>
  </li>
</ol>

<p>Estos principios empiezan sencillos pero se van complicando, as√≠ que le dedicaremos m√°s adelante un post entero a cada principio y a su aplicaci√≥n, extendi√©ndola m√°s all√° del software orientado a objetos.</p>

<p><strong>¬øPor qu√© son importantes?</strong> Permiten crear software estructurado correctamente que resista el paso del tiempo.</p>

<p>Como podr√°s ver estos principios pueden complicar con un poco el c√≥digo. Sin embargo, dependiendo del fin del software que est√©s creando, puedes decidir aplicarlos o saltarte alguno de ellos.</p>

<h2 id="conclusi√≥n">Conclusi√≥n</h2>

<p>Hay m√°s principios de dise√±o de software de los que no hablamos en este momento, pero estos son los b√°sicos que todo programador debe de conocer porque facilitan la vida.</p>

<p>Si seguimos estos principios podremos hacer software mantenible, que sea f√°cil de actualizar, entender, compartir, explicar y que est√© preparado para el futuro.</p>

<p>Sigue atento por los siguientes posts que explican cada principio en profundidad, con ejemplos reales.</p>
:ET