I"ô(<blockquote>
  <p>El prop√≥sito de construir software no es crear una topolog√≠a de interacciones espec√≠ficas, o usar un tipo particular de componente; es crear un sistema que cumpla y exceda las necesidades de la aplicaci√≥n. - Thomas Fielding</p>
</blockquote>

<p>Ya hablamos de las <a href="/2019/06/15/entendiendo-rest-estilo-de-arquitectura.html">motivaciones detr√°s del estilo arquitectural REST</a>. Ahora empecemos con la primera de sus caracter√≠sticas o restricciones, que la empieza a definir: la arquitectura cliente-servidor.</p>

<h2 id="qu√©-es-la-arquitectura-cliente-servidor">¬øQu√© es la arquitectura cliente-servidor?</h2>

<p>Esta arquitectura de aplicaci√≥n divide un sistema en dos componentes:</p>

<ul>
  <li>
    <p><strong>Cliente</strong>: Es un programa o proceso que solicita un servicio y usa la informaci√≥n provista para sus propios objetivos.</p>
  </li>
  <li>
    <p><strong>Servidor</strong>: Programa o proceso que ofrece un conjunto de servicios y espera por peticiones para ejecutar o dar estos servicios.</p>
  </li>
</ul>

<p>La principal caracter√≠stica de la arquitectura cliente-servidor es que logra una <em>separaci√≥n de responsabilidades clara</em>.</p>

<p>En palabras de <a href="https://homepages.cwi.nl/~marcello/SAPapers/And91.pdf">Gregory R. Andrews</a>, el cliente es un proceso desencadenante mientras que el servidor es un proceso reactivo. Es decir el servidor no puede env√≠ar datos o empezar procesos que un cliente no le ha solicitado.</p>

<p>La arquitectura b√°sica de un sistema cliente-servidor es esta:</p>

<p><img src="https://res.cloudinary.com/hectorip/image/upload/v1562699566/PNG_image-ABC17A5C0944-1_wpyk2e.png" alt="Esquema cliente-servidor" /></p>

<!-- Recordemos que todos los dise√±os o arquitecturas implican un intercambio de valor entre varias caracter√≠sticas, en este caso un poco de simplicidad por la separaci√≥n de responsabilidades claras. -->

<p>Veamos sus ventajas y desventajas.</p>

<h2 id="ventajas">Ventajas</h2>

<p>Hablemos de los beneficios que trae usar la arquitectura cliente-servidor.</p>

<h3 id="separaci√≥n-clara-de-responsabilidades">Separaci√≥n clara de responsabilidades</h3>

<p>La funcionalidad del sistema se divide en dos partes (por lo menos), como el nombre lo indica en parte de dar los servicios (generalmente de datos) y la parte de atender al usuario (humanos o programa) final.</p>

<p>El cliente y el servidor tienen funciones completamente distintas y cada uno puede cambiar por su lado sin afectar al otro, a esto le podemos llamar ‚Äúevoluci√≥n independiente‚Äù.</p>

<p>El ejemplo que tenemos es el del navegador y las p√°ginas que visitamos normalmente en internet. Mientras sigan cumpliendo con el protocolo establecido de comunicaci√≥n (HTTP) van a poder seguir comunic√°ndose y transfiriendo informaci√≥n, sin interferir la manera en que est√©n implementados sus procesos internos.</p>

<h3 id="divisi√≥n-de-complejidad">Divisi√≥n de complejidad</h3>

<p>La misma divisi√≥n de la que hablamos en el punto anterior permite dividir la complejidad en dos partes por lo que cada una por su lado es m√°s f√°cil de entender y desarrollar que el sistema completo.</p>

<p>Por lo tanto, se sigue el mismo principio que se usa para desarrollar software complejo en general: <strong>divide y vencer√°s</strong>. Esto permite que podamos dividir el trabajo limpiamente en diferentes etapas de desarrollo o entre diferentes equipos, que lo √∫nico que requieren es una interfaz de comunicaci√≥n clara.</p>

<p>Esto no quiere decir que la complejidad <em>general</em> se reduzca. De esto hablaremos en las desventajas.</p>

<h3 id="m√∫ltiples-versiones-y-reusabilidad">M√∫ltiples versiones y reusabilidad</h3>

<p>La implementaci√≥n de la interfaz de comunicaci√≥n es el √∫nico requisito indispensable para que un sistema cliente-servidor pueda seguir funcionando. Esto permite que un servidor pueda tener un n√∫mero indefinido de clientes diferentes que puedan consumir su interfaz y viceversa. En el caso de REST implementar el servidor con la API permite crear tantos clientes como se necesite:</p>

<ul>
  <li>p√°gina web</li>
  <li>aplicaci√≥n m√≥vil</li>
  <li>sistema embebido</li>
  <li>SDK para servidores</li>
</ul>

<p>S√≥lo para ilustrar:</p>

<p><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_800/v1562294072/PNG_image-5618E8EA3C0D-1_vk18wv.png" alt="Ilustraci√≥n de cliente-servidor multi-cliente" /></p>

<p>Tener N versiones de los clientes o poder crear una sin tener que volver a a replicar la funcionalidad del servidor ha hecho que las API‚Äôs se vuelvan sumamente populares.</p>

<h3 id="simplificaci√≥n-de-escalamiento">Simplificaci√≥n de escalamiento</h3>

<p>Poder tener separado el servidor permite que podamos escalarlo de forma independiente dependiendo del n√∫mero de clientes a los que va a atender. Si necesitamos dar un servicio a escala mundial podemos replicar nuestros servidores (usando las arquitecturas adecuadas para esto) sin afectar a los clientes y sin que ellos se enteren y por lo tanto tengan que hacer alg√∫n cambio.</p>

<h2 id="desventajas">Desventajas</h2>

<p>Todo en la vida viene con desventajas asociadas y generalmente directamente proporcionales a sus ventajas. Y otra vez: intercambiamos valor entre diferentes partes de la aplicaci√≥n. Analicemos algunas de estos intercambios que hacemos al aplicar la arquitectura cliente-servidor.</p>

<h3 id="complejidad-general-aumentada">Complejidad general aumentada</h3>

<p>Cuando dividimos la aplicaci√≥n y funciones completas en dos partes, aunque la complejidad de cada parte es menos que la general, la complejidad general aumenta porque hay que agregar elementos al sistema:</p>

<ul>
  <li>Interfaces de comunicaci√≥n entre cliente y servidor</li>
  <li>Mantenimiento o forma de recuperaci√≥n del estado general de la aplicaci√≥n</li>
  <li>Protocolos de comunicaci√≥n de red cuando es el caso</li>
</ul>

<h3 id="centralizaci√≥n-de-la-informaci√≥n">Centralizaci√≥n de la informaci√≥n</h3>

<p>El servidor es el responsable de almacenar la informaci√≥n y procesarla para darle servicio a los diferentes clientes que los soliciten, lo cual, aunque hace m√°s f√°cil su administraci√≥n, representa la desventaja de tener la informaci√≥n centralizada en el sistema que act√∫a como servidor. Si este sistema se corrompe de alguna forma, los clientes necesitan otras fuentes de informaci√≥n para eliminar este problema.</p>

<p>Combinar cliente-servidor con otra arquitecturas ayuda a mitigar esta falla. Por ejemplo, se puede implementar el patr√≥n de replicaci√≥n de repositorio en el lado de los proveedores de servicio.</p>

<p>Pero, un momento, ¬øacaso no es cliente-servidor la √∫nica arquitectura que existe para sistemas web o sistemas distribuidos?</p>

<h2 id="otras-arquitecturas">Otras arquitecturas</h2>

<p>La arquitectura para aplicaciones distribuidas m√°s escuchada es la cliente-servidor, pero no es ni de lejos la √∫nica. Analicemos otras dos arquitecturas comunes y d√≥nde se usan. Si quieres ver la lista completa que Fielding analiza puedes revisar la secci√≥n 2 de <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf">su tesis doctoral</a>.</p>

<h3 id="peer-to-peer">Peer to Peer</h3>

<p>En este estilo est√° compuesta por nodos equivalentes, es decir, que tiene la misma funci√≥n (aunque pueden tener diferente informaci√≥n) y que se distribuyen la carga que soporta el sistema entero seg√∫n las capacidades de cada uno y a veces se proporcionan servicios entre ellos. Un mismo nodo puede cambiar entre funciones o roles en la red dependiendo de la demanda.</p>

<p>En esta arquitectura no hay por definici√≥n un nodo m√°s importante que otro y si alguno de toda la red falla, puede ser sustituido por otro si tiene la informaci√≥n replicada.</p>

<p>Las redes de torrents, el blockchain y programas como Ares o LimeWire funcionaban de esta forma.</p>

<p>Una red peer-to-peer puede lucir as√≠:</p>

<p><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_871/v1561266301/PNG_image-CC8B051C8851-1_r78hfc.png" alt="Ejemplo de red peer to peer" /></p>

<p>Las redes peer-to-peer son una de las mejores formas de crear sistemas distribuidos resistentes y descentralizados, es decir, que no concentran la informaci√≥n en un s√≥lo punto que se vuelve el m√°s delicado e importante de todos.</p>

<h3 id="pipe-and-filter">Pipe and Filter</h3>

<p>En este patr√≥n, la informaci√≥n pasa por una series de ‚Äúfiltros‚Äù o nodos que la procesan y van dejando la informaci√≥n en un nuevo estado o con nuevas propiedades y que pasan la informaci√≥n al siguiente nodo. Este patr√≥n es el que siguen los pipelines de datos normalmente, en el que la informaci√≥n que es producida por una fuente externa es procesada a trav√©s de una serie de pasos, que pueden incluir la recolecci√≥n, limpieza, almacenamiento, etc.</p>

<p><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_800/v1562217820/PNG_image-C00985E33227-1_mevaqa.png" alt="Ilustraci√≥n de pipe and filter" /></p>

<h2 id="conclusi√≥n">Conclusi√≥n</h2>

<blockquote>
  <p>Los estilos arquitect√≥nicos el dise√±o de un sistema deben adecuarse a las necesidades de ese sistema, no al rev√©s. - Thomas Fielding</p>
</blockquote>

<p>¬øA qu√© necesidades nos adaptamos?</p>

<p>A la necesidad de tener una separaci√≥n clara entre las funciones de datos y procesos de negocio y las interfaces de usuario: sean usuarios finales humanos u otros programas que consumen informaci√≥n.</p>

<p>La arquitectura cliente-servidor permite simplificar el trabajo del lado del servidor al no tener que preocuparse por todas las distintas situaciones en las que sus datos o procesos van a ser usados.</p>

<p>Esto nos lleva a que sus procesos sean <strong>reutilizables</strong> por todos los clientes que sepan comunicarse con el servidor (l√©ase: usar su interfaz). A su vez los clientes son m√°s f√°ciles de crear por no tener en ellos mismos toda la l√≥gica del negocio y poder enfocarse en las funcionalidades de la entidad al que le van servir.</p>

<p>Y por √∫ltimo, esta separaci√≥n permite que el servidor sea f√°cil de escalar al nivel del servicio requerido.</p>

<p>Para los prop√≥sitos de REST la arquitectura Cliente-servidor es muy adecuada. Sus beneficios superan sus desventajas para este caso de uso particular.</p>
:ET