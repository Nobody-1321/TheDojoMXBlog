<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="https://blog.thedojo.mx/feed.xml" rel="self" type="application/atom+xml" /><link href="https://blog.thedojo.mx/" rel="alternate" type="text/html" /><updated>2020-09-01T01:10:55-05:00</updated><id>https://blog.thedojo.mx/feed.xml</id><author><name>Héctor Patricio</name><uri>https://github.com/hectorip</uri></author><entry><title type="html">A Philosophy of Software Design: Organiza bien los sistemas en capas</title><link href="https://blog.thedojo.mx/2020/09/01/a-philosophy-of-software-design-organiza-bien-los-sistemas-en-capas.html" rel="alternate" type="text/html" title="A Philosophy of Software Design: Organiza bien los sistemas en capas" /><published>2020-09-01T00:00:00-05:00</published><updated>2020-09-01T00:00:00-05:00</updated><id>https://blog.thedojo.mx/2020/09/01/a-philosophy-of-software-design-organiza-bien-los-sistemas-en-capas</id><content type="html" xml:base="https://blog.thedojo.mx/2020/09/01/a-philosophy-of-software-design-organiza-bien-los-sistemas-en-capas.html">&lt;p&gt;Hemos escuchado muchísimo acerca de los sistemas en capas como &lt;em&gt;Modelo-Vista-Controlador&lt;/em&gt;, &lt;em&gt;Modelo-Vista-Template, Modelo-Vista-*, _MVADFGDFD&lt;/em&gt; etc. y eso es porque la mayoría de los sistemas actuales se organiza así: &lt;strong&gt;en capas&lt;/strong&gt;. Además, nuestros módulos se dividen naturalmente en capas con diferentes funciones (como código que usa a otro).&lt;/p&gt;

&lt;p&gt;Hablemos de por qué es efectiva esta forma de organización (o patrón de arquitectura)
de código, de sus características y cómo podemos aprovecharla para sacar el máximo provecho.&lt;/p&gt;

&lt;h2 id=&quot;características-de-los-sistemas-en-capas&quot;&gt;Características de los sistemas en capas&lt;/h2&gt;

&lt;p&gt;Sabemos que la mejor forma de organización de un proyecto es &lt;strong&gt;descomponerlo&lt;/strong&gt; en partes independientes que &lt;strong&gt;oculten&lt;/strong&gt; información de otras.&lt;/p&gt;

&lt;p&gt;La comunicación entre las diferentes partes se da por medio de una &lt;strong&gt;interfaz&lt;/strong&gt;. Esta interfaz, es la &lt;strong&gt;API&lt;/strong&gt; del componente, ya que será usada de manera automática por otra parte del programa.&lt;/p&gt;

&lt;p&gt;En un sistema en capas el conjunto de elementos pertenecientes a una capa sólo se puede comunicar con la capa superior y con la capa inferior.&lt;/p&gt;

&lt;p&gt;Si un sistema tiene 10 capas, cada componente puede comunicarse máximo con 2 capas.&lt;/p&gt;

&lt;p&gt;En los sistemas más comunes, como el de 3 capas (MVC, MVT, MV*), sólamente la capa intermedia (el controlador, por ejemplo) puede comunicarse con dos capas, mientras que las otras sólo se comunican con la intermedia.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://amzn.to/2GdeHi5&quot;&gt;John Ousterhout&lt;/a&gt; usa la división en capas para explicar cómo se organiza el software con respecto al usuario final: la capa de “hasta arriba” es la que interactúa directamente con el usuario y la de “hasta abajo” es la más alejada del usuario, generalmente el núcleo de tu sistema.&lt;/p&gt;

&lt;p&gt;Hablemos ahora de las mejores prácticas según &lt;a href=&quot;https://amzn.to/2GdeHi5&quot;&gt;A Philosphy of Software Design&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;diferente-capa-diferente-abstracción&quot;&gt;Diferente capa, diferente abstracción&lt;/h2&gt;

&lt;p&gt;El concepto que debes tener más claro para descomponer tu software en capas es que cada capa debe tener sus propias abstracciones. Ousterhout da el ejemplo de un sistema de archivos:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;La capa que interactúa con el mundo exterior o la más alta, tiene la abstracción de un archivo&lt;/li&gt;
  &lt;li&gt;La siguiente capa tiene la abstracción de bloques de memoria y caché&lt;/li&gt;
  &lt;li&gt;La siguiente capa maneja directamente los bloques en el disco&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Esta abstracción es efectiva porque cada capa trabaja con abstracciones diferentes y no repiten ninguna entre ellas.&lt;/p&gt;

&lt;p&gt;Esta es la idea básica que debes checar en tus diseños, si notas que una abstracción no cambia de una capa a otra, algo está saliendo mal. ¿Cómo puedes identificarlas?&lt;/p&gt;

&lt;h3 id=&quot;funciones-de-paso&quot;&gt;Funciones de paso&lt;/h3&gt;

&lt;p&gt;Estos son funciones que no hacen nada mas que mandar llamar una función de la siguiente capa, normalmente para cumplir con la limitante de comunicación entre capas.&lt;/p&gt;

&lt;p&gt;Esto indica que no hay una división clara de responsabilidad entre clases o módulos. Para resolver este problema tienes que asegurarte de que la interfaz y la funcionalidad de este punto de tu sistema estén en el mismo módulo.&lt;/p&gt;

&lt;p&gt;Evitar este tipo de métodos te evitará complicar la interfaz sin añadir ninguna funcionalidad.&lt;/p&gt;

&lt;h3 id=&quot;variables-pasadas&quot;&gt;Variables pasadas&lt;/h3&gt;

&lt;p&gt;Similar al caso anterior, si tienes una variable que recibes en la llamada de tu módulo y no haces nada con ella mas que pasarla a una capa inferior, estás mezclando las abstracciones entre capas.&lt;/p&gt;

&lt;p&gt;A veces son necesarias, pero el manejarlas crea complejidad. Dependiendo del paradigma y el lenguaje de programación deberías buscar una solución adecuada.&lt;/p&gt;

&lt;p&gt;Por ejemplo, en lenguajes orientados a objetos podrías guardar todos lo valores a los que necesitas constante acceso desde diferentes lugares un una variable de “contexto” y que generalmente está almacenada en un lugar en el que todas tus funciones puedan acceder. Algunos frameworks usan su variable de &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings&lt;/code&gt; para poner información necesaria ahí.&lt;/p&gt;

&lt;p&gt;Los siguientes dos consejos tratan más los diferentes niveles de código que capas del sistema.&lt;/p&gt;

&lt;h3 id=&quot;evita-lo-más-que-puedas-los-decoradores&quot;&gt;Evita lo más que puedas los decoradores&lt;/h3&gt;

&lt;p&gt;Ousterhout habla en contra del patrón decorador. Este patrón consiste en envolver clases, objetos o funciones con otros, con el fin de extender la funcionalidad. Los decoradores intentan mantener una interfaz muy similar o exactamente igual al elemento original.&lt;/p&gt;

&lt;p&gt;Un ejemplo es la clase de Java &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BufferedInputStream&lt;/code&gt; es un decorador de &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InputStream&lt;/code&gt;, añadiéndole el buffering.&lt;/p&gt;

&lt;p&gt;Los decoradores pueden crear un montón de funciones y variables de pasada y agregar un montón de código de soporte sin de verdad agregar tanta funcionalidad como código.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;APoSD&lt;/strong&gt; (el libro) sugiere crear entidades separadas cuando sea posible y evitar el sobreuso de este patrón, a menos que de verdad tenga sentido, por ejemplo: cuando tienes un módulo muy profundo que con un decorador vas a poder reutilizar todo con muy poco código de soporte.&lt;/p&gt;

&lt;h3 id=&quot;abstracciones-diferentes-entre-la-interfaz-y-la-implementación&quot;&gt;Abstracciones diferentes entre la interfaz y la implementación&lt;/h3&gt;

&lt;p&gt;Tu código debería de exponer en su interfaz la abstracción más conveniente para los usuarios de tu módulo, sin importar las abstracciones más convenientes para manejar los datos internamente.&lt;/p&gt;

&lt;p&gt;Por este principio, es muy normal que las abstracciones de la interfaz no sean las mismas interfaces que tu implementación usa.&lt;/p&gt;

&lt;p&gt;Un ejemplo: imagina que estás escribiendo un componente que te permite editar texto. &lt;strong&gt;¿Cuál es la unidad básica con la que el usuario de tu módulo interactuará?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Puede ser un carácter, una línea, un párrafo. Ya que tu la visualización del texto es en líneas, lo más conveniente para la implementación es una abstracción que represente una línea de texto.&lt;/p&gt;

&lt;p&gt;Pero para el usuario de la clase que maneja texto lo más conveniente es una interfaz que use carácteres porque es más fácil de usar, se quita la responsabilidad de manejar las líneas.&lt;/p&gt;

&lt;p&gt;Entonces tu clase queda así: internamente representa el texto como un conjunto de líneas, pero las interfaces lo usan como si fuera un conjunto de caractéres en los que puedes insertar y borrar sin preocuparte por la organización en líneas.&lt;/p&gt;

&lt;h2 id=&quot;conclusión&quot;&gt;Conclusión&lt;/h2&gt;

&lt;p&gt;La separación en capas permitirá que tu código esté mejor organizado y que sea más fácil de entender. Tener cuidado con la forma en que las capas se organizan, cómo se dividen responsabilidades y las interfaces que cada capa expone hará mucho más mantenible y entendible tu base de código.&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><summary type="html">Resuelve problemas de organización de código mediante un sistema en capas.</summary></entry><entry><title type="html">Traducción automática: API’s vs tu propio modelo</title><link href="https://blog.thedojo.mx/2020/07/19/traduccion-automatica-de-textos-un-caso-practico.html" rel="alternate" type="text/html" title="Traducción automática: API’s vs tu propio modelo" /><published>2020-07-19T00:00:00-05:00</published><updated>2020-07-19T00:00:00-05:00</updated><id>https://blog.thedojo.mx/2020/07/19/traduccion-automatica-de-textos-un-caso-practico</id><content type="html" xml:base="https://blog.thedojo.mx/2020/07/19/traduccion-automatica-de-textos-un-caso-practico.html">&lt;p&gt;Traducir texto es una tarea frecuente y que puede realizarse de diferentes maneras, en este artículo queremos explorar algunas de ellas.&lt;/p&gt;

&lt;p&gt;Existen sitios donde la traducción puede hacerse en línea, como en &lt;a href=&quot;https://translate.google.com.mx/?hl=es&quot;&gt;Google Translate&lt;/a&gt;, sin embargo, en muchos casos existe un límite en la cantidad de texto que puedes traducir.&lt;/p&gt;

&lt;p&gt;También puedes utilizar &lt;strong&gt;APIs que pueden ayudarte a hacer dicho trabajo&lt;/strong&gt;, dichas APIs también tiene límites por traducción.&lt;/p&gt;

&lt;p&gt;Una solución que nos resulta interesante es la traducción utilizando algún modelo de &lt;strong&gt;Aprendizaje de Máquina&lt;/strong&gt; que ya haya sido previamente entrenado.  En este artículo podrás explorar estos diferentes métodos y el código que podrías utilizar para llevarlo a cabo, entendiendo las ventajas y desventajas que cada método ofrece.&lt;/p&gt;

&lt;p&gt;Hablemos de los diferentes métodos.&lt;/p&gt;

&lt;h2 id=&quot;interfaz-gráfica&quot;&gt;Interfaz gráfica&lt;/h2&gt;

&lt;p&gt;Google Translate te permite traducir 5,000 palabras a la vez en su interfaz. Si lo vas a hacer pocas veces y los textos no rebasan esa cantidad de palabras, ¿para qué construir algo?&lt;/p&gt;

&lt;p&gt;Esta opción nos recuerda que a veces la mejor solución es que no programemos nada.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ventajas&lt;/strong&gt;: Inmediata, fácil de usar y sin costo.
&lt;strong&gt;Desventajas&lt;/strong&gt;: Requiere intervención humana cada que se tenga que traducir algo.&lt;/p&gt;

&lt;h2 id=&quot;apis&quot;&gt;API’s&lt;/h2&gt;

&lt;p&gt;Si quieres automatizar las tareas de traducción para integrarlas en un sistema más grande o generar salidas que se queden almacenadas en archivos o bases de datos, una solución es crear un programa que consuma una API de traducción.&lt;/p&gt;

&lt;p&gt;Algunas opciones son:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Cloud Translation&lt;/strong&gt; de Google Cloud Platform. Tiene dos niveles de traducción: el básico que soporta el modelo tradicional de traducción y el avanzado que permite customizar los modelos de traducción además de incluir glosarios y otras monerías.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.ibm.com/watson/services/language-translator/&quot;&gt;Watson Language Translator&lt;/a&gt; permite traducir una gran cantidad de formatos de texto en muchos lenguajes. La única desventaja es que las API’s de IBM no son las más hermosas y en general sus sitemas de administración fallan bastante.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Otras&lt;/strong&gt;. En &lt;a href=&quot;https://rapidapi.com/collection/google-translate-api-alternatives&quot;&gt;RapidAPI&lt;/a&gt; puedes encontrar una colección actualizada de las alternativas a Google Translation API.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Para desarrollar esta pieza de software, lo más recomendable sería crear un wrapper alrededor de la API y exponer a las demás partes del programa sólo los métodos para poder realizar la tarea de traducción, abstrayendo completamente los detalles de cómo se realiza. De esta manera podrías cambiar de API fácilmente (implementando las llamadas a la nueva API) sin irrumpir en la mayoría del programa.&lt;/p&gt;

&lt;p&gt;Además esta forma de hacerlo también sería compatible con el siguiente método:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;AutoML Translation&lt;/strong&gt;. Pertenece también a GCP y permite entrenar un modelo mediante el envío de pares de frases para entrenar un modelo que posteriormente puedes usar para hacer traducciones sobre un dominio específico. Es el que más trabajo implicaría de tu parte pero es el que más flexibilidad de tiene.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ventajas&quot;&gt;Ventajas&lt;/h3&gt;

&lt;p&gt;Puedes olvidarte completamente de los detalles de implementación de la traducción, del hosting y mantenimiento de esta parte y probablemente las traducciones son muy precisas, como estamos acostumbrados a las de Google.&lt;/p&gt;

&lt;h3 id=&quot;desventajas&quot;&gt;Desventajas&lt;/h3&gt;

&lt;p&gt;Generalmente esta comodidad viene un costo económico que varía dependiendo del uso. La flexibilidad y capacidad de configuración de las API’s es variada y si no funciona como esperas es muy probable que no puedas hacer nada por mejorar la traducción.&lt;/p&gt;

&lt;h2 id=&quot;modelo-pre-entrenado-de-aprendizaje-de-máquina&quot;&gt;Modelo pre-entrenado de Aprendizaje de Máquina&lt;/h2&gt;

&lt;p&gt;Los modelos de Aprendizaje Profundo que se han desarrollado de manera importante en los últimos años han sustituido los modelos previos que utilizaban el conocimiento de lingüistas y décadas de investigación estadística.&lt;/p&gt;

&lt;p&gt;Una peculiaridad de un modelo de Aprendizaje Profundo es que logra detectar patrones de uso de los lenguajes y utilizar dichos patrones para realizar la traducción de uno a otro. Dichos patrones no tienen una representación equivalente de una palabra en un idioma a otra en un idioma distinto, sino que combinan los patrones internos de uso de las palabras en un idioma y después aplican los patrones que el otro idioma utilizaría. Eso hace que los traductores que utilizan aprendizaje profundo sean mucho más precisos y que las traducciones sean mucho más naturales, además de que pueden adaptarse a casos de uso específicos que los modelos anteriores no contemplaban. ¿Por qué? Porque podemos entrenarlos utilizando un conjunto de datos de entrenamiento que se enfoquen en un dominio específico del lenguaje (ej. traducción de subtítulos de películas, o traducción de textos técnicos).&lt;/p&gt;

&lt;p&gt;A pesar de ello, uno de los impedimentos más relevantes para su entrenamiento es que hasta hace algunos años, entrenar un modelo requería grandes cantidades de cómputo y memoria, cosa que ha ido cambiando conforme la industria ha ido evolucionando y los principales proveedores de cómputo han puesto a disposición del mundo, plataformas en la nube donde puede adquirirse poder computacional y de procesamiento de manera sencilla (AWS, Google, Microsoft, IBM, Oracle, etc.). De igual forma, las compañías que crean procesadores especializados (NVIDIA, AMD) también han logrado reducir los costos y poner en manos de cada vez más desarrolladores, tarjetas de video con Unidades de Procesamiento Gráfico (GPUs) a precios cada vez más accesibles.&lt;/p&gt;

&lt;p&gt;El modelo genérico de un sistema de traducción basado en Aprendizaje de Máquina consta de dos piezas principales (cada una de ellas una red neuronal por sí misma):&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Un  codificador de secuencias de palabras (que serían oraciones del texto) que aprende a codificar palabras como un arreglo de números que representa el significado de la oración.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Un decodificador de números, que toma un arreglo de números en general y los transforma en oraciones.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;La peculiaridad es que en el paso 1 obtenemos ese arreglo de números utilizando el lenguaje de orígen y la decodificación la hacemos hacia el lenguaje destino.&lt;/p&gt;

&lt;p&gt;Para poder capturar los patrones y relaciones que existen entre las palabras en una oración, es necesario que la red neuronal cuente con la capacidad de recordar las palabras dentro de una oración, ya que las relaciones de una palabra cualquiera serán mucho más fuertes con ciertas palabras que con otras, por ejemplo la relación entre “la” y “relación” será mucho más fuerte que “él” y “relación”, no esperaríamos poder encontrar un texto donde “él” y “relación” estén presentes en dicho orden específico.&lt;/p&gt;

&lt;p&gt;Esta capacidad de “recordar” de una red neuronal no existe en una red neuronal tradicional, donde las entradas pasan y son procesadas por todas las capas de la red sin hacer referencia a las palabras que pasaron antes o las palabras que pasaron después, por ello es que estos algoritmos utilizan un tipo de red neuronal llamado recurrente donde la última entrada influye en la siguiente predicción, esto permite a la red neuronal recurrente “aprender” el “significado” de cada palabra dentro de un contexto.&lt;/p&gt;

&lt;p&gt;En tiempos recientes, se han mejorado los modelos de procesamiento del “significado” de las palabras dentro de un contexto utilizando Transformadores que van incluso más allá del simple contexto de una palabra dentro de una oración, modelando las relaciones cruzadas entre cualquier palabra (previa o posterior) en vez de considerar únicamente el orden.&lt;/p&gt;

&lt;p&gt;Estos modelos requieren mucho más operaciones matemáticas durante su entrenamiento pero los patrones que pueden identificar las hacen mucho más poderosas, aún así los modelos de recurrentes arrojan resultados bastante aceptables.&lt;/p&gt;

&lt;p&gt;Existen casos en particular donde no es necesario entrenar tu propia red neuronal recurrente, ya que es probable que alguien más lo haya hecho ya. Esto puede ahorrarte muchas horas de procesamiento de información y el entrenamiento y validación del proceso de entrenamiento.&lt;/p&gt;

&lt;p&gt;El proceso que se sigue es:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Obtener un corpus o conjunto de datos sobre el problema que quieres resolver (por ejemplo, textos en el idioma de origen y en el idioma destino.&lt;/li&gt;
  &lt;li&gt;Limpieza y normalización de este corpus que remueva errores o piezas de los textos que sean incompletas o por ejemplo se puede decidir utilizar todas las palabras en minúsculas, separar las oraciones por ciertos símbolos de puntuación, etc. estas decisiones deberán tomarse teniendo en cuenta los objetivos para los cuales utilizaremos nuestro modelo de traducción, no es lo mismo un traductor de textos formateados de manera regular a textos que por ejemplo se vayan a utilizar como subtítulos para películas. Los pasos que normalmente se utilizarán tendrán como mínimo, código para separar las oraciones, y normalizar el texto.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;utilizando-un-modelo-de-traducción-prefabricado&quot;&gt;Utilizando un modelo de traducción prefabricado&lt;/h3&gt;

&lt;p&gt;Si quieres experimentar con este tipo de modelos te recomiendo empezar por el uso de un modelo pre-entrenado y dependiendo de los resultados evaluar si es necesario entrenar uno especializado en la tarea que estás buscando resolver.&lt;/p&gt;

&lt;p&gt;Aunque hay varios modelos disponibles, te dejo la liga a un framework hecho en C++ y que tiene un número mínimo de dependencias, se llama &lt;a href=&quot;https://marian-nmt.github.io/quickstart/&quot;&gt;Marian Neural Machine Translation&lt;/a&gt; y como parte de sus peculiaridades es que es eficiente, puede utilizar varios procesadores gráficos para el entrenamiento y soporta el uso de CPU o GPU para la traducción (al poder utilizar sólo CPU hace que el modelo pueda utilizarse en computadoras que no tienen tantos recursos).&lt;/p&gt;

&lt;p&gt;Y aquí hay un modelo pre-entrenado que puede utilizarse para traducciones de español a inglés: &lt;a href=&quot;https://github.com/ageitgey/spanish-to-english-translation&quot;&gt;Spanish to English Translation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Si tuvieras necesidad de entrenar la red neuronal sería necesario que tuvieras datos paralelos, es decir el mismo texto en los dos idiomas entre los cuales quieres hacer la traducción. Aquí te dejamos la liga a uno de ellos: &lt;a href=&quot;http://opus.nlpl.eu/&quot;&gt;The open parallel corpus&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;ventajas-1&quot;&gt;Ventajas&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Puede adaptarse mediante el entrenamiento, a un estilo o tipo específico de textos (textos científicos, técnicos, informales, subtítulos, etc.)&lt;/li&gt;
  &lt;li&gt;Puede utilizarse en modo “offline” sin necesidad de estar conectado a alguna fuente externa de internet.&lt;/li&gt;
  &lt;li&gt;No tiene costos o límites de uso, más que aquellos resultado de operar el modelo una vez entrenado (y de entrenarlo si fuera necesario hacerlo).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;desventajas-1&quot;&gt;Desventajas&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Entrenarlo requiere una gran cantidad de datos y un proceso de limpieza/normalización que no son técnicamente sencillos.&lt;/li&gt;
  &lt;li&gt;Es probable que no sea sencillo alcanzar el nivel de entrenamiento que las grandes compañías han utilizado para entrenar sus propios modelos (porque seguramente tienen fuentes bastante grandes de datos/procesadores gráficos/etc).&lt;/li&gt;
  &lt;li&gt;Escalarlo para su uso masivo puede ser todo un reto.&lt;/li&gt;
  &lt;li&gt;Las redes neuronales son cajas negras por lo que si se detecta algún error en la traducción normalmente será muy difícil saber en qué parte de los datos de entrenamiento se introdujo el error y por lo tanto será difícil removerlo.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;En el siguiente artículo te contaremos cómo nos fue con las pruebas.&lt;/p&gt;</content><author><name>Alejandro Santamaría</name><email>alexsmx@gmail.com</email><uri>https://github.com/alexsmx</uri></author><category term="apis" /><category term="machine-learning" /><category term="AI" /><summary type="html">Exploremos las opciones que tienes para realizar traducciones automáticas de texto en tus proyectos.</summary></entry><entry><title type="html">De Bash a Zsh</title><link href="https://blog.thedojo.mx/2020/07/16/de-bash-a-zsh.html" rel="alternate" type="text/html" title="De Bash a Zsh" /><published>2020-07-16T00:00:00-05:00</published><updated>2020-07-16T00:00:00-05:00</updated><id>https://blog.thedojo.mx/2020/07/16/de-bash-a-zsh</id><content type="html" xml:base="https://blog.thedojo.mx/2020/07/16/de-bash-a-zsh.html">&lt;p&gt;Con la reciente liberación de MacOS Catalina, Apple anunció que entre alguno de los cambios al sistema operativo, se utilizará a partir de esta versión un nuevo &lt;em&gt;shell&lt;/em&gt; que de manera regular se utilizaba en la app Terminal y en otras aplicaciones utilizadas por los desarrolladores para interactuar con la Mac a través de la línea de comandos.&lt;/p&gt;

&lt;p&gt;El shell que se utilizaba previo a esta versión era &lt;strong&gt;Bash&lt;/strong&gt; (&lt;em&gt;Bourne Again Shell&lt;/em&gt;) y el que se utilizará ahora es &lt;strong&gt;Zsh&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;qué-es-un-shell&quot;&gt;¿Qué es un shell?&lt;/h2&gt;

&lt;p&gt;En resumen, un shell es un programa que permite &lt;strong&gt;controlar la computadora a través de comandos de texto&lt;/strong&gt;, normalmente se trata de interfaces de texto interactivo, donde el usuario podrá ir &lt;strong&gt;tecleando comandos para obtener información&lt;/strong&gt; o ejecutar comandos y obtener resultados a través de la misma interfaz.&lt;/p&gt;

&lt;p&gt;A lo largo de la historia se han creado diferentes shells, cada uno con una serie de comandos que ponen a disposición de los usuarios &lt;strong&gt;funcionalidades específicas&lt;/strong&gt; de sus sistemas operativos. ¿Y porqué estaría alguien interesado en usar un shell y una línea de comandos para controlar una computadora? Para entenderlo hay que viajar un poco en el tiempo.&lt;/p&gt;

&lt;h3 id=&quot;historia&quot;&gt;Historia&lt;/h3&gt;

&lt;p&gt;Inicialmente, controlar una computadora era una tarea difícil, las primeras de ellas se controlaban mediante diferentes dispositivos (interruptores, tarjetas perforadas, etc.) que “cargaban” en memoria las distintas piezas de información que serían procesados en forma de programas. Este proceso era regularmente &lt;strong&gt;tedioso y sujeto a errores&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;En algunos casos, el primer programa que se cargaba en memoria era un programa que permitía cargar instrucciones adicionales a través de la lectura de datos en las mismas tarjetas perforadas. De igual forma, los resultados de la ejecución normalmente se plasmaban en papel o tarjetas similares a las que se utilizaban para su carga.&lt;/p&gt;

&lt;p&gt;Conforme fueron evolucionando los computadores, los programas permitieron el uso de dispositivos de entrada más amigables para el usuario de la computadora, como Teletipos, que permitían enviar comandos desde teclados y terminales remotas al ordenador (remoto en un sentido práctico, quizás de un cuarto a otro). Esta forma de transmitir comandos y obtener resultados era mucho más sencilla que estar cargando información a través de interruptores o tarjetas perforadas.&lt;/p&gt;

&lt;p&gt;La pregunta natural es: si esto fue la primer evolución hacia un uso más sencillo de las computadoras, &lt;strong&gt;¿por qué se sigue utilizando?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Aunque la evolución de las computadoras ha seguido su curso y la interacción Humano-Computador ha avanzado en diferentes vertientes, por ejemplo, &lt;strong&gt;mediante la implementación de interfaces gráficas&lt;/strong&gt;, el uso de la interfaz de línea de comandos se ha mantenido vigente por diversas razones:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Por su &lt;strong&gt;versatilidad&lt;/strong&gt;, es posible utilizarlo para resolver distintos tipos de problemas y con distintos tipos de opciones que harían muy difícil su integración completa en una interfaz gráfica.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Por su &lt;strong&gt;poder&lt;/strong&gt;, al tener acceso a las funciones centrales del sistema operativo, también contempla casos de uso para los cuales las interfaces gráficas no están preparados.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Permite crear programas que hacen uso de las capacidades nativas y extendidas del sistema operativo y ejecutar dichos programas o scripts en distintas modalidades, por ejemplo, de manera repetitiva a través de trabajos programados (cron jobs) o en conjunto con otros programas (por ejemplo con ambientes de desarrollo integrados). A esto le podemos llamar &lt;strong&gt;automatización de tareas&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;El programa de shell específico (en este caso Bash o Zsh), definen su interfaz con el usuario, no sólo en la manera en la que presentarán la linea de comando sino también en las &lt;strong&gt;capacidades y comandos que soportan de manera nativa&lt;/strong&gt;, en general, podemos encontrar algunas de estas características:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Una sintaxis que define los comandos y secuencias de comando que el shell ‘entenderá’.&lt;/li&gt;
  &lt;li&gt;Comandos que darán acceso a las ‘operaciones’ que el shell puede ejecutar .&lt;/li&gt;
  &lt;li&gt;Funciones que permiten agrupar comandos para ejecutar labores más complejas.&lt;/li&gt;
  &lt;li&gt;Parámetros para almacenar valores para su uso durante la ejecución de las funciones y comandos.&lt;/li&gt;
  &lt;li&gt;Expansión que define la forma en la que los parámetros en un comando son aplicados.&lt;/li&gt;
  &lt;li&gt;Flujo y redirección que controla las entradas y salidas de y desde los comandos.&lt;/li&gt;
  &lt;li&gt;Ejecución que define lo que sucede cuando cada comando corre.&lt;/li&gt;
  &lt;li&gt;Scripting que permite ejecutar archivos que contienen una lista de comandos y/o funciones.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;porqué-razón-puede-estar-cambiando-apple-de-un-shell-a-otro&quot;&gt;¿Porqué razón puede estar cambiando Apple de un shell a otro?&lt;/h2&gt;

&lt;p&gt;Existen varias posibilidades, la primera de ellas es que aunque Apple utiliza Bash desde OSX Jaguar, no había actualizado Bash desde la versión 3.2 liberada en el 2007, es decir casi el mismo año en el que se liberó el primer iPhone. Es probable que una de las razones por las que esto sucedió fue que Bash cambió su licencia de uso de &lt;strong&gt;GNU GPL 2 a una licencia GNU GPLv3&lt;/strong&gt;, y dicho cambio incluía restricciones que quizás no fueron del todo favorables a Apple.&lt;/p&gt;

&lt;p&gt;Así que migrar a Zsh es una opción refrescante. La versión que está incluida en Catalina es la 5.7.1 y utiliza una versión de licenciamiento &lt;strong&gt;MIT que es menos restrictiva que la GPLv3&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;qué-sucederá-con-bash-tendré-que-dejar-de-usarlo&quot;&gt;¿Qué sucederá con Bash, tendré que dejar de usarlo?&lt;/h2&gt;

&lt;p&gt;No necesariamente, aunque Zsh será el shell por default para todas las nuevas cuentas de usuario creadas en macOS Catalina, si tu hiciste un upgrade del Sistema Operativo, tu cuenta seguirá utilizando por default Bash. Pero siempre tendrás opción de configurar el shell que desees por default de manera voluntaria, incluso a alguno distinto a Zsh o Bash.&lt;/p&gt;

&lt;p&gt;A nivel general, Bash y Zsh tienen un nivel de compatibilidad bastante alto ya que &lt;strong&gt;ambos están basados en el aún más antiguo Bourne Shell&lt;/strong&gt;, de tal forma que la mayoría de los scripts y comandos existentes funcionarán sin ningún cambio en Zsh.&lt;/p&gt;

&lt;p&gt;La ventaja real de Zsh es la inclusión de funcionalidades que hacen trabajar con él más fácil (funcionalidades no incluidas por default en la versión vieja de Bash), entre algunas de mis funcionalidades favoritas están:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Auto completado de comandos&lt;/li&gt;
  &lt;li&gt;Auto corrección de comandos&lt;/li&gt;
  &lt;li&gt;Integración con algunos sistemas de uso común para desarrolladores (git)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;qué-sucederá-con-mis-scripts-hechos-en-bash&quot;&gt;¿Qué sucederá con mis scripts hechos en Bash?&lt;/h2&gt;

&lt;p&gt;En general, correrán de igual forma a como lo venían haciendo, sin embargo en casos muy peculiares podrías requerir modificarlos o simplemente agregar #!/bin/bash (&lt;em&gt;shebang&lt;/em&gt;) para forzar a que el script utilice el shell de Bash que sigue incluyéndose en MacOS.&lt;/p&gt;

&lt;p&gt;Puedes usar temporalmente uno u otro shell simplemente invocando su nombre en la línea de comandos (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zsh&lt;/code&gt; o &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bash&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;En la Mac, podrás configurar el shell default en las Preferencias del Sistema, en el panel de Usuarios y Grupos, podrás seleccionar la cuenta de un usuario y en las Opciones Avanzadas podrás seleccionar uno de los shells disponibles.&lt;/p&gt;

&lt;h2 id=&quot;conclusión-y-referencias&quot;&gt;Conclusión y referencias&lt;/h2&gt;

&lt;p&gt;Dominar tu shell &lt;strong&gt;hará que tu trabajo diario sea más sencillo&lt;/strong&gt; ya que podrás configurar funcionalidades que aumenten tus capacidades como desarrollador y en conjunto con el conocimiento a profundidad de tu interfaz de desarrollo, podrá hacerte mucho más eficiente al momento de administrar y ejecutar comandos que tengan que ver con tus proyectos.&lt;/p&gt;

&lt;p&gt;Algunos recursos que te ayudarán:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;La &lt;a href=&quot;http://zsh.sourceforge.net/&quot;&gt;documentación de Zsh&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Configuración Zsh es mediante &lt;a href=&quot;https://ohmyz.sh/&quot;&gt;Oh My Zsh&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;¿Donde se configuran las funcionalidades de Zsh? En &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;¿Cómo  saber que shell estoy usando?&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;o&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$SHELL&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;¿Cómo configurar Zsh como mi shell default?&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;chsh &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; /bin/zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;¿Cómo activar el autocomplete?&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;autoload &lt;span class=&quot;nt&quot;&gt;-U&lt;/span&gt; compinit &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; compinit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;¿Cómo activar la extensión para git?&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;autoload &lt;span class=&quot;nt&quot;&gt;-Uz&lt;/span&gt; vcs_info
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;¿Cómo configurar el cambio de directorio automático?
    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;setopt autocd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;referencias&quot;&gt;Referencias&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.bash.academy/&quot;&gt;Bash academy&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://news.ycombinator.com/item?id=10737639&quot;&gt;Discusión en YCombinator&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.rayninfo.co.uk/tips/zshtips.html?LMCL=bNg6o6&quot;&gt;Zsh tips&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://leahneukirchen.org/blog/archive/2008/02/10-zsh-tricks-you-may-not-know.html&quot;&gt;10 trucos de Zsh&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://zsh.sourceforge.net/Guide/zshguide.html&quot;&gt;Zsh Guide&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.tldp.org/LDP/abs/html/&quot;&gt;Advanced Bash-Scripting Guide&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://matt.might.net/articles/bash-by-example/&quot;&gt;Bash by example&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Libro: &lt;a href=&quot;https://amzn.to/32phs95&quot;&gt;From Bash to Zsh&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Alejandro Santamaría</name><email>alexsmx@gmail.com</email><uri>https://github.com/alexsmx</uri></author><category term="shell" /><category term="zsh" /><category term="bash" /><category term="terminal" /><summary type="html">Zsh es el nuevo shell default de MacOS Catalina. Entiende las principales diferencias entre Bash y Zsh.</summary></entry><entry><title type="html">Recursos para aprender Arquitectura de Software</title><link href="https://blog.thedojo.mx/2020/07/15/recursos-para-aprender-arquitectura-de-software.html" rel="alternate" type="text/html" title="Recursos para aprender Arquitectura de Software" /><published>2020-07-15T00:00:00-05:00</published><updated>2020-07-15T00:00:00-05:00</updated><id>https://blog.thedojo.mx/2020/07/15/recursos-para-aprender-arquitectura-de-software</id><content type="html" xml:base="https://blog.thedojo.mx/2020/07/15/recursos-para-aprender-arquitectura-de-software.html">&lt;p&gt;Tuvimos una plática con &lt;a href=&quot;https://twitter.com/machinesareus&quot;&gt;Agustín Ramos&lt;/a&gt; acerca de la arquitectura de software y lo que debes aprender para practicarla. Este pequeño artículo incluye nuestro resumen y las recomendaciones de Agustín.&lt;/p&gt;

&lt;h2 id=&quot;qué-es-la-arquitectura-de-software&quot;&gt;¿Qué es la arquitectura de software?&lt;/h2&gt;

&lt;p&gt;La arquitectura del software incluye el &lt;strong&gt;diseño del sistema&lt;/strong&gt; a alto nivel: la descomposición del sistema en módulos, la descripción de las responsabilidades de cada uno y sus relaciones.&lt;/p&gt;

&lt;p&gt;También incluye las prácticas y herramientas que permitirán que el proyecto cumpla con los &lt;strong&gt;atributos de calidad&lt;/strong&gt; o requerimientos no funcionales.&lt;/p&gt;

&lt;p&gt;Todo lo anterior está basado en un análisis de las &lt;em&gt;funciones&lt;/em&gt; y &lt;em&gt;atributos de calidad&lt;/em&gt; del sistema.&lt;/p&gt;

&lt;h1 id=&quot;el-proceso&quot;&gt;El proceso&lt;/h1&gt;

&lt;p&gt;En la plática tocamos 5 etapas del desarrollo de una arquitectura:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Descubrimiento y definición de los atributos de calidad.&lt;/strong&gt; Básicamente consiste en entender el problema, escuchar a todos los involucrados en el proyecto y definir los atributos del software que no están directamente relacionados con la funcionalidad, pero que debe de cumplir.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Diseño del sistema.&lt;/strong&gt; Generalmente te ayudarás de estilos de arquitectura y patrones de diseño para llegar a los objetivos funcionales y no funcionales.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Validación del diseño.&lt;/strong&gt; Mediante la creación de prototipos se puede validar que las asunciones principales acerca del diseño y su relación con los atributos de calidad se cumplen. Esto puede derivar en &lt;em&gt;cambios&lt;/em&gt; sobre el diseño que lo mejoren.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Comunicación del diseño.&lt;/strong&gt; Después de definir la arquitectura es importante comunicar el diseño al equipo mediante un exposición directa y la documentación. Esta documentación debe incluir la mayor información posible sobre la razón de las decisiones y la evolución de la arquitectura.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Seguimiento del diseño.&lt;/strong&gt; Esto incluye varias cosas:&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;Verificación de que el equipo está siguiendo el diseño.&lt;/em&gt; Esto se logra con revisiones constantes con el equipo: programación en parejas y revisión de código.&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;El diseño nunca está está escrito en piedra&lt;/em&gt;. Después de las revisiones de código se descubrirán cosas que no están funcionando como se esperaba, por lo que será necesario modificar el diseño y dejar registro de los cambios y las decisiones tomadas.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;consejos-específicos&quot;&gt;Consejos específicos&lt;/h2&gt;

&lt;p&gt;Los arquitectos de software deben encontrar la solución más simple posible porque si no va a ser rígida.&lt;/p&gt;

&lt;p&gt;Acerca de la &lt;strong&gt;documentación&lt;/strong&gt;, Agustín recomienda, exponerla al equipo en una junta y hacer un video de esto, que se le pase a cada integrante del equipo. Se puede seguir el marco llamado &lt;a href=&quot;https://www.cs.ubc.ca/~gregor/teaching/papers/4+1view-architecture.pdf&quot;&gt;“Arquitectura 4 + 1”&lt;/a&gt; que se compone de:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Vista de Componentes&lt;/li&gt;
  &lt;li&gt;Vista de Desarrollo&lt;/li&gt;
  &lt;li&gt;Vista de Procesos&lt;/li&gt;
  &lt;li&gt;Vista Física&lt;/li&gt;
  &lt;li&gt;Vista de Casos (Este es el +1)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Además, tenemos que mantener una bitácora de los cambios y los factores que los impulsaron, esto puede ser mediante los &lt;a href=&quot;https://adr.github.io/&quot;&gt;Architectural Decision Records&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;cómo-empezar&quot;&gt;Cómo empezar&lt;/h2&gt;

&lt;p&gt;Agustín nos recomendó algunos recursos para que empieces a aprender:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.goodreads.com/book/show/179204.Object_Design?from_search=true&amp;amp;from_srp=true&amp;amp;qid=3yFmpRp03n&amp;amp;rank=6&quot;&gt;Object Design - Rebecca Wirfs-Brock&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.goodreads.com/book/show/70143.Software_Architecture_in_Practice?from_search=true&amp;amp;from_srp=true&amp;amp;qid=mnXRSoVML7&amp;amp;rank=1&quot;&gt;Software Architecture in Practice&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Como alternativa al libro anterior  se recomienda Technical Report sobre arquitectura del Software Engineering Institute, encontré varios, tienes un ejemplo &lt;a href=&quot;https://pure.au.dk/portal/files/20484966/tech-report-5.pdf&quot;&gt;aquí&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://pragprog.com/titles/mkdsa/&quot;&gt;Design it! - Micheal Keeling&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;La serie &lt;a href=&quot;&quot;&gt;Pattern-orinted Software Architecture&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Para aprender patrones de diseño se habló de los siguientes libros:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.amazon.com.mx/dp/0201633612?tag=amz-mkt-chr-mx-20&amp;amp;ascsubtag=1ba00-01000-a0087-mac00-other-nomod-mx000-pcomp-feature-scomp-wm-5&amp;amp;ref=aa_scomp&quot;&gt;Patrones de Diseño - Erich Gamma, et Al.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.amazon.com/Patterns-Handbook-Techniques-Strategies-Applications/dp/0521648181&quot;&gt;The patterns handbook&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;La serie &lt;a href=&quot;https://www.amazon.com.mx/Pattern-Languages-Program-Design-Coplien/dp/0201607344/ref=sr_1_3?dchild=1&amp;amp;keywords=Pattern+Languages+of+Program+Design&amp;amp;qid=1594823984&amp;amp;s=books&amp;amp;sr=1-3&quot;&gt;Pattern language of program design (5 libros)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Y entre los libros que se mencionan como la fuente de las ideas de patrones y diseño:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.amazon.com.mx/Phenomenon-Life-Building-Nature-Universe/dp/0972652914/ref=pd_sim_14_1/132-2199838-9714154?_encoding=UTF8&amp;amp;pd_rd_i=0972652914&amp;amp;pd_rd_r=43c91cc2-6447-4629-a6d7-fb29dc8fd2d7&amp;amp;pd_rd_w=gNuac&amp;amp;pd_rd_wg=g8gOe&amp;amp;pf_rd_p=a62f455d-612d-4136-9fd7-44067fe2cd11&amp;amp;pf_rd_r=86FX03JZ655BENFVMSC0&amp;amp;psc=1&amp;amp;refRID=86FX03JZ655BENFVMSC0&quot;&gt;The nature of order de Christopher Alexander&lt;/a&gt; y los otros libros de él como &lt;a href=&quot;https://www.amazon.com.mx/Professor-Department-Architecture-Christopher-Alexander/dp/0195024028/ref=pd_sim_14_3/132-2199838-9714154?_encoding=UTF8&amp;amp;pd_rd_i=0195024028&amp;amp;pd_rd_r=c4dd6dad-be5f-4a11-a037-a4ecd8f56915&amp;amp;pd_rd_w=CYjKZ&amp;amp;pd_rd_wg=x61DA&amp;amp;pf_rd_p=a62f455d-612d-4136-9fd7-44067fe2cd11&amp;amp;pf_rd_r=JWAJ48WRNHYPDZ8RC2R1&amp;amp;psc=1&amp;amp;refRID=JWAJ48WRNHYPDZ8RC2R1&quot;&gt;A timeless way of building&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.amazon.com.mx/Art-Scalability-Architecture-Organizations-Enterprise/dp/0134032802/ref=sr_1_1?__mk_es_MX=%C3%85M%C3%85%C5%BD%C3%95%C3%91&amp;amp;dchild=1&amp;amp;keywords=the+art+of+scalability&amp;amp;qid=1594824264&amp;amp;s=books&amp;amp;sr=1-1&quot;&gt;The art of Scalability&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;el-capítulo&quot;&gt;El capítulo&lt;/h2&gt;

&lt;p&gt;De todos modos no te pierdas el capítulo, que estuvo muy bueno:&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/vfu5PsSH7us&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="podcast" /><category term="thedojomx" /><category term="arquitecturaarquitectura_de_software" /><category term="libros" /><summary type="html">¿Qué es la arquitectura de software y cómo puedes empezar a aprenderla? Aquí te damos un resumen de una plática muy interesante que tuvimos.</summary></entry><entry><title type="html">¿Qué es el pensamiento computacional?</title><link href="https://blog.thedojo.mx/2020/07/09/que-es-el-pensamiento-computacional.html" rel="alternate" type="text/html" title="¿Qué es el pensamiento computacional?" /><published>2020-07-09T00:00:00-05:00</published><updated>2020-07-09T00:00:00-05:00</updated><id>https://blog.thedojo.mx/2020/07/09/que-es-el-pensamiento-computacional</id><content type="html" xml:base="https://blog.thedojo.mx/2020/07/09/que-es-el-pensamiento-computacional.html">&lt;p&gt;Todo lo relacionado con el &lt;strong&gt;pensamiento computacional&lt;/strong&gt; (la programación, la inteligencia artificial, las computadoras) ha estado muy presente en la mente de la sociedad, porque vivimos en un mundo en el que &lt;em&gt;cada aspecto de la vida&lt;/em&gt; se ha visto influenciado por lo que la computación permite.&lt;/p&gt;

&lt;p&gt;En varios lugares del mundo se ha pensado que se debe agregar el pensamiento computacional a la educación básica que todos reciben, bajo la promesa de que mejorará en general la &lt;strong&gt;capacidad de pensar y resolver problemas&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Hablemos de qué es el pensamiento computacional y cómo te puede ayudar a comprender mejor el mundo creado con la ayuda de las computadoras.&lt;/p&gt;

&lt;h2 id=&quot;qué-es-el-pensamiento-computacional&quot;&gt;¿Qué es el pensamiento computacional?&lt;/h2&gt;

&lt;p&gt;No hay una definición clara, y todo el tiempo está cambiando lo que se entiende por este término, pero podemos dar una definición decente como la &lt;strong&gt;habilidad mental&lt;/strong&gt; y las prácticas que nos permiten &lt;em&gt;diseñar cálculos&lt;/em&gt; para que las computadoras realicen un trabajo.&lt;/p&gt;

&lt;p&gt;Otra acepción es la capacidad de entender el mundo como un &lt;strong&gt;complejo de procesos de información&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Estas dos habilidades combinadas pueden ayudarte a resolver muchos problemas y a navegar mejor el mundo moderno.&lt;/p&gt;

&lt;p&gt;Por ejemplo, para tener la capacidad de diseñar algoritmos para las computadoras modernas debes entender las bases del funcionamiento y eso necesariamente te llevará a entender sus &lt;strong&gt;limitaciones y fortalezas&lt;/strong&gt;, lo cuál te llevará a evitar que te engañen fácilmente.&lt;/p&gt;

&lt;p&gt;Tener conocimiento de las capacidades además nos hace conscientes de lo que una empresa o gobierno con los suficientes recursos puede lograr en los campo de manipulación y colección de datos, inteligencia artificial, &lt;strong&gt;vigilancia&lt;/strong&gt;, seguridad e influencia sobre los pensamientos colectivos.&lt;/p&gt;

&lt;p&gt;El pensamiento computacional ha avanzado en por lo menos &lt;strong&gt;seis áreas&lt;/strong&gt;. Veamos lo que estas abarcan.&lt;/p&gt;

&lt;h2 id=&quot;métodos-computacionales&quot;&gt;Métodos computacionales&lt;/h2&gt;

&lt;p&gt;Los matemáticos e ingenieros a lo largo de la historia han buscado desarrollar métodos para hacer &lt;strong&gt;más eficientes los cálculos y poder calcular más cosas automáticamente&lt;/strong&gt;. Esto ha permitido que calculemos cosas que en cierto tiempo se creían imposibles.&lt;/p&gt;

&lt;p&gt;Gran parte del trabajo que se ha realizado está dedicado a que los cálculos se puedan realizar sin entendimiento e intuición. Es por eso que se han ido desarrollando áreas de las matemáticas que tienen que ver directamente con esto:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;La lógica&lt;/li&gt;
  &lt;li&gt;El álgebra booleana&lt;/li&gt;
  &lt;li&gt;La teoría de autómatas.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Todo esto es con el objetivo de realizar &lt;strong&gt;cálculos libres de errores&lt;/strong&gt; lo más rápidamente posible. Algunas de las tareas principales que los métodos de cómputo incluyen son:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Descomposición de problemas en problemas más sencillos&lt;/li&gt;
  &lt;li&gt;Distribución de la ejecución de los cálculos en diferentes tiempos y ejecutores&lt;/li&gt;
  &lt;li&gt;Chequeo y corrección de errores&lt;/li&gt;
  &lt;li&gt;Representación de información&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;máquinas&quot;&gt;Máquinas&lt;/h2&gt;

&lt;p&gt;La computación está casada con un &lt;em&gt;medio&lt;/em&gt; que ejecute los cálculos. Estas son las computadoras, que han variado con el paso del tiempo.&lt;/p&gt;

&lt;p&gt;La principal motivación de buscar máquinas automáticas que realizaran los cálculos es eliminar los &lt;strong&gt;problemas inherentes&lt;/strong&gt; a los cálculos realizados por humanos: son lentos y propensos a errores.&lt;/p&gt;

&lt;p&gt;Los medios en los que se ejecutan los cálculos han ido evolucionando hasta llegar a los microprocesadores que tenemos hoy que pueden realizar una infinidad de cálculos en poco tiempo.&lt;/p&gt;

&lt;p&gt;Para diseñar y trabajar con estas máquinas, se tienen que entender muchos conceptos, que el pensamiento computacional trata:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Representación de información digitalmente y señales eléctricas como códigos binarios&lt;/li&gt;
  &lt;li&gt;Diseño de circuitos&lt;/li&gt;
  &lt;li&gt;Temporización con reloj de los cálculos&lt;/li&gt;
  &lt;li&gt;Control de flujo&lt;/li&gt;
  &lt;li&gt;Loops&lt;/li&gt;
  &lt;li&gt;Memoria digital&lt;/li&gt;
  &lt;li&gt;Espacios de memoria&lt;/li&gt;
  &lt;li&gt;Aislamiento de procesos&lt;/li&gt;
  &lt;li&gt;Tolerancia a fallos&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Todo esto está casado con el concepto de computadora digital que tenemos hoy (el modelo de von Neumann), pero &lt;strong&gt;existen otro tipo de computadoras&lt;/strong&gt; que no ejecutan cálculos en la misma forma.&lt;/p&gt;

&lt;p&gt;Dos ejemplos de esto son las redes neuronales y las computadoras cuánticas, que no necesitan una serie de “pasos” para resolver los cálculos y tienen un tipo de pensamiento computacional completamente diferente.&lt;/p&gt;

&lt;p&gt;Es en este punto en donde la computación deja de ser un campo específicamente de las matemáticas y la lógica, ya que los cálculos y los procedimientos realizados están &lt;strong&gt;estrechamente ligados al medio de ejecución&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;De este apartado lo último que tenemos que mencionar es que toda la revolución del mundo que vemos hoy causada por las computadoras está causada por la &lt;strong&gt;gran velocidad&lt;/strong&gt; que las computadoras han alcanzado. Sin esto, que es difícil de comprender (ve la cita de abajo), no podríamos ver todo lo que las computadoras han causado hoy.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;154,300,000,000 de operaciones por segundo en el procesador del iPhone 11 Pro.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;educación-de-ciencias-de-la-computación&quot;&gt;Educación de ciencias de la computación&lt;/h2&gt;

&lt;p&gt;Difundir el conocimiento para crear procedimientos que las computadoras automáticas puedan ejecutar es una de las principales tareas y &lt;em&gt;responsabilidades&lt;/em&gt; del pensamiento computacional.&lt;/p&gt;

&lt;p&gt;Al ser una combinación de ingeniería, matemáticas y ciencia la computación nació como un campo nuevo de estudios que tomó tiempo en ser reconocido y abrazado como una ciencia más.&lt;/p&gt;

&lt;p&gt;Las ciencias de la computación han sido entendidas de diferentes formas a lo largo del tiempo:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Como los fenómenos que rodean a las computadoras&lt;/li&gt;
  &lt;li&gt;Entendiendo la programación como un arte y una ciencia&lt;/li&gt;
  &lt;li&gt;Computación == Automatización&lt;/li&gt;
  &lt;li&gt;Entendimiento del universo como una computadora gigantezca&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Estas etapas del entendimiento de las ciencias de la computación han modificado la forma en que el pensamiento computacional es entendido.&lt;/p&gt;

&lt;h2 id=&quot;ingeniería-del-software&quot;&gt;Ingeniería del Software&lt;/h2&gt;

&lt;p&gt;El software son los programas que las computadoras digitales modernas ejecutan para realizar los cálculos que les permiten realizar todas las tareas a las que estamos acostumbrados.&lt;/p&gt;

&lt;p&gt;La &lt;strong&gt;construcción de software&lt;/strong&gt; es una da las tareas más importantes que se relacionan con el pensamiento computacional. Lo más importante de esta área es la entrega confiable de software listo para entornos de la vida real (&lt;em&gt;de producción&lt;/em&gt;), que tiene las siguientes características:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Confiable (no falla constantemente)&lt;/li&gt;
  &lt;li&gt;Usable (cumple con su función, a una velocidad adecuada)&lt;/li&gt;
  &lt;li&gt;Seguro (no causa daños y no se puede robar información)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hacer software con estas características es una tarea súmamente difícil por la complejidad que implica.&lt;/p&gt;

&lt;p&gt;La ingeniería es “la aplicación de las matemáticas y la ciencia a los problemas de las personas”. Así, la ingeniería de software busca establecer &lt;strong&gt;técnicas y procedimientos para desarrollar software correcto&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Además la ingeniería del software ha buscado desarrollar herramientas que faciliten el desarrollo de software. Es un área muy compleja del pensamiento computacional que está constante evolución y el principal problema de la industria del software actual.&lt;/p&gt;

&lt;h2 id=&quot;diseño-de-software&quot;&gt;Diseño de Software&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;El buen diseño produce un objeto que funciona para las personas en un contexto de necesidades y valores, para producir resultados de calidad y una &lt;strong&gt;experiencia satisfactoria&lt;/strong&gt;. - Terry Winograd&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;El software muchas veces está hecho para interactuar con personas. La tarea del diseñador de software es diseñar programas que &lt;strong&gt;resuelvan los problemas de los usuarios&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Esto tiene que ver con la forma de usarlo, las interfaces que presentará a los usuarios, las funciones, las actualizaciones, la protección de información, los medios de presentación y muchas más tareas relacionadas con &lt;strong&gt;crear software que deleite al usuario&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;La principal diferencia con la ingeniería de software es que mientras la ingeniería está pensada desde el punto de vista &lt;strong&gt;del programador&lt;/strong&gt;, el diseño está pensado desde el punto de vista &lt;strong&gt;del usuario&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Es decir, la ingeniería asegura que el programa funciona como el programador desea, el diseño asegura que el programa hace lo que el usuario necesita.&lt;/p&gt;

&lt;h2 id=&quot;ciencia-computacional&quot;&gt;Ciencia computacional&lt;/h2&gt;

&lt;p&gt;La ciencia ha sido completamente revolucionada por lo que la computación electrónica automática permite, desde grandes cantidades de cálculos en poco tiempo hasta simulaciones de los procesos naturales.&lt;/p&gt;

&lt;p&gt;Desde que la computación automática existe, ha sido una gran ayuda para llegar a lugares que no se había siquiera podido soñar. Incluso se han creado &lt;strong&gt;nuevas ciencias&lt;/strong&gt;, que son la combinación de una ciencia tradicional con la computación como “Biología computacional”.&lt;/p&gt;

&lt;p&gt;Pero la ciencia computacional requiere su &lt;strong&gt;propio tipo de pensamiento computacional&lt;/strong&gt;, desde los métodos hasta el software creado. No se aplican las misma técnicas ni herramientas que para el software no usado en la ciencia. Es por eso que el uso de la computación en las ciencias he hecho &lt;strong&gt;avanzar a la computación&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Otro aspecto del pensamiento computacional en la ciencia es el uso del conocimiento de los procesos de información para &lt;strong&gt;interpretar el mundo natural como una conexión muchos modelos de información&lt;/strong&gt;. Esto nos revela que la computación ha influido incluso en la manera en la que vemos el mundo.&lt;/p&gt;

&lt;h2 id=&quot;conclusión&quot;&gt;Conclusión&lt;/h2&gt;

&lt;p&gt;El pensamiento computacional es mucho más complejo de lo que parece o de los que los medios han entendido (“hacer algoritmos”).&lt;/p&gt;

&lt;p&gt;Este campo del pensamiento es tan grande que no alcanzaría una vida para cubrirlo en su totalidad, pero podemos tener una idea general de los campos que abarca y si nos gusta, especializarnos en uno de ellos.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;Este artículo está basado en el libro &lt;a href=&quot;https://mitpress.mit.edu/books/computational-thinking&quot;&gt;Computational Thinking&lt;/a&gt; de Peter J. Denning y Matti Tedre.&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="cs" /><category term="computational-thinking" /><category term="pensamiento-computacional" /><category term="libros" /><category term="mit" /><summary type="html">El pensamiento computacional ha sonado mucho en los medios últimamente. Hablemos de lo que es y todo lo que implica.</summary></entry><entry><title type="html">¿Qué es un engine de JavaScript?</title><link href="https://blog.thedojo.mx/2020/05/17/que-es-un-engine-de-javascript.html" rel="alternate" type="text/html" title="¿Qué es un engine de JavaScript?" /><published>2020-05-17T00:00:00-05:00</published><updated>2020-05-17T00:00:00-05:00</updated><id>https://blog.thedojo.mx/2020/05/17/que-es-un-engine-de-javascript</id><content type="html" xml:base="https://blog.thedojo.mx/2020/05/17/que-es-un-engine-de-javascript.html">&lt;p&gt;Me llamó mucho la atención  la salida de &lt;a href=&quot;https://deno.land/v1&quot;&gt;Deno v1 esta semana&lt;/a&gt; y le quise echar un ojito. Pero desde la explicación que da inicialmente, no entiendo &lt;em&gt;exactamente&lt;/em&gt; lo que es y hace:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Deno is a simple, modern and secure runtime for JavaScript and TypeScript that uses V8 and is built in Rust.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Aquí me surgió la pregunta: ¿Qué es un &lt;strong&gt;runtime&lt;/strong&gt; para JavaScript?&lt;/p&gt;

&lt;p&gt;Pero para contestarla, antes tengo que entender &lt;strong&gt;qué es V8&lt;/strong&gt;. La respuesta es: un &lt;em&gt;engine&lt;/em&gt; o &lt;em&gt;motor&lt;/em&gt; de JavaScript. En este artículo explicaremos qué es y cómo funciona.&lt;/p&gt;

&lt;h2 id=&quot;explicación-rápida&quot;&gt;Explicación rápida&lt;/h2&gt;

&lt;p&gt;Puedes pensar en un engine o motor de JavaScript como en el programa encargado de correr el código de JavaScript. Todos los navegadores tienen uno:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Navegador&lt;/th&gt;
      &lt;th&gt;Engine&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Chrome&lt;/strong&gt; y &lt;strong&gt;Opera&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://v8.dev/&quot;&gt;V8&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Firefox&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey&quot;&gt;SpiderMonkey&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Safari&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://trac.webkit.org/wiki/JavaScriptCore&quot;&gt;WebKit JSCore&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Edge&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/microsoft/ChakraCore&quot;&gt;Chakra&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Este, combinado con el motor web componen la mayor parte de un navegador. Los engines se pueden usar fuera de los navegadores para otras tareas, como en Deno o Node.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;El &lt;strong&gt;motor de JavaScript&lt;/strong&gt; es quien convierte tu código de JavaScript en código ejecutable por la máquina en la que va a correr.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;teoría-compilación-contra-interpretación&quot;&gt;Teoría: Compilación contra Interpretación&lt;/h2&gt;

&lt;p&gt;Para correr un programa en cualquier lenguaje, hay que convertirlo en instrucciones que las computadoras puedan entender. Esto es el &lt;strong&gt;código máquina&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Los lenguajes compilados transforman todo el código &lt;strong&gt;antes de ejecutarlo&lt;/strong&gt;, por lo que pueden hacer optimizaciones generales para que el programa sea más eficiente.&lt;/p&gt;

&lt;p&gt;Para que el programa compile tiene que estar libre de errores. Generalmente esa compilación lleva un poco de tiempo, que va creciendo dependiendo del tamaño y complejidad del programa. Los programas compilados pueden ser más eficientes en ejecución, pero cuesta más empezarlos a correr.&lt;/p&gt;

&lt;p&gt;Los lenguajes interpretados van ejecutando &lt;strong&gt;línea por línea&lt;/strong&gt;, sentencia por sentencia. Por esto mismo no pueden hacer optimizaciones generales, pero es más fácil y rápido para el programador &lt;em&gt;empezar&lt;/em&gt; a ejecutarlos. Normalmente tienen un &lt;strong&gt;REPL&lt;/strong&gt; (Read - Eval - Print - Loop) que puede servir para jugar con ellos y hacer pruebas.&lt;/p&gt;

&lt;p&gt;Se pude pensar que es &lt;em&gt;más fácil&lt;/em&gt; desarrollar en lenguajes interpretados que compilados, por lo que su desarrollo es &lt;em&gt;más rápido&lt;/em&gt;. Pero como los lenguajes compilados pueden hacer optimizaciones generales, son &lt;strong&gt;más eficientes&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;la-ejecución-de-javascript&quot;&gt;La ejecución de JavaScript&lt;/h2&gt;

&lt;p&gt;JavaScript &lt;em&gt;nació&lt;/em&gt; como lenguaje &lt;strong&gt;interpretado&lt;/strong&gt;, para correr dentro del navegador Netscape. La idea principal de esto es que no necesitara de un paso de &lt;em&gt;compilación&lt;/em&gt; previa, entendida como la generación de un producto intermedio que sea ejecutable.&lt;/p&gt;

&lt;p&gt;El encargado de esta “interpretación”, es decir, de convertir instrucciones de JavaScript en
instrucciones de la computadora es el &lt;em&gt;engine o motor&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Pero los motores modernos de JavaScript están muy optimizados, la ejecución de JS puede a veces compararse con la de lenguajes completamente compilados. Y esto es gracias las optimizaciones de compilación en el momento de la ejecución: &lt;em&gt;just in time&lt;/em&gt; o &lt;strong&gt;JIT&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;En resumen: JavaScript dejó de de ser un lenguaje &lt;em&gt;puramente interpretado&lt;/em&gt; para convertirse en un lenguaje híbrido, con interpretación y compilado JIT. Se comporta como interpretado cuando un programador lo corre, pero el motor compila el código, produciendo algunas veces un producto intermedio (bytecode) que puede ser optimizado para que las siguientes ejecuciones sean mucho más rápidas.&lt;/p&gt;

&lt;h2 id=&quot;las-etapas-de-un-motor-de-javascript&quot;&gt;Las etapas de un motor de JavaScript&lt;/h2&gt;

&lt;p&gt;Ls principales etapas son:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Escaneo&lt;/strong&gt;. Convierte el texto del código que escribes en &lt;em&gt;tokens&lt;/em&gt;. Un token es un bloque de carácteres que tienen un significado sintáctico. Ejemplo: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x=33&lt;/code&gt; está compuesto por 3 tokens: Un identificador (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;), un operador (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;=&lt;/code&gt;) y un número (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;33&lt;/code&gt;). Puedes irte por el hoyo del conejo si quieres entender como funciona el scanner de V8 aquí: &lt;a href=&quot;https://v8.dev/blog/scanner&quot;&gt;Blazingly fast parsing&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Parseo&lt;/strong&gt;. No encontré la palabra correcta para traducirlo, pero se puede entender como la ‘lectura’ de un texto que lo transforma en una estructura de datos. Esta fase convierte el conjunto de &lt;em&gt;tokens&lt;/em&gt; generados por el scanner en un Árbol de Sintaxis Abstracta (AST - Abstract Sintax Tree). Este árbol representa tu programa sintácticamente y se pasa a la siguiente fase de la compilación.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Interpretación&lt;/strong&gt;. En esta fase se toma el AST y se convierte en una primera versión de código que la máquina ya puede ejecutar, &lt;em&gt;sin optimizaciones&lt;/em&gt;. Genera además código intermedio (bytecode) que puede ser pasado a la siguiente etapa para optimizarlo. En V8 se llama &lt;a href=&quot;https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775&quot;&gt;Ignition&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Optimización&lt;/strong&gt;. Esta parte es ejecutada por un compilador JIT, que analiza el código, cómo se comporta, los tipos de datos usados para crear una versión más optimizada en código máquina. Si las optimizaciones fallan, el bytecode sigue siendo ejecutado por el intérprete. En V8 se llama &lt;a href=&quot;https://v8.dev/docs/turbofan&quot;&gt;TurboFan&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Las últimas dos etapas son donde el código se ejecuta, una en forma de bytecode interpretado y la otra en forma de código máquina &lt;strong&gt;altamente eficiente y optimizado&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Aquí puedes ver un diagrama de la secuencia de operaciones de V8.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/v1589700777/1_ZIH_wjqDfZn6NRKsDi9mvA_wc08nl.png&quot; alt=&quot;Ejecución de un script de JavaScript&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ejecución&quot;&gt;Ejecución&lt;/h2&gt;

&lt;p&gt;Durante la ejecución, el motor de JavaScript debe mantener por lo menos dos cosas:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;La información de tu programa&lt;/li&gt;
  &lt;li&gt;En qué parte del programa estamos&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Esto lo hace mediante dos espacios de memoria organizados específicamente para estas tareas:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;El &lt;strong&gt;Heap&lt;/strong&gt;. Encargado de mantener la información de las variables y todo otro dato ocupado por el programa.&lt;/li&gt;
  &lt;li&gt;El &lt;strong&gt;Stack&lt;/strong&gt;. Encargado de llevar un registro de las llamadas a funciones y contextos de ejecución.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Además necesitamos a alguien que libere memoria para que nuestro programa no crezca infinitamente en la memoria y el &lt;em&gt;heap&lt;/em&gt; sea fácil de acceder. Esto es el &lt;strong&gt;garbage collector&lt;/strong&gt; o &lt;em&gt;recolector de basura&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Todo este proceso complejo se explica en mayor profundidad aquí: &lt;a href=&quot;https://deepu.tech/memory-management-in-v8/&quot;&gt;Visualizing memory management in V8 Engine&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusión&quot;&gt;Conclusión&lt;/h2&gt;

&lt;p&gt;Esto es lo básico que necesitamos entender de lo que hace un motor de JavaScript, el encargado de ejecutar el código. Pero no es suficiente contar con alguien que pueda correr el código, necesitamos además &lt;strong&gt;algo que nos proporcione el material para trabajar&lt;/strong&gt;, ya que los programas en general actúan sobre algo, u obtienen información de algún lado. Esto es el &lt;strong&gt;Runtime&lt;/strong&gt;, que explicaremos en el siguiente artículo.&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="js" /><category term="javascript" /><category term="compiladores" /><category term="javascript-engine" /><category term="v8" /><category term="chrome" /><summary type="html">Hablemos de qué es y cómo funciona un motor de Javascript.</summary></entry><entry><title type="html">Cursos certificados gratuitos</title><link href="https://blog.thedojo.mx/2020/05/16/cursos-certificados-gratuitos.html" rel="alternate" type="text/html" title="Cursos certificados gratuitos" /><published>2020-05-16T00:00:00-05:00</published><updated>2020-05-16T00:00:00-05:00</updated><id>https://blog.thedojo.mx/2020/05/16/cursos-certificados-gratuitos</id><content type="html" xml:base="https://blog.thedojo.mx/2020/05/16/cursos-certificados-gratuitos.html">&lt;p&gt;Debido a la emergencia sanitaria mundial, algunas universidades han liberado cursos
que además de auditar, puedes cursar para obtener un &lt;strong&gt;cetificado&lt;/strong&gt;. Si quieres mejorar un poco tu perfil del LinkedIn aquí te ponemos unos cursos de tecnología que puedes tomar.&lt;/p&gt;

&lt;h2 id=&quot;programación&quot;&gt;Programación&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.classcentral.com/course/computer-programming-for-everyone-17488&quot;&gt;Computer Programming For Everyone&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.coursera.org/learn/c-plus-plus-a?edocomorp=free-courses-high-school&quot;&gt;C++ For C Programmers&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/codeyourself-2938&quot;&gt;Code Yourself! An introduction to Programming&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.classcentral.com/course/android-app-5719&quot;&gt;Build Your First Android App&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.classcentral.com/course/aprogramar-2939&quot;&gt;¡A Programar! Una introducción a la programación&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/robotica-inicial-4659&quot;&gt;Robótica (para niños)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.coursera.org/learn/computer-vision-basics&quot;&gt;Computer Vision Basics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ia-y-machine-learning&quot;&gt;IA y Machine Learning&lt;/h2&gt;

&lt;h3 id=&quot;español&quot;&gt;Español&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/ai-for-everyone-es-13786&quot;&gt;IA para todos&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;inglés&quot;&gt;Inglés&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/datasciencemathskills-7745&quot;&gt;Data Scince Math Skills&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/machine-learning-business-professionals-13415&quot;&gt;Machine Learning for Business Professionals&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;cloud-computing&quot;&gt;Cloud Computing&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/cloud-computing-basics-18069&quot;&gt;Cloud Computing Basics&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/gcp-fundamentals-aws-8614&quot;&gt;Google Cloud Platform Fundamentals for AWS Professionals&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/aws-machine-learning-16924&quot;&gt;Getting Started with AWS Machine Learning&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/cloud-identity-10785&quot;&gt;Introduction to Cloud Identity&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/iiot-google-cloud-platform-12701&quot;&gt;Industrial IoT on Google Cloud Platform&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/developing-ai-applications-azure-17329&quot;&gt;Developing AI Applications on Azure&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/conversational-experiences-dialogflow-12529&quot;&gt;Building Conversational Experiences with Dialogflow&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/aws-computer-vision-gluoncv-17327&quot;&gt;AWS Computer Vision: Getting Started with GluonCV&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;matemáticas&quot;&gt;Matemáticas&lt;/h2&gt;

&lt;h3 id=&quot;español-1&quot;&gt;Español&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.coursera.org/learn/estadistica-probabilidad&quot;&gt;Estadística y probabilidad (UNAM)&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/calculo-1-4231&quot;&gt;El Cálculo - Modelo Lineal&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/calculo-2-4226&quot;&gt;El Cálculo - Modelo Cuadrático&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/calculo-3-4284&quot;&gt;El Cálculo - Modelo Cúbico&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/calculo-4-4167&quot;&gt;El Cálculo - Otros Modelos&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;inglés-1&quot;&gt;Inglés&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.coursera.org/learn/matlab&quot;&gt;Introduction to Matlab&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/datasciencemathskills-7745&quot;&gt;Data Scince Math Skills&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/introduccion-al-calculo-4225&quot;&gt;Pre-Calculus&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/introduction-to-calculus-12547&quot;&gt;Introduction to Calculus&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;diseño&quot;&gt;Diseño&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.coursera.org/learn/design&quot;&gt;Design: Creation of Artifacts in Society&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/design-language-16927&quot;&gt;The Language of Design: Form and Meaning&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;otros-temas&quot;&gt;Otros temas&lt;/h2&gt;

&lt;h3 id=&quot;español-2&quot;&gt;Español&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/pensamiento-sistemico-4332&quot;&gt;Pensamiento Sistémico&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.classcentral.com/course/mindshift-transforma-mente-10619&quot;&gt;Mindshift: Transforma tu mente para superar obstáculos en el aprendizaje y descubrir tu potencial oculto&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.classcentral.com/course/arte-publico-pedagogia-7196&quot;&gt;ART of the MOOC: Arte Público y Pedagogía&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.classcentral.com/course/escritura-esp-13496&quot;&gt;Fundamentos de la Escritura&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.classcentral.com/course/innovacion-734&quot;&gt;Desarrollo rápido de productos innovadores para mercados emergentes&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/hablar-bien-en-publico-10518&quot;&gt;Cómo hablar bien en público&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;inglés-2&quot;&gt;Inglés&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.classcentral.com/course/teamwork-skills-effective-communication-9661&quot;&gt;Teamwork Skills: Communicating Effectively in Groups&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/personal-branding-4865&quot;&gt;Introduction to personal branding&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/understanding-arguments-6620&quot;&gt;Think Again I&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/market-analytics-4868&quot;&gt;Marketing Analytics&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.classcentral.com/course/skills-management-11218&quot;&gt;Introduction to Skills Management&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.classcentral.com/course/how-to-write-a-scientific-paper-5816&quot;&gt;How to Write and Publish a Scientific Paper&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.classcentral.com/course/emerging-technologies-lifelong-learning-10396&quot;&gt;Exploring Emerging Technologies for Lifelong Learning and Success&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.classcentral.com/course/making-architecture-7153&quot;&gt;MAking Architecture&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Puedes ver una lista actualizada de los cursos aquí: &lt;a href=&quot;https://www.classcentral.com/report/free-online-learning-coronavirus/&quot;&gt;Free Learning Due to Coronavirus&lt;/a&gt;. Es emocionante ver todo lo que se puede aprender si uno puede ponerle el tiempo necesario.&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="cursos" /><category term="aprendizaje" /><category term="programación" /><category term="matemáticas" /><category term="mooc" /><summary type="html">Es emocionante todo lo que se puede aprender en internet. Revisa algunos cursos que además te certifcan gratuitamente.</summary></entry><entry><title type="html">Entendiendo ES6</title><link href="https://blog.thedojo.mx/2020/04/27/entendiendo-es6.html" rel="alternate" type="text/html" title="Entendiendo ES6" /><published>2020-04-27T00:00:00-05:00</published><updated>2020-04-27T00:00:00-05:00</updated><id>https://blog.thedojo.mx/2020/04/27/entendiendo-es6</id><content type="html" xml:base="https://blog.thedojo.mx/2020/04/27/entendiendo-es6.html">&lt;p&gt;Hace tiempo dimos un curso de ES6 o ES2015. Hicimos una investigación acerca de la historia, la nomenclatura, quién lo creo y porque tanta confusión con los nombres.&lt;/p&gt;

&lt;p&gt;En este video explicamos eso y más: las características principales que se agregaron y la diferencia entre JavaScript y ECMAScript.&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/ZnS37QdoTDA&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;hr /&gt;

&lt;p&gt;¿Tienes dudas específicas de JavaScript? Compártelas en los comentarios e intentaremos hacer videos sobre eso.&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="es6" /><category term="js" /><category term="javascript" /><category term="videos" /><summary type="html">Lanzamos un video explicando por qué ES6 sonó tanto. Velo aquí.</summary></entry><entry><title type="html">A Philosophy of Software Design: Crea módulos de propósito general</title><link href="https://blog.thedojo.mx/2020/04/02/a-philosophy-of-software-design-crea-modulos-de-proposito-general.html" rel="alternate" type="text/html" title="A Philosophy of Software Design: Crea módulos de propósito general" /><published>2020-04-02T00:00:00-06:00</published><updated>2020-04-02T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2020/04/02/a-philosophy-of-software-design-crea-modulos-de-proposito-general</id><content type="html" xml:base="https://blog.thedojo.mx/2020/04/02/a-philosophy-of-software-design-crea-modulos-de-proposito-general.html">&lt;p&gt;Una burla común hacia los programadores es que todo lo queremos hacer &lt;em&gt;demasiado general&lt;/em&gt;. Nos piden una funcionalidad y en ese momento empezamos a pensar en todos los casos en los que podría ser usado en el universo.&lt;/p&gt;

&lt;p&gt;Hay muchos consejos &lt;strong&gt;en contra&lt;/strong&gt; de escribir código que abarque
muchos casos. En este artículo vamos a hablar de las ventajas y
desventajas de módulos de &lt;strong&gt;propósito general&lt;/strong&gt;, es decir, vamos a
hablar en contra de la sabiduría popular.&lt;/p&gt;

&lt;p&gt;Pero además hablaremos &lt;strong&gt;del equilibrio&lt;/strong&gt; y cómo lograrlo.&lt;/p&gt;

&lt;h2 id=&quot;especificidad-de-un-módulo&quot;&gt;Especificidad de un módulo&lt;/h2&gt;

&lt;p&gt;Puedes pensar en la especialización de un módulo (o del código en general) como en continuo que va desde algo que se puede utilizar en muchos muchos casos (las bibliotecas estándar) hasta código que sólo sirve para un uso muy acotado y es muy difícil de cambiar.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/c_scale,w_1200/v1585279283/7655B57E-A45D-4832-A0D6-41670C22D6CA_boy7ej.png&quot; alt=&quot;Gráfica del continuo de especificidad&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Un módulo específico está dedicado a cumplir &lt;em&gt;una sola función&lt;/em&gt; en el sistema y sólo se puede usar para eso. Si los pensáramos como conectores para un dispositivo, como un celular, podrías decir que es la conexión especial que Nokia, Apple o Sony Ericsson se inventaron en su tiempo para cargar.&lt;/p&gt;

&lt;p&gt;Un módulo de propósito general se puede usar para varios casos con &lt;em&gt;poca modificación&lt;/em&gt;, o creando un módulo más específico a partir de él. En el mismo ejemplo de los dispositivos electrónicos puede compararse al estándar USB que sirve para múltiples cosas y puede ser usado en muchos aparatos diferentes.&lt;/p&gt;

&lt;h2 id=&quot;módulos-específicos&quot;&gt;Módulos específicos&lt;/h2&gt;

&lt;p&gt;El caso más extremo del código específico es el que llamamos &lt;em&gt;hardcoding&lt;/em&gt;. Es tan específico que sirve sólo para una instancia muy pequeña de un problema y &lt;em&gt;no es fácil de modificar en producción&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Se entiende como &lt;em&gt;hardcoding&lt;/em&gt; a poner directamente en el código un valor fijo que pudiera variar en el futuro: configuración de IP’s, conexión a bases de datos, nombres de usuario, etc. Y es uno de los casos extremos de &lt;a href=&quot;https://blog.thedojo.mx/2020/02/11/a-philosophy-of-software-design-programacion-tactica-vs-estrategica.html#desarrollo-t%C3%A1ctico&quot;&gt;programación táctica&lt;/a&gt;. Por lo tanto, y esto todos lo sabemos, es una &lt;strong&gt;muy mala  práctica&lt;/strong&gt; para crear código mantenible e incluso para la practicidad en el desarrollo.&lt;/p&gt;

&lt;p&gt;El siguiente nivel de especificidad y con el que casi todos nos quedamos contentos es cuando creamos un módulo (una clase, por ejemplo), para una &lt;em&gt;función específica&lt;/em&gt; de nuestro sistema y que &lt;em&gt;sólo puede usarse ahí&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Usemos como ejemplo un programa para registrar publicaciones impresas como libros, revistas, periódicos, panfletos, etc. Una manera de diseñarlo es creando en el módulo una función para cada tipo de publicación:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;registrar_libro&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;registrar_revista&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;registrar_panfleto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Esto nos llevaría a tener una interfaz muy amplia y generalmente funciones o módulos poco profundos. Además, si agregamos un nuevo tipo de publicación se tendría que crear una nueva función para atenderlo.&lt;/p&gt;

&lt;h2 id=&quot;módulos-de-propósito-general&quot;&gt;Módulos de propósito general&lt;/h2&gt;

&lt;p&gt;Un módulo de propósito general puede tener, casi siempre, una interfaz más sencilla que un módulo de propósito específico. Siguiendo con el ejemplo de los libros, en vez de crear una función para cada uno de los tipos de publicación se podría crear una general:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;registrar_publicacion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;registrar_tipo_de_publicacion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Esto permitiría tener una interfaz más sencilla con aplicaciones &lt;em&gt;más amplias&lt;/em&gt;, con más usos.&lt;/p&gt;

&lt;p&gt;El ejemplo mencionado por &lt;a href=&quot;https://amzn.to/2GdeHi5&quot;&gt;A Philosophy of Software Design&lt;/a&gt; es el de un editor de texto con interfaz gráfica. La clase encargada de almacenar el texto en memoria deber tener las capacidades para modificarlo.&lt;/p&gt;

&lt;p&gt;Piensa en las operaciones que los editores de texto dan: insertar texto, borrar texto hacia adelante, borrar texto hacia atrás, seleccionar, copiar, pegar. Ousterhout menciona que implementar una función &lt;em&gt;específica&lt;/em&gt; para cada una de estas operaciones crea complejidad no necesaria. Un diseño más general permite hacer tres operaciones: insertar texto, borrar texto y mover el cursor. Todas las operaciones se pueden lograr con estas otras tres, teniendo una interfaz más sencilla.&lt;/p&gt;

&lt;p&gt;Este debería ser nuestro objetivo: crear interfaces sencillas que hagan mucho por nosotros.&lt;/p&gt;

&lt;h2 id=&quot;por-qué-hacer-módulos-de-propósito-general&quot;&gt;¿Por qué hacer módulos de propósito general?&lt;/h2&gt;

&lt;p&gt;El principal motivo que &lt;a href=&quot;https://amzn.to/2GdeHi5&quot;&gt;A Philosophy of Software Design&lt;/a&gt; menciona es que los módulos de propósito general &lt;a href=&quot;https://blog.thedojo.mx/2020/03/02/a-philosophy-of-software-design-los-modulos-deben-ser-profundos.html#dise%C3%B1o-de-m%C3%B3dulos&quot;&gt;son más profundos&lt;/a&gt; es decir, encierran más funcionalidad con una interfaz pequeña.&lt;/p&gt;

&lt;p&gt;Hacerlo contribuye a que tu código esconda más información y por lo tanto su uso sea más simple.&lt;/p&gt;

&lt;p&gt;Además los módulos demasiado específicos crean &lt;strong&gt;acoplamiento&lt;/strong&gt; en el sistema que no es sano: los usuarios del módulo tienen que adaptarse a una interfaz mu específica.&lt;/p&gt;

&lt;p&gt;Los módulos de propósito general te pueden quitar trabajo en el futuro, al requerir menos modificación y poder reutilizar su código para crear nuevas funcionalidades, como en el caso extremo de las bibliotecas estándar.&lt;/p&gt;

&lt;p&gt;Y por último una interfaz demasiado específica puede filtrar información no necesaria.&lt;/p&gt;

&lt;h2 id=&quot;equilibrio&quot;&gt;Equilibrio&lt;/h2&gt;

&lt;p&gt;La clave para elegir qué tan específico es tu módulo es la forma en la que lo vas a utilizar: tu pieza de código tiene que ser &lt;strong&gt;tan general&lt;/strong&gt; como puedas sin que dificulte demasiado su uso actual.&lt;/p&gt;

&lt;p&gt;Tienes que evaluar qué tanto desvía del uso específico inmediato el que modifiques la interfaz para crear algo que pueda ser reutilizado.&lt;/p&gt;

&lt;h2 id=&quot;conclusión&quot;&gt;Conclusión&lt;/h2&gt;

&lt;p&gt;Crear módulos de “no tan específicos” puede ayudarte a:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Ocultar mejor la información&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Crear interfaces más concisas&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Reutilizar mejor el código&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Tienes que buscar el equilibrio entre crear un módulo tan específico que sólo uses una vez, contra un módulo que cubra todos los casos del mundo. El equilibrio está en un módulo que no sea difícil de utilizar para tu problema a la mano pero que puede ser (o este siendo) utilizado en varios lugares y de varias formas si es el caso.&lt;/p&gt;

&lt;p&gt;Tu “yo” del futuro te agradecerá si logras encontrar el equilibrio, porque podrás crear funcionalidades más rápido, &lt;em&gt;acelerar&lt;/em&gt;: una característica de la programación estratégica.&lt;/p&gt;

&lt;p&gt;En el próximo artículo hablaremos de los sistemas en capas y cómo aprovechar sus particularidades para crear diseños que dominen la complejidad.&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="PoSD" /><category term="módulos" /><category term="generalización" /><category term="module" /><category term="class" /><summary type="html">Crear módulos o clases demasiado específicas puede llevar a tu código a ser difícil de mantener, veamos por qué te conviene crear módulos de propósito general.</summary></entry><entry><title type="html">A Philosophy of Software Design: Recomendaciones de diseño modular</title><link href="https://blog.thedojo.mx/2020/03/18/a-philosophy-of-software-design-recomendaciones-disenio-modular.html" rel="alternate" type="text/html" title="A Philosophy of Software Design: Recomendaciones de diseño modular" /><published>2020-03-18T00:00:00-06:00</published><updated>2020-03-18T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2020/03/18/a-philosophy-of-software-design-recomendaciones-disenio-modular</id><content type="html" xml:base="https://blog.thedojo.mx/2020/03/18/a-philosophy-of-software-design-recomendaciones-disenio-modular.html">&lt;p&gt;En los artículos anteriores hemos estado hablando de cómo evitar la complejidad mediante ocultar información.&lt;/p&gt;

&lt;p&gt;En este daremos algunas recomendaciones más y hablaremos de cómo no llevar este principio al extremo.&lt;/p&gt;

&lt;p&gt;Hablemos primero de consejos que te ayudarán a mantener oculta la información que debe de estarlo.&lt;/p&gt;

&lt;h2 id=&quot;exponer-lo-menos-posible-estructuras-de-datos&quot;&gt;Exponer lo menos posible estructuras de datos&lt;/h2&gt;

&lt;p&gt;Un error común cuando creamos un módulo es exponer las estructuras de datos internas hacia otros módulos. Esto hace el código que usa tu módulo sea &lt;em&gt;dependiente de detalles de implementación&lt;/em&gt; que no le conciernen y, como hemos repetido hasta el cansancio, que una decisión de diseño se vea reflejada en varios lugares.&lt;/p&gt;

&lt;p&gt;Transforma las estructuras de datos internas en estructuras de uso general que no dependan de la implementación de tu módulo. Por ejemplo, si estás haciendo una conexión con una API de la que extraes información para otros lados del sistema, comunica esa información en una estructura de datos diseñada para tu sistema no dependiente de la API.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ejemplo&lt;/strong&gt;. Imagina un módulo de comunicación con diferentes API’s de mensajería como WhatsApp, Messenger, etc. Cada una las API’s avisa de la entrada de un nuevo mensaje con sus datos específicos y en su formato. Para que to módulo encapsule la mayo cantidad de decisiones de diseño posible debería crear una estructura de mensajes que los demás módulos &lt;em&gt;recibieran independientemente del medio por el que llegó el mensaje&lt;/em&gt;. Lo mismo para responder: la función encargada de la respuesta debería recibir &lt;em&gt;siempre los mismos datos independientemente del mensajero que se esté usando&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;defaults-útiles&quot;&gt;Defaults útiles&lt;/h2&gt;

&lt;p&gt;Tal vez este punto merezca su propio artículo pero tratemos de resumirlo.&lt;/p&gt;

&lt;p&gt;La idea de crear un módulo es, a parte de ocultar complejidad, crear un pieza de código que pueda ser &lt;em&gt;reutilizable&lt;/em&gt;. Como la operación no es siempre exactamente igual, a veces hay que incluir parámetros que permitan modificar el comportamiento del módulo. Los parámetros pueden llegar a revelar detalles de implementación, así que es conveniente saber diseñarlos, primero &lt;em&gt;para no contaminar la interfaz&lt;/em&gt; y segundo &lt;em&gt;para mantener la interfaz fácil de usar&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;John Ousterhout habla como ejemplo de lo mal diseñada que está la interfaz de la clase &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FileInputStream&lt;/code&gt; de Java, que no es capaz de realizar una lectura con buffer sin que le pases una clase que lo hace explícitamente. La lectura de un archivo con un buffer &lt;strong&gt;es normal&lt;/strong&gt;, generalmente no quieres leer un archivo sin tener el buffer disponible. Entonces el default de esta clase debería ser la lectura con buffer, &lt;em&gt;sin que se lo tengas que pedir explícitamente&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Los módulos deberían hacer lo normal o lo correcto siempre que sea posible, sin que se tenga que pedir explícitamente.&lt;/strong&gt; Es decir, tus módulos deberían estar diseñados para hacer el &lt;em&gt;caso más común&lt;/em&gt; muy fácil de usar.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Las mejores funciones son las que obtienes sin siquiera saber que existen. - &lt;strong&gt;John Ousterhout&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Un ejemplo de buen diseño son los lenguajes modernos con la codificación de las cadenas: son &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;utf-8&lt;/code&gt; por default, ya que es ‘lo correcto’ y lo común.&lt;/p&gt;

&lt;p&gt;Otro ejemplo son las funciones &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;split&lt;/code&gt; (separar una cadena) y &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;join&lt;/code&gt; (juntar los elementos de un array o lista en una cadena) de Python, Elixir y otros lenguajes: si no le pasas el carácter que usarán para dividir o pegar, lo harán por la cadena vacía, &lt;em&gt;facilitando un caso de uso muy común&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Podemos aprender de estos buenos diseños para crear los propios. Por ejemplo, imagina que tienes un módulo que usa la fecha y hora para registrar algo. El caso &lt;em&gt;común&lt;/em&gt; es que registres algo en el momento inmediato que sucedió. Un buen default sería que el módulo &lt;em&gt;automáticamente&lt;/em&gt; registrara la hora actual sin esperarla del usuario, pero dando la opción de modificarla en caso de que se necesite. Un programa que hace esto es &lt;strong&gt;Git&lt;/strong&gt;, registra automáticamente un commit con la hora en que lo hiciste pero tiene la opción de que la especifiques o modifiques.&lt;/p&gt;

&lt;h2 id=&quot;aisla-dentro-de-las-clases-y-paquetes&quot;&gt;Aisla dentro de las clases y paquetes&lt;/h2&gt;

&lt;p&gt;Cuando trabajas con clases, es buena idea crear métodos independientes (privados en caso de ser posible), que oculten información &lt;em&gt;del resto de la clase&lt;/em&gt;. Piensa en esto como en aplicar los principios anteriores a nivel de clase. Además las variables de clase o de instancia deberían ser usadas en el &lt;strong&gt;menor número de lugares posible&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Si estás usando un lenguaje funcional o procedural, &lt;em&gt;aplica este principio al nivel de tus paquetes&lt;/em&gt; (y definitivamente evita variables globales lo más que puedas).&lt;/p&gt;

&lt;p&gt;Finalmente hablemos de cómo llevar todo esto demasiado lejos.&lt;/p&gt;

&lt;h2 id=&quot;la-clase-dios&quot;&gt;La clase dios&lt;/h2&gt;

&lt;p&gt;En artículos pasados hablamos un poco de que es mejor crear clases grandes que encapsulen decisiones de diseño completas en vez de dividir esas decisiones de diseño. Pero si no tenemos cuidado, esto nos puede llevar a crear lo que algunos conoce como &lt;em&gt;‘the God Class’&lt;/em&gt; o la clase dios.&lt;/p&gt;

&lt;p&gt;Esta infame clase es la que en muchos sistemas se ha creado para mantener la mayoría de la información y operación, es decir, es una clase que lo &lt;em&gt;sabe&lt;/em&gt; y lo &lt;em&gt;puede&lt;/em&gt; todo. Crearla romería el propósito de ocultar información: &lt;strong&gt;pasarías la mayor parte del tiempo trabajando en esta clase&lt;/strong&gt;, que por lo general sería muy complicada, teniendo tantas cosas que hacer. Así que &lt;em&gt;evítala a toda costa&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;ocultar-información-que-sí-se-usa-afuera&quot;&gt;Ocultar información que sí se usa afuera&lt;/h2&gt;

&lt;p&gt;Sería un error grave de diseño hacer inaccesible (en lenguajes que lo permiten), o difícil de encontrar, información que se usa afuera de tu módulo. Un ejemplo que da &lt;a href=&quot;https://amzn.to/2GdeHi5&quot;&gt;A Philosophy of Software Design&lt;/a&gt; es en el caso de parámetros de configuración que afecten el rendimiento de una pieza de software y que sea absolutamente necesario conocer para operar bien (podría ser el método de conexión en una red, por ejemplo).&lt;/p&gt;

&lt;p&gt;En el ejemplo de las API’s de mensajería del que hablamos arriba, piensa por ejemplo que la parte del código encargada de generar un mensaje &lt;em&gt;necesita&lt;/em&gt; saber de dónde viene el mensaje para generar un mensaje adecuado al medio (si viene de SMS hará un mensaje mejor de 100 carácteres, por ejemplo).&lt;/p&gt;

&lt;p&gt;O algo a lo que la mayoría de los lenguajes de programación nos obligan: especificar el modo de apertura de u archivo.&lt;/p&gt;

&lt;p&gt;Sin embargo, tu trabajo como diseñador de software consiste en &lt;strong&gt;minimizar&lt;/strong&gt; la información que se necesita fuera del módulo, para que sea lo más fácil de usar dentro de los límites.&lt;/p&gt;

&lt;h2 id=&quot;conclusión&quot;&gt;Conclusión&lt;/h2&gt;

&lt;p&gt;Este y los artículos anteriores quieren dejar claro algo: el trabajo principal de un módulo es ocultar información. Hay varias formas de lograrlo y detalles a los cuáles ponerles atención. Hacerlo creará código que sea más fácil de &lt;strong&gt;entender y mantener&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;En el próximo artículo hablaremos de por qué es mejor crear módulos de propósito general.&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="PoSD" /><category term="software-design" /><category term="complexity" /><category term="interfaces" /><category term="defaults" /><summary type="html">Hablemos de algunos consejos para lograr ocultar la mayor cantidad de información posible en tus módulos, pero también de cómo no llevarlo demasiado lejos</summary></entry></feed>