<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://blog.thedojo.mx/feed.xml" rel="self" type="application/atom+xml" /><link href="https://blog.thedojo.mx/" rel="alternate" type="text/html" /><updated>2023-02-27T20:24:38-06:00</updated><id>https://blog.thedojo.mx/feed.xml</id><title type="html">The Dojo MX Blog</title><author><name>Héctor Patricio</name><uri>https://github.com/hectorip</uri></author><entry><title type="html">Code Review: La practica Milenaria que seguimos haciendo mal.</title><link href="https://blog.thedojo.mx/2023/02/27/code-review.html" rel="alternate" type="text/html" title="Code Review: La practica Milenaria que seguimos haciendo mal." /><published>2023-02-27T00:00:00-06:00</published><updated>2023-02-27T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2023/02/27/code-review</id><content type="html" xml:base="https://blog.thedojo.mx/2023/02/27/code-review.html">&lt;h2 id=&quot;qué-es-code-review&quot;&gt;¿Qué es “Code Review”?&lt;/h2&gt;

&lt;p&gt;Es la práctica que realizan los equipos de ingeniería de software para verificar los cambios de código antes de fusionarlos con el código fuente principal.&lt;/p&gt;

&lt;h2 id=&quot;dónde-se-aplica&quot;&gt;Dónde se aplica&lt;/h2&gt;

&lt;p&gt;En todas partes, cuando eres miembro de un equipo, como colaborador individual o como estudiante. Tienes la oportunidad de involucrarte, contribuir y dar tu opinión a código escrito por otra persona. Algunos ejemplos:&lt;/p&gt;

&lt;h3 id=&quot;durante-una-sesión-de-pair-programming&quot;&gt;Durante una sesión de “pair programming”&lt;/h3&gt;
&lt;blockquote&gt;

  &lt;p&gt;“Dos cabezas piensan mejor que una.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Revisando una pieza de código con alguien más, los desarrolladores podemos hacer recomendaciones, mejoras y adiciones a un sistema en tiempo real.&lt;/p&gt;

&lt;h3 id=&quot;en-aplicaciones-de-control-de-versiones-tales-como&quot;&gt;En aplicaciones de control de versiones, tales como&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;El Pull Request (PR) en GitHub.&lt;/li&gt;
  &lt;li&gt;El Merge Request (MR) en GitLab.
Estas funciónes permiten a los desarrolladores proponer cambios en un código propiedad de otra persona. Es una forma de revisar y discutir cambios propuestos antes de fusionarlos, lo que permite a otros desarrolladores dejar comentarios, solicitar cambios o aprobar una solicitud de forma asíncrona.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;en-cualquier-fragmento-de-código-propuesto&quot;&gt;En cualquier fragmento de código propuesto&lt;/h3&gt;

&lt;p&gt;Hay otros canales o formas de compartir código con un equipo. A veces, los desarrolladores lo hacen a través de Slack (u otros servicios de mensajeria) u otra, simplemente compartiendo enlaces.
Si como desarrollador notas algo para mejorar o agregar, tu equipo de tecnología debe ser el lugar que permita que esas interacciones y comentarios sucedan orgánicamente.&lt;/p&gt;

&lt;h2 id=&quot;beneficios-de-la-revisión-de-código&quot;&gt;Beneficios de la revisión de código&lt;/h2&gt;

&lt;p&gt;Esta práctica aumenta significativamente el trabajo en equipo. Involucrarse con el código de los demás e involucrar a otros en tus contribuciones aumenta el éxito en la creación de productos. Algunos de los beneficios son:&lt;/p&gt;

&lt;h3 id=&quot;solucion-temprana-de-errores&quot;&gt;Solucion temprana de errores&lt;/h3&gt;
&lt;blockquote&gt;

  &lt;p&gt;“Aquel de ustedes que esté libre de romper producción, que tire la primera piedra.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Como humanos, los ingenieros de software no están exentos de cometer errores, y es una gran ventaja contar con un equipo que te apoye, revise y libere tareas en conjunto. Durante una revisión de código, estos errores se pueden detectar y corregir.&lt;/p&gt;

&lt;h3 id=&quot;mejorar-la-calidad&quot;&gt;Mejorar la calidad&lt;/h3&gt;
&lt;blockquote&gt;

  &lt;p&gt;“Es más barato hacer las cosas bien la primera vez.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Establecer reglas en el estilo de código que aumenten la legibilidad, el mantenimiento y la escalabilidad del código ayuda a escribir software de calidad.&lt;/p&gt;

&lt;h3 id=&quot;intercambio-de-conocimientos&quot;&gt;Intercambio de conocimientos&lt;/h3&gt;

&lt;p&gt;El Code Review es una excelente herramienta para recibir y dar retroalimentación, aprender las mejores prácticas de los desarrolladores con más experiencia e intercambiar soluciones.&lt;/p&gt;

&lt;h3 id=&quot;sincronización&quot;&gt;Sincronización&lt;/h3&gt;

&lt;p&gt;Con esta práctica, se puede saber en qué está trabajando cada miembro del equipo, evitar duplicación de esfuerzos y mantenerse actualizado con la lógica del negocio.&lt;/p&gt;

&lt;h2 id=&quot;primeros-pasos&quot;&gt;Primeros pasos&lt;/h2&gt;

&lt;p&gt;Una buena idea para aplicar correctamente esta práctica en tu equipo es establecer reglas antes de empezar.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Establezca una plantilla de descripción con los puntos mínimos que el equipo necesitará para comprender el contexto y el propósito de una solicitud de cambios de código y apliquen esa plantilla de manera consistente en todas las solicitudes futuras.&lt;/li&gt;
  &lt;li&gt;El número mínimo de revisores para aprobar un fragmento de código; esto dependerá del tamaño del equipo.&lt;/li&gt;
  &lt;li&gt;Canales o herramientas de comunicación al equipo cuando un código este listo para ser revisado.&lt;/li&gt;
  &lt;li&gt;El tiempo entre las revisiones, es decir, que si un desarrollador marca un fragmento de código listo para revisarse y el equipo hace sugerencias o solicita cambios, y seguido de eso el desarrollador aplica los cambios solicitados, debe establecerse la cantidad de tiempo que debe pasar para solicitar una nueva revisión. Esta regla puede ser útil en equipos grandes que están involucrados en diferentes sistemas y necesitan dividir el tiempo entre el desarrollo y la revisión. En equipos pequeños, una regla de este tipo es opcional.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;revisión-efectiva&quot;&gt;Revisión efectiva&lt;/h2&gt;
&lt;blockquote&gt;

  &lt;p&gt;“Una buena revisión necesita de experiencia y profesionalismo y no de nivel de seniority.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Solo algunos desarrolladores son capaces de aplicar una buena revisión del código, esa es la razón principal por la que escribir esta publicación. El Code Review no es una práctica nueva en lo absoluto. Por el contrario, ha existido durante décadas, desde que las personas comenzaran a escribir código. Una de las primeras referencias a esta práctica como proceso formal se encuentra en el libro “The Mythical Man-Month” de Fred Brooks, publicado en 1975.&lt;/p&gt;

&lt;p&gt;Entonces, ¿por qué te pareció un tema importante? he estado trabajando con equipos de Ingeniería de Software durante aproximadamente 12 años y sigo leyendo comentarios que tienen un tono vago o agresivo o que carecen de explicación y contexto, lo que dificulta la aplicación efectiva de cambios en el código.&lt;/p&gt;

&lt;h3 id=&quot;la-revisión-de-código-no-es-una-práctica-para&quot;&gt;La revisión de código &lt;em&gt;NO ES&lt;/em&gt; una práctica para&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Demostrar superioridad.&lt;/li&gt;
  &lt;li&gt;Hacer que otros se sientan inseguros.&lt;/li&gt;
  &lt;li&gt;Imponer estilos de codificación.&lt;/li&gt;
  &lt;li&gt;En resumen, ser un idiota.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/c_scale,w_350/v1677550574/221453027-36a424b8-7ff5-4b17-bc8a-9bda2e223c22_rahapd.png&quot; alt=&quot;No&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Aquí algunos ejemplos.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/c_scale,q_100,w_800/v1677550576/221453038-b93d320a-5389-40e8-bf58-cd24b42910c4_ta57tb.png&quot; alt=&quot;code example&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Mala revisión:
“Este código es malo. ¿Por qué estás haciendo una búsqueda lineal?”&lt;/p&gt;

&lt;p&gt;Buena revisión:
“Este bloque de código podría optimizarse mediante el uso de una búsqueda binaria en lugar de una lineal. Esto mejoraría el rendimiento al buscar en grandes conjuntos de datos”.&lt;/p&gt;

&lt;p&gt;Como puedes ver en la mala revisión, hay más críticas que propuestas de alternativas o solución, o carece de la explicación del por qué se debe mejorar el código. Por el otro lado, la buena revisión ofrece una optimización, explicando por qué el enfoque diferente puede mejorar la función.&lt;/p&gt;

&lt;p&gt;Más malos ejemplos:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;“Este código apesta”. - Esto no es útil y no proporciona comentarios ni sugerencias para mejorar.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;“No entiendo lo que estás tratando de hacer aquí”. - Esto es desdeñoso y no proporciona comentarios constructivos. Si hay una duda genuina de la implementación lo ideal es expresar esa duda lo mejor posible.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;“Yo no lo haría de esta manera”. - Este comentario no es útil y le faltan razones o sugerencias para mejorar el código en revisión.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Los comentarios en una revisión del código deben ser específicos, constructivos y aplicables, evitando agresiones personales, un lenguaje desdeñoso y generalizaciones.&lt;/p&gt;

&lt;p&gt;Evite por completo el uso de signos de exclamación e íconos para enfatizar comentarios negativos. Por último, recuerda que las malas interpretaciones son comunes en la comunicación escrita y pueden ocurrir aunque la intención sea buena.&lt;/p&gt;

&lt;h3 id=&quot;la-revisión-de-código-si-es-una-práctica-para&quot;&gt;La revisión de código &lt;em&gt;SI ES&lt;/em&gt; una práctica para&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Incentivar el trabajo en equipo.&lt;/li&gt;
  &lt;li&gt;Reconocer el buen trabajo.&lt;/li&gt;
  &lt;li&gt;Ser flexible con los estilos de código y aprender de el equipo.&lt;/li&gt;
  &lt;li&gt;En resumen, es para ser un miembro del equipo.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/c_scale,w_350/v1677550578/221453050-3cc5f85d-a2bd-4f67-9aa6-9a0e1ddf76b2_hol1iu.png&quot; alt=&quot;approved symbol&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Aquí te dejo una sugerencia poderosa&lt;/em&gt;, no solo comentes lo que consideres que se puede cambiar o mejorar, sino también comenta lo que te gustó en una implementación, por ejemplo:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“¡Buen trabajo! Este código está muy bien organizado y es fácil de entender. Aprecio especialmente cómo usaste las funciones integradas en la biblioteca estándar de Go para simplificar el código. ¡Sigue con el excelente trabajo!””&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Adicionalmente, recuerda tomarte el tiempo. El trabajo es exigente y, a veces, no dedicamos suficiente tiempo a las revisiones, y comentamos “¡LGTM!” (Me parece bien) para seguir adelante, pero recordemos que el otro desarrollador dedicó tiempo a trabajar en esos cambios, por lo que vale la pena revisarlos con cuidado.&lt;/p&gt;

&lt;p&gt;Otra sugerencia que les dejo es establecer el prefijo “NIT” (nitpicker) en los comentarios, lo que significa que puedes sugerir un cambio, pero no bloquea ni impide que ese el codigo en revisión sea aceptado; es simplemente una “perfección” que sugieres pero que puede ser ignorada.&lt;/p&gt;

&lt;h2 id=&quot;mi-código-es-el-que-esta-en-revisión&quot;&gt;Mi código es el que esta en revisión&lt;/h2&gt;

&lt;p&gt;Por último, ser la persona que recibe las revisiones también requiere práctica.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;No te lo tomes como algo personal.
Aunque recibas un mal comentario, recuerda que el objetivo del equipo siempre será entregar un software de calidad. Se está revisando una parte de tu código, no su persona o tu trabajo en sí.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Se un miembro de equipo.
Otras personas usarán el código que escribiste hoy. Por lo tanto, es fundamental estar abierto a modificar tu trabajo por el bien del equipo y del producto final.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Responde positivamente a los comentarios.
Habrá casos en los que, como desarrollador que escribió el código en revisión, tendrás razones para creer que es la solución que debe fusionarse, sin embargo, si alguien solicita cambios o sugiere algo, debes comunicar tus razones de forma clara y justificada.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Participa en el intercambio de revisiones.
No seas solo un espectador que genera código para ser revisado. Considera que independientemente de tu nivel, la experiencia que se obtiene leyendo código al máximo no se ve superada por nada.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;conclusión&quot;&gt;Conclusión&lt;/h2&gt;

&lt;p&gt;Estamos en el año 2023, y la IA nos acompaña a diario en nuestras actividades, algunas prácticas desaparecerán pero los diferenciadores permanecerán. Una máquina puede decirnos qué está mal o dónde se puede mejorar una parte del código, sin embargo, la calidez, la empatía y el apoyo que otro ser humano puede brindarnos no se puede reemplazar (todavía), sigamos practicándolo y demos lo mejor de nosotros en todos los procesos en los que participamos.&lt;/p&gt;</content><author><name>Sagrario Meneses</name><email>sagrario.meneses@gmail.com</email><uri>https://github.com/smmd</uri></author><category term="crecimiento-profesional," /><category term="comunidad," /><category term="mentoria," /><category term="programación," /><category term="productividad" /><summary type="html">¿Quieres saber si haces una buena revisión de código? Estas en el lugar correcto.</summary></entry><entry><title type="html">La importancia de entender los principios de la computación</title><link href="https://blog.thedojo.mx/2023/02/17/la-importancia-de-entender-los-principios-de-la-computacion.html" rel="alternate" type="text/html" title="La importancia de entender los principios de la computación" /><published>2023-02-17T00:00:00-06:00</published><updated>2023-02-17T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2023/02/17/la-importancia-de-entender-los-principios-de-la-computacion</id><content type="html" xml:base="https://blog.thedojo.mx/2023/02/17/la-importancia-de-entender-los-principios-de-la-computacion.html">&lt;p&gt;Este artículo está inspirado por lo que leí en el resumen del libro que &lt;a href=&quot;https://camilochs.github.io/web/&quot;&gt;Camilo Chacón Sartori&lt;/a&gt; está escribiendo y que muy amablemente me compartió para que le diera mi opinión. El libro se llama &lt;strong&gt;“Principios de programación”.&lt;/strong&gt; Espero que pronto esté disponible, pero mientras, hablemos de la importancia de comprender los principios básicos de la computación y programación, con la esperanza de que te emociones por aprender más sobre ellos.&lt;/p&gt;

&lt;p&gt;Empecemos hablando de qué son los principios.&lt;/p&gt;

&lt;h2 id=&quot;qué-es-un-principio&quot;&gt;¿Qué es un principio?&lt;/h2&gt;

&lt;p&gt;En donde más se oye este término si no estás metido en ciencia es en ética. Por ejemplo, dice que una persona o una empresa tiene “principios”. ¿A qué se refiere?&lt;/p&gt;

&lt;p&gt;Yo definiría un principio como un hecho que está en &lt;strong&gt;los fundamentos&lt;/strong&gt; de un sistema de creencias. Por eso, cuando hablamos de una persona con principios, nos referimos a alguien que tiene bien claro lo que &lt;em&gt;piensa del mundo&lt;/em&gt; y de las situaciones que se le presentan. Como consecuencia, tiene claro cómo &lt;em&gt;actuará&lt;/em&gt; en cada situación.&lt;/p&gt;

&lt;p&gt;En las ciencias, un principio es más o menos lo mismo, un hecho comprobado que da pie y soporte a una teoría más amplia, que nos permite comprender el mundo y generar más conocimiento, sea mediante la experimentación o la reflexión (esto incluye la inducción, deducción y predicción).&lt;/p&gt;

&lt;p&gt;En las leyes, un principio es una guía general que da soporte a normas y leyes.&lt;/p&gt;

&lt;p&gt;Como resumen: un principio fundamenta un sistema de creencias, una teoría o una ley. Así que esto te puede dar una idea de lo importante que es entender los principios de tu profesión. Hablemos de los principios más importantes relacionados con la computación y el desarrollo de software.&lt;/p&gt;

&lt;h2 id=&quot;principios-importantes-de-la-computación&quot;&gt;Principios importantes de la computación&lt;/h2&gt;

&lt;p&gt;Desde mi punto de vista, los principios más importantes tienen que ver con la naturaleza misma de la computación y nuestra manera de interactuar con ella. Entender los límites y lo que podemos hacer con una computadora es primordial para poder desarrollar software de calidad.&lt;/p&gt;

&lt;p&gt;Estos principios incluyen:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Las mejores formas de representar información&lt;/li&gt;
  &lt;li&gt;La complejidad de las operaciones en tiempo y espacio (memoria)&lt;/li&gt;
  &lt;li&gt;Cosas imposibles de lograr con una computadora&lt;/li&gt;
  &lt;li&gt;Los diferentes modelos de computación que se han inventado (¿o descubierto?)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;¿Se te ocurre algún otro? Me gustaría leerlo en los comentarios.&lt;/p&gt;

&lt;h2 id=&quot;principios-de-conducta&quot;&gt;Principios de conducta&lt;/h2&gt;

&lt;p&gt;Como casi todas las carreras humanas, las ciencias de la computación y el desarrollo de software tiene prácticas que conviene seguir, sobre todo si se quiere dominarlas y pasarla bien haciéndola. A estos los llamamos principios de conducta.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;¿Qué prácticas nos conviene tener?&lt;/strong&gt; La mayoría tiene que ver con la capacidad de tratar bien con las personas. Casi ningún software serio se puede hacer solo en tiempo razonable (pero por supuesto que hay &lt;a href=&quot;https://stackoverflow.blog/2021/12/31/700000-lines-of-code-20-years-and-one-developer-how-dwarf-fortress-is-built/&quot;&gt;excepciones&lt;/a&gt;). Por eso, considero que los principios de conducta más importantes son:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;La capacidad de comunicar tus ideas efectivamente&lt;/li&gt;
  &lt;li&gt;Responsabilidad&lt;/li&gt;
  &lt;li&gt;Capacidad de resolver conflictos&lt;/li&gt;
  &lt;li&gt;Organización del tiempo de trabajo&lt;/li&gt;
  &lt;li&gt;Capacidad de dividir el trabajo y repartirlo&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Además de estas capacidades o principios se tienen que desarrollar otra conductas que son importantes individualmente:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;La capacidad de aprender de forma efectiva&lt;/li&gt;
  &lt;li&gt;Atención a los detalles&lt;/li&gt;
  &lt;li&gt;Resiliencia y perseverancia&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Todas estas son cosas que casi cualquier profesional debe tener, pero son superlativamente importantes en el desarrollo de software si quieres avanzar. Aquí sólo hablamos de los nombres, pero si te interesa alguna puedes investigar más profundamente sobre ese principio.&lt;/p&gt;

&lt;h2 id=&quot;principios-de-programación-libro&quot;&gt;Principios de Programación (libro)&lt;/h2&gt;

&lt;p&gt;Camilo Chacón Sartori, un gran amigo de The Dojo MX, está terminando de escribir un libro que se llama “Principios de Programación” (tal vez para cuando leas esto ya esté disponible). En él, habla mucho más extensamente de los principios que hemos mencionado en este post.&lt;/p&gt;

&lt;p&gt;Ahí podrás encontrar temas como las cosas que debes entender fundamentalmente de la computación hasta sus recomendaciones de lo que hace falta para tener una buena vida, claro, todo relacionado con la actividad de programar como tu profesión. No te lo pierdas si quieres seguir avanzando en tu carrera como desarrollador@ de software.&lt;/p&gt;

&lt;h2 id=&quot;conclusión&quot;&gt;Conclusión&lt;/h2&gt;

&lt;p&gt;Conocer y aplicar los principios de la ciencias de la computación y relacionados con la creación de software te ayudará a disfrutar más del trabajo, a avanzar en tu carrera y conseguir mejores resultados. Continua profundizando en ellos y aprendiendo más formas de aplicarlos, para mejorar tu trabajo y tu vida.&lt;/p&gt;

&lt;p&gt;Gracias a &lt;a href=&quot;https://camilochacon&quot;&gt;Camilo Chacón Sartori&lt;/a&gt; por escribir sobre este tipo de cosas y levantar temas tan importantes.&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="computer-science" /><category term="computación" /><category term="principios" /><summary type="html">A veces, entre tantas herramientas y tecnologías que podemos usar día a día, nos olvidamos de los principios básicos que soportan todo lo que hacemos como desarrolladores.</summary></entry><entry><title type="html">Máquinas de Turing no deterministas y problemas NP</title><link href="https://blog.thedojo.mx/2023/02/08/maquinas-de-turing-no-deterministas-y-problemas-np.html" rel="alternate" type="text/html" title="Máquinas de Turing no deterministas y problemas NP" /><published>2023-02-08T00:00:00-06:00</published><updated>2023-02-08T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2023/02/08/maquinas-de-turing-no-deterministas-y-problemas-np</id><content type="html" xml:base="https://blog.thedojo.mx/2023/02/08/maquinas-de-turing-no-deterministas-y-problemas-np.html">&lt;p&gt;En el artículo anterior hablamos de las clases de complejidad y su relación con la criptografía. Hablamos brevemente de los problemas NP y de dijimos que pueden ser resueltos por una máquina de Turing no determinista en un tiempo razonable (complejidad polinomial).&lt;/p&gt;

&lt;p&gt;En este artículo vamos a entender qué son las máquinas de Turing no deterministas, pero empecemos entendiendo la diferencia entre determinismo y no determinismo.&lt;/p&gt;

&lt;h2 id=&quot;determinismo-y-no-determinismo&quot;&gt;Determinismo y no determinismo&lt;/h2&gt;

&lt;p&gt;En la física y las ciencias existen básicamente dos tipos de sistemas basados en el conocimiento que podemos tener de su comportamiento en un momento dado.&lt;/p&gt;

&lt;p&gt;El primer tipo es el de los sistemas deterministas, en el que saber el estado actual del sistema y el evento (o la entrada del sistema) nos permite predecir el estado futuro del sistema, sin errores y con una precisión infinita. En estos sistemas existen una serie de reglas que no se pueden romper y que nos dan la capacidad saber exactamente lo que sucederá. Estos sistemas son casi siempre simplificaciones del mundo real o sistemas creados y diseñados por el hombre. Ejemplos de estos sistemas son:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;El juego de la vida&lt;/li&gt;
  &lt;li&gt;El ajedrez&lt;/li&gt;
  &lt;li&gt;El juego de Go&lt;/li&gt;
  &lt;li&gt;Casi todos los problemas que analizamos en un clase de física son tratados como deterministas, por ejemplo, el movimiento de un proyectil, una mesa de billar, etc., aunque no lo sean realmente, se tratan como tales para simplificar el análisis.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;El segundo tipo son los &lt;strong&gt;sistemas no deterministas o estocásticos&lt;/strong&gt;. En estos sistemas no tenemos la información suficiente para poder predecir estados futuros del sistema de manera precisa, solamente podemos predecir probabilidades. Algunos ejemplos de estos sistemas son:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;El clima&lt;/li&gt;
  &lt;li&gt;El comportamiento de una persona&lt;/li&gt;
  &lt;li&gt;El comportamiento de un mercado de un mercado financiero&lt;/li&gt;
  &lt;li&gt;Una selección aleatoria de elementos de un conjunto&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;En pocas palabras, en un sistema determinista podemos predecir la salida si conocemos la entrada con toda seguridad. En un sistema no determinista o estocástico sólo podemos dar una probabilidad de que algo suceda en el mejor de los casos.&lt;/p&gt;

&lt;h2 id=&quot;máquinas-de-turing-deterministas&quot;&gt;Máquinas de Turing deterministas&lt;/h2&gt;

&lt;p&gt;Si no sabes lo que es una máquina de Turing tradicional, una de las mejores explicaciones que hemos encontrado está en el libro &lt;a href=&quot;/assets/pdfs/la_mente_nueva_del_emperador.pdf&quot; target=&quot;_blank&quot;&gt;“La Mente nueva del Emperador”&lt;/a&gt; de &lt;strong&gt;Roger Penrose&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Lo que debes saber es que estas representan un modelo universal de computación, todo lo que se puede computar (calcular, o conocer con certeza) se puede representar en una máquina de Turing. Te la puedes imaginar como una máquina que lee de una cinta infinita que contiene tanto las instrucciones como los datos de entrada. ¿Te suena? Es como funcionan las computadoras actualmente: el ejecutor es el CPU y la cinta es la memoria.&lt;/p&gt;

&lt;p&gt;La máquina de Turing como se definió es determinista, es decir siempre para el la misma entrada obtendremos la misma salida. En cada punto de su cálculo la máquina de Turing sabe &lt;strong&gt;exactamente qué hacer&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Ahora hablemos de otro modelo de computación: las máquinas de Turing no deterministas.&lt;/p&gt;

&lt;h2 id=&quot;máquinas-de-turing-no-deterministas&quot;&gt;Máquinas de Turing no deterministas&lt;/h2&gt;

&lt;p&gt;Apliquemos el concepto del “no determinismo” al modelo de computación de lo que acabamos de hablar. Recordemos que la en la máquina de Turing tradicional, para un mismo estado y una misma entrada de datos (o eventos), siempre obtendremos la misma acción.
En contraparte, una máquina no determinista puede tener múltiples acciones para un mismo estado y una misma entrada o evento.&lt;/p&gt;

&lt;p&gt;Esto implica que este tipo de computación también puede tener múltiples resultados posibles para un mismo conjunto de entrada.&lt;/p&gt;

&lt;p&gt;El comportamiento de una máquina de Turing no determinista es hasta cierto grado impredecible. Incluso con las mismas entradas y estados, la máquina puede devolver diferentes resultados en diferentes ejecuciones.&lt;/p&gt;

&lt;p&gt;Estas máquinas también fueron definidas (o más bien, mencionadas) en el mismo documento en que Turing definió las máquinas tradicionales: &lt;a href=&quot;/assets/pdfs/Turing_Paper_1936.pdf&quot; target=&quot;_blank&quot;&gt;ON COMPUTABLE NUMBERS, WITH AN APPLICATION TO THE ENTSCHEIDUNGSPROBLEM&lt;/a&gt;. A estas él las llamó &lt;strong&gt;máquinas de selección&lt;/strong&gt; (choice machines o &lt;em&gt;c-machine&lt;/em&gt;). La definición más formal la podemos encontrar en  un documento escrito por Rabin y Scott en 1959: &lt;a href=&quot;/assets/pdfs/rabin_scott_1959.pdf&quot; target=&quot;_blank&quot;&gt;Finite Automata and Their Decision Problems&lt;/a&gt;, en el que se habla de Autómatas Finitos No Deterministas (AFND), una especialización finita de las máquinas de Turing.&lt;/p&gt;

&lt;p&gt;A diferencia de los sistemas no deterministas de los que hablamos arriba, las máquinas de Turing no deterministas no es que tengan una probabilidad de pasar de un estado a otro, sino que la máquina puede “seleccionar” una transición de un estado a otro. En el documento de Turing mencionado anteriormente, se menciona que estas máquinas son “operadas” por un humano, que &lt;strong&gt;elige&lt;/strong&gt; qué camino tomar, por eso las llamó máquinas de selección. En referencias más modernas no se especifica el mecanismo de selección.&lt;/p&gt;

&lt;p&gt;Para una misma entrada una máquina de Turing no determinista puede tener múltiples salidas posibles, algunas de ellas válidas y otras no. Para que una máquina de Turing encuentre el resultado correcto, &lt;strong&gt;debe probar todas las posibles salidas y seleccionar la correcta&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Una NTM (&lt;em&gt;Non-deterministic Turing Machine&lt;/em&gt;, así la llamaremos a partir de ahora) es una construcción matemática que no existe en la vida real, es decir, no hay computadora que funcione como una NTM.&lt;/p&gt;

&lt;h2 id=&quot;relación-entre-las-máquinas-de-turing-deterministas-y-no-deterministas&quot;&gt;Relación entre las máquinas de Turing deterministas y no deterministas&lt;/h2&gt;

&lt;p&gt;Se ha demostrado que para cada máquina de Turing no determinista existe una máquina de Turing determinista equivalente. Lo malo es que esta máquina de Turing determinista necesita &lt;strong&gt;exponencialmente&lt;/strong&gt; más nodos o &lt;em&gt;pasos&lt;/em&gt;. Por ejemplo, si una NTM necesita tiene 100 posibles estados, entonces la máquina de Turing equivalente necesitará aproximadamente 2^100 estados.&lt;/p&gt;

&lt;p&gt;Y aquí es donde entra la relación con los problemas NP.&lt;/p&gt;

&lt;h2 id=&quot;relación-con-los-problemas-np&quot;&gt;Relación con los problemas NP&lt;/h2&gt;

&lt;p&gt;Como te darás cuenta, las NTM tienen mucho que ver con la combinatoria, porque necesitan probar todas las posibles combinaciones de estados y transiciones para encontrar la solución correcta.&lt;/p&gt;

&lt;p&gt;Si ejecutáramos una NTM en una computadora, tendríamos que probar cada uno de esos estados. Esto es exactamente lo mismo que sucede con muchos problemas NP o NP-completo, para encontrar una solución se tienen que probar todas las posibles combinaciones en un conjunto de elementos.&lt;/p&gt;

&lt;p&gt;Las siglas NP significan &lt;em&gt;Non-deterministic Polynomial&lt;/em&gt; (polinomial no determinista), y esto significa que en una NTM hay por lo menos un camino que resuelve el problema en un tiempo polinomial. &lt;em&gt;El problema es saber cuál de todos los caminos&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Y de ahí viene su nombre. Todos estos problemas tienen una solución que corre en tiempo polinomial, pero para encontrarla tenemos que &lt;em&gt;adivinar&lt;/em&gt; o &lt;em&gt;probar todas las combinaciones&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusión&quot;&gt;Conclusión&lt;/h2&gt;

&lt;p&gt;Ahora que sabemos como funciona una máquina de Turing no determinista, que es una construcción teórica que nos sirve para hacer experimentos del pensamiento y  además que tienen una relación muy estrecha con la teoría de la complejidad y los problemas NP.&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="turing" /><category term="ntm" /><category term="non-deterministic" /><summary type="html">Hablemos de la relación que existe entre las máquinas de Turing no deterministas (NTM), la complejidad y los problemas NP.</summary></entry><entry><title type="html">Problemas difíciles de la computación y su relación con la criptografía: Problemas NP</title><link href="https://blog.thedojo.mx/2023/02/03/problemas-dificiles-de-la-computacion-y-su-relacion-con-la-criptografia.html" rel="alternate" type="text/html" title="Problemas difíciles de la computación y su relación con la criptografía: Problemas NP" /><published>2023-02-03T00:00:00-06:00</published><updated>2023-02-03T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2023/02/03/problemas-dificiles-de-la-computacion-y-su-relacion-con-la-criptografia</id><content type="html" xml:base="https://blog.thedojo.mx/2023/02/03/problemas-dificiles-de-la-computacion-y-su-relacion-con-la-criptografia.html">&lt;p&gt;La intuición a veces nos dice que cualquier cálculo numérico &lt;em&gt;debería&lt;/em&gt; ser muy fácil para una computadora. Sin embargo, hay problemas numéricos y no numéricos que son imposibles de resolver para las computadoras actuales, independientemente de su poder de procesamiento.&lt;/p&gt;

&lt;p&gt;La &lt;strong&gt;criptografía&lt;/strong&gt; actual está soportada por una serie de problemas que &lt;em&gt;suponemos muy difíciles&lt;/em&gt; de resolver de la ciencias de la computación.&lt;/p&gt;

&lt;p&gt;En esta serie de artículos vamos a estar hablando de ellos para entenderlos a profundidad y sobre todo para entender cómo es que se relacionan con los algoritmos criptográficos, como con los algoritmos de llave pública, como Diffie-Hellman y RSA.&lt;/p&gt;

&lt;p&gt;Pero primero hablemos de lo que consideramos un problema difícil de la computación y la complejidad computacional.&lt;/p&gt;

&lt;h2 id=&quot;complejidad-computacional&quot;&gt;Complejidad computacional&lt;/h2&gt;

&lt;p&gt;La complejidad computacional se puede entender como la &lt;strong&gt;cantidad de operaciones&lt;/strong&gt; que un algoritmo ejecuta para finalizar. Esta cantidad de operaciones es una función (en el sentido &lt;em&gt;matemático&lt;/em&gt;) de la entrada del problema. Puedes pensar en una función como una relación entre la entrada y el tiempo de ejecución.&lt;/p&gt;

&lt;p&gt;Por ejemplo, si te piden contar todas las letras “a” e una cadena, esto podría resolverse de la siguiente manera en Python:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;contar_a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;¿Cuántas operaciones tarda este algoritmo? Como dijimos &lt;em&gt;depende&lt;/em&gt; de la entrada. Esa relación de dependencia es una función. Lo que la función nos dice es &lt;em&gt;qué relación existe&lt;/em&gt; entre la entrada y la cantidad de operaciones que se ejecutan.&lt;/p&gt;

&lt;p&gt;En este ejemplo específico, tenemos que hacer  1 ó 2 operaciones por cada letra de la entrada, y esto no cambia, independientemente de la longitud de esta cadena de entrada. Por lo tanto la función que describe la relación entre la entrada y la cantidad de operaciones es:&lt;/p&gt;

\[f(n) = 2n\]

&lt;p&gt;Donde $n$ es la longitud de la cadena de entrada. Como esta relación crece proporcionalmente a la entrada, es decir, lo mismo que crece la entrada crece el tiempo de ejecución, decimos que este algoritmo es de complejidad lineal.&lt;/p&gt;

&lt;h2 id=&quot;complejidad-polinomial-p&quot;&gt;Complejidad polinomial (P)&lt;/h2&gt;

&lt;p&gt;Un polinomio es una expresión matemática que consiste en sumas, restas, multiplicaciones, divisiones y potencias de números.&lt;/p&gt;

&lt;p&gt;Un algoritmo es de complejidad polinomial si su tiempo de ejecución es una función que consiste en multiplicaciones, sumas o elevaciones a &lt;em&gt;ciertas&lt;/em&gt; potencias del tamaño de la entrada. Algunos ejemplos de complejidad polinomial son:&lt;/p&gt;

\[f(n) = 2n\]

\[f(n) = 3n^2\]

\[f(n) = 4n^3\]

\[f(n) = n^{log(n)}\]

&lt;p&gt;En la práctica, si un algoritmo es tiene complejidad polinomial quiere decir que su ejecución es más o menos rápida (o por lo menos posible en caso de polinomios muy grandes) para cualquier entrada.&lt;/p&gt;

&lt;h2 id=&quot;la-notación-big-o&quot;&gt;La notación Big O&lt;/h2&gt;

&lt;p&gt;La notación más usada para expresar la complejidad no es la de una función común como lo hemos hecho hasta ahora. Normalmente, lo que nos interesa es expresar o conocer &lt;strong&gt;el peor de los casos&lt;/strong&gt; para un algoritmo específico. Por ejemplo, si estamos observando un algoritmo de búsqueda como el siguiente:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;buscar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lista&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elemento&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lista&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)):&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lista&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elemento&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;El peor de los casos es cuando el elemento esté en el último lugar. Por lo tanto, su complejidad en el peor de los casos depende directamente de la longitud de la lista de entrada. Podemos expresar esta complejidad con una función como:&lt;/p&gt;

\[f(n) = n\]

&lt;p&gt;Pero la notación Big O nos permite expresar esto de una manera más simple:&lt;/p&gt;

\[O(n)\]

&lt;p&gt;En el ejemplo de arriba, de la búsqueda de las letras “a” en una cadena, la complejidad que calculamos expresada como función en el peor de los casos es:&lt;/p&gt;

\[f(n) = 2n\]

&lt;p&gt;En la notación Big O se eliminan todas los valores constantes, y por la tanto esta complejidad se expresa como:&lt;/p&gt;

\[O(n)\]

&lt;p&gt;Equivalente al ejemplo anterior. Lo que tienes que recordar de la notación Big O es que te da un &lt;strong&gt;límite superior&lt;/strong&gt; de operaciones que se ejecutarán para un algoritmo. Este límite lo podemos pensar como una línea que el algoritmo nunca va a tocar y mucho menos a rebasar, esto se llama una asíntota en matemáticas, por lo que también se le conoce como &lt;strong&gt;notación asintótica&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;En este artículo no vamos a hablar de cómo calcular más complejidades, pero probablemente lo hagamos en uno futuro. A este tipo de cálculo, o análisis de algoritmos se le llama &lt;strong&gt;“análisis asintótico”&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Ahora, con esta notación, estamos listos para seguir hablando de las clases de complejidad.&lt;/p&gt;

&lt;h2 id=&quot;complejidad-súper-polinomial&quot;&gt;Complejidad súper polinomial&lt;/h2&gt;

&lt;p&gt;Una clase que estaría bien separar de los polinomios que acabamos de hablar, es la de los tiempos &lt;em&gt;súper polinomiales&lt;/em&gt;. Estos algoritmos tienen una complejidad que crece muy rápido con respecto a su entrada. Por ejemplo:&lt;/p&gt;

\[O(n^{n ^ 2})\]

\[O(n!)\]

\[O(2^n)\]

&lt;p&gt;Estos tres ejemplos crecen más rápido que cualquier función polinomial que común que podamos representar como \(O(n^k)\), siendo k &lt;em&gt;una constante&lt;/em&gt; (que normalmente es un número pequeño).&lt;/p&gt;

&lt;p&gt;A esta clase de complejidad la empezamos ya a considerar como problemas intratables en la computación. Pero hablemos, dentro de los tiempos súper polinomiales de otra clase característica.&lt;/p&gt;

&lt;h3 id=&quot;complejidad-exponencial-exp&quot;&gt;Complejidad Exponencial (EXP)&lt;/h3&gt;

&lt;p&gt;La clase de complejidad exponencial se expresa como \(O(2^n)\). Cuando un algoritmo tiene un complejidad de esta categoría o mayor, se considera completamente incalculable.&lt;/p&gt;

&lt;p&gt;Por ejemplo, si midiéramos la entrada en bits y tuviéramos una entrada de 100 bits, el número de operaciones sería \(2^{100}\). Suponiendo que una buena computadora pudiera hacer 1,000,000 de operaciones por segundo, esta tardaría \(2^{81}\) segundos en completar el cálculo. Sin embargo, calculamos que el universo “sólo” ha existido por menos de \(2^{34}\). Así de grande es la complejidad exponencial.&lt;/p&gt;

&lt;p&gt;Te preguntarás si con una computadora más rápida podemos resolver el problema. Veamos el récord de la computadora más poderosa en 2023, que puede hacer 1,000,000,000,000,000,000 de operaciones por segundo. Esto es \(2^{59.8}\). Esto significa que una computadora de este tamaño tardaría \(2^{40.2}\) segundos. “Poco” más que la edad del universo.&lt;/p&gt;

&lt;p&gt;Este tipo de algoritmos son los que hay que ejecutar para encontrar una llave por fuerza bruta. Si quieres por ejemplo encontrar una llave de &lt;a href=&quot;/2020/12/03/tipos-de-algoritmos-criptograficos.html#aes&quot;&gt;AES&lt;/a&gt;, tendrías que hacer \(2^128\) intentos, en el peor de los casos.&lt;/p&gt;

&lt;h2 id=&quot;tiempos-polinomiales-no-deterministas-np&quot;&gt;Tiempos polinomiales no deterministas (NP)&lt;/h2&gt;

&lt;p&gt;Hasta ahora hemos hablado de tiempos polinomiales que estamos seguros que &lt;em&gt;siempre&lt;/em&gt; se van a comportar como los conocemos o incluso van a mejorar.&lt;/p&gt;

&lt;p&gt;Para las clases que hemos hablado existe su equivalente &lt;em&gt;no determinista&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;¿Qué tiene que ver el determinismo con la complejidad? El determinismo en las clases anteriores significa que sabemos con certeza que el resultado está abajo de la línea de complejidad que la notación Big O describe.&lt;/p&gt;

&lt;p&gt;En el caso de los tiempos polinomiales no deterministas significa que una máquina de Turing no determinista puede resolver el problema en un tiempo polinomial. El que la máquina sea no determinista significa que no sabemos si el resultado está abajo de la línea de complejidad que la notación Big O describe, o que a veces lo logrará y otras veces no.&lt;/p&gt;

&lt;p&gt;Esto en otras palabras, significa que para los problemas con complejidad NP se puede &lt;strong&gt;adivinar&lt;/strong&gt; una solución en un tiempo finito no muy grande, pero no se puede encontrar esta solución o garantizar que se encontrará en un tiempo razonable para cada una de las entradas del algoritmo.&lt;/p&gt;

&lt;p&gt;Otra característica que tienen los problemas NP es que aunque encontrar una solución sea difícil, verificarla es fácil.&lt;/p&gt;

&lt;p&gt;Un ejemplo de un problema NP es el de encontrar una llave de &lt;a href=&quot;/2020/12/03/tipos-de-algoritmos-criptograficos.html#aes&quot;&gt;AES&lt;/a&gt; cuando conocemos el texto plano. Usando la fuerza bruta por ejemplo, podríamos encontrar la llave en un golpe de suerte y podríamos verificar que la llave es la correcta comparando el texto plano con el texto descifrado, si son iguales, entonces la llave es correcta.&lt;/p&gt;

&lt;p&gt;Muchos de los problemas NP tienen que ver con combinatoria, con problemas que tienen que ver con la cantidad de combinaciones posibles que hay en un conjunto de elementos, justo como las llaves criptográficas.&lt;/p&gt;

&lt;h2 id=&quot;np-complete&quot;&gt;NP-Complete&lt;/h2&gt;

&lt;p&gt;Los problemas NP-Complete son la clase más difícil de resolver dentro de los problemas NP. Estos problemas se pueden transformar en otros problemas NP-complete, lo que significa que si se puede resolver un problema NP-complete, se puede resolver cualquier otro problema NP-complete en un tiempo razonable.&lt;/p&gt;

&lt;h2 id=&quot;problemas-que-creemos-que-son-difíciles-y-problemas-np&quot;&gt;Problemas que creemos que son difíciles y problemas NP&lt;/h2&gt;

&lt;p&gt;La criptografía actual se basa en problemas que creemos que son por lo menos NP. ¿Por qué usamos la palabra “creemos”? Porque no podemos probar que son NP, pero hasta el momento nadie ha encontrado una forma de resolverlos en tiempo polinomial, pero creemos que lo pueden ser. Lo ideal sería usar problemas que sean NP-Complete, pero no hay muchos problemas NP-Complete que se puedan usar en la criptografía, además de que existe la posibilidad de que si resuelven un problema NP-Complete, se resuelvan todos los problemas NP-Complete, lo que rompería la criptografía actual.&lt;/p&gt;

&lt;h2 id=&quot;conclusión&quot;&gt;Conclusión&lt;/h2&gt;

&lt;p&gt;La criptografía moderna se basa en problemas muy difíciles de resolver para cualquier computadora, para los que no existe un algoritmo eficiente que pueda encontrar una solución garantizada cada vez. Algunos de estos problemas son fáciles de verificar una vez que se propone una solución y son justo estos los que son más útiles para la criptografía.&lt;/p&gt;

&lt;p&gt;Lo más interesante es que la criptografía simétrica crea un problema NP con sus llaves: encontrar una llave de cifrado es casi imposible en un tiempo razonable, pero verificar si es correcta si se tiene el tiempo original es muy fácil.&lt;/p&gt;

&lt;p&gt;En los próximos artículos hablaremos específicamente de algunos de estos problemas, sobre todo aquellos en los que la criptografía asimétrica se basa.&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="criptografía" /><category term="computer-science" /><category term="cs" /><category term="complejidad-computacional" /><summary type="html">En esta serie de posts vamos a hablar de una serie de problemas difíciles de la ciencia de la computación y su relación con la criptografía.</summary></entry><entry><title type="html">Patrones para aprendices: Cava más hondo</title><link href="https://blog.thedojo.mx/2023/01/25/patrones-de-aprendizaje-cava-mas-hondo.html" rel="alternate" type="text/html" title="Patrones para aprendices: Cava más hondo" /><published>2023-01-25T00:00:00-06:00</published><updated>2023-01-25T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2023/01/25/patrones-de-aprendizaje-cava-mas-hondo</id><content type="html" xml:base="https://blog.thedojo.mx/2023/01/25/patrones-de-aprendizaje-cava-mas-hondo.html">&lt;p&gt;¿Sientes que sabes un poquito de muchas cosas pero no te sientes con lo confianza de decir que eres experto en algo? Muchos desarrolladores de software sentimos eso, exacerbado por la gran cantidad de herramientas, lenguajes y situaciones que las necesidades del negocio nos impone.&lt;/p&gt;

&lt;p&gt;En este artículo vamos a hablar acerca de un un consejo encontrado en el libro &lt;a href=&quot;https://www.oreilly.com/library/view/apprenticeship-patterns/9780596806842/&quot;&gt;Apprenticeship Patterns&lt;/a&gt; que en español llamaríamos “Patrones para aprendices”. En este libro se mencionan una serie de consejos con acciones para los desarrolladores de software que se consideran aprendices. En realidad es una buena idea siempre tener “la mentalidad del aprendiz”, aquella que considera que tiene mucho que aprender y se mantiene humilde.&lt;/p&gt;

&lt;p&gt;Los consejos de este libro se enmarcan en la misma forma que lo que conocemos como &lt;em&gt;patrones de diseño&lt;/em&gt;, en cada uno se dan tres partes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Contexto&lt;/strong&gt;: describe una situación típica en la que puedes estar en la que el consejo puede ser útil&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Problema&lt;/strong&gt;: describe específicamente el conflicto que surge y que se puede resolver con el consejo&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Solución&lt;/strong&gt;: describe las acciones que puedes tomas para resolver el problema de manera efectiva&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Aunque este libro tiene sus cosas negativas, tiene grandes consejos, como el que vamos a ver en este artículo. Empecemos a hablar de él.&lt;/p&gt;

&lt;h2 id=&quot;la-situación-y-el-problema&quot;&gt;La situación y el problema&lt;/h2&gt;

&lt;p&gt;Eres un desarrollador o desarrolladora de software que se desenvuelve más que decentemente en su trabajo. Te piden algo y aunque no lo conozcas, tienes la habilidad de entender lo suficiente del problema rápidamente para “sacar” el trabajo. Sin embargo, cuando te preguntan en qué te sientes más cómodo programando, o en qué podrías decir que eres un experto, te sientes inseguro de contestar.&lt;/p&gt;

&lt;p&gt;El problema es que no te has dado el tiempo de conocer nada profundamente y sabes un poco, muy poco de hecho, de muchas cosas, generalmente las cosas más superficiales. No entiendes los principios de funcionamiento de las cosas que usas.&lt;/p&gt;

&lt;h2 id=&quot;la-solución&quot;&gt;La solución&lt;/h2&gt;

&lt;p&gt;En el principio que David Hoover nombra “Cava más hondo” (Dig Deeper), sugiere lo siguiente:&lt;/p&gt;

&lt;p&gt;En vez de sólo conformarte por entender lo mínimo aprende a estudiar aquellos problemas que se te presentan con más profundidad. Aprender a investigar el funcionamiento fundamental de las herramientas, lenguajes y técnicas que usas te separará de los desarrolladores que se conforman con el conocimiento mínimo necesario que el día a día nos deja.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Leer las especificaciones y la documentación.&lt;/strong&gt; Esto te va a dar el conocimiento directo de la fuente primaria de la información. Es muy importante leerlo directamente del primer creador porque nadie (o muy pocas personas más) te pueden explicar el trasfondo del asunto tan bien como él. Existen miles de tutoriales o videos ahí afuera, que son útiles en ciertas situaciones, pero para profundizar, hay pocas cosas mejores que las referencias o documentos de diseño originales.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Aprender a usar las herramientas de tu entorno a profundidad.&lt;/strong&gt; La mayoría de los lenguajes de programación tienen herramientas que te permiten entender cómo está corriendo cierta parte del programa. Si tu lenguaje no lo tienen, existen herramientas a nivel del sistema operativo que te permitirán entender el funcionamiento a fondo.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Entiende los problemas a fondo.&lt;/strong&gt; Cuando estés analizando código, un tutorial, o alguien que te explique algo, intenta entender las ideas que están en el fondo de las cosas que te están explicando, no sólo las cosas que están en la superficie. Intenta absorber el pensamiento que los guió a la solución que están presentando. Para hacer esto, debes reconstruir el contexto en el que surgió el problema y la solución que se presenta.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ventajas&quot;&gt;Ventajas&lt;/h2&gt;

&lt;p&gt;Tener estas habilidades te permitirá entender cómo debería funcionar algo, además de el funcionamiento real en acción de lo que estás usando. Si algo no te gusta como funciona, puedes cambiarlo o mejorarlo.&lt;/p&gt;

&lt;p&gt;Al tener conocimiento profundo en ciencias de la computación, es probable que puedas resolver cosas que nunca te imaginaste o que crees una solución que se destaque y deje a las soluciones existentes muy por detrás.&lt;/p&gt;

&lt;p&gt;Finalmente, este conocimiento te puede dar la capacidad de ayudar a tu equipo, enseñándole cosas que harán que tanto ellos como tu empresa avancen más rápido.&lt;/p&gt;

&lt;h2 id=&quot;conclusión&quot;&gt;Conclusión&lt;/h2&gt;

&lt;p&gt;Te preguntarás: &lt;strong&gt;¿de dónde sale el tiempo para aprender esto?&lt;/strong&gt; Puedes apartar un poco de tiempo de tu trabajo, pero debido a las exigencias que el día a día impone, debes considerar esto como un ejercicio de aprendizaje que la mayoría de las veces va a correr por tu cuenta.&lt;/p&gt;

&lt;p&gt;Profundizar en algo es una habilidad que tienes que desarrollar si quieres destacar en tu carrera. El libro menciona una idea que me gusta: el conocimiento profundo es lo que distingue a los constructores de catedrales de los que hacen software común. Me gusta la idea de pensar en el software como una construcción y pensar que puede ser algo tan bonito y tan grande como una catedral.&lt;/p&gt;

&lt;p&gt;Así que ya sabes: si quieres ser un desarrollador o desarrolladora de software que es capaz de construir catedrales, cava más hondo.&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="aprendizaje" /><category term="patrones-de-aprendizaje" /><category term="profundizar" /><category term="conocimiento" /><summary type="html">Hablemos de por qué aprender a profundizar en los temas en los que trabajas día a día es importante para avanzar en tu carrera como desarrolldor de software.</summary></entry><entry><title type="html">¿Qué es el bytecode?</title><link href="https://blog.thedojo.mx/2023/01/22/entendiendo-el-bytecode.html" rel="alternate" type="text/html" title="¿Qué es el bytecode?" /><published>2023-01-22T00:00:00-06:00</published><updated>2023-01-22T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2023/01/22/entendiendo-el-bytecode</id><content type="html" xml:base="https://blog.thedojo.mx/2023/01/22/entendiendo-el-bytecode.html">&lt;p&gt;Tanto para Java como para otros lenguajes que son interpretados, por ejemplo Python o JavaScript, se genera una representación intermedia como resultado de la ejecución o compilación. A este código le llamamos bytecode.&lt;/p&gt;

&lt;p&gt;Hablemos de qué es y para qué existe.&lt;/p&gt;

&lt;h2 id=&quot;qué-es-el-bytecode&quot;&gt;¿Qué es el bytecode?&lt;/h2&gt;

&lt;p&gt;El bytecode es una representación intermedia de tu programa que tiene dos características principales:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;No es tan legible como el código fuente, por ser más compacta.&lt;/li&gt;
  &lt;li&gt;Es independiente de la arquitectura de la máquina, por lo que siempre es la misma representación para tu máquina virtual.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;El objetivo del bytecode entonces es conservar la semántica de tu programa, pero de una forma que sea más fácil de ejecutar en una máquina virtual o el intérprete.&lt;/p&gt;

&lt;p&gt;Se llama &lt;em&gt;bytecode&lt;/em&gt; porque normalmente es una secuencia de bytes que representan tanto las instrucciones como los datos.&lt;/p&gt;

&lt;h2 id=&quot;ejemplo-de-un-bytecode&quot;&gt;Ejemplo de un bytecode&lt;/h2&gt;

&lt;p&gt;Veamos el ejemplo de Elixir y el código de bytes que produce, para entender el con un ejemplo.&lt;/p&gt;

&lt;div class=&quot;language-elixir highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;defmodule&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Hello&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greet&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hello, world!&quot;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;El proceso que Elixir sigue para ejecutarse es el siguiente:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/v1674191298/58786d8c955aaa5df2ebdb5a2c2790da5216b705_bllv3i.png&quot; alt=&quot;Procesamiento de Elixir al Bytecode de BEAM&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fuente: &lt;a href=&quot;https://elixirforum.com/t/getting-each-stage-of-elixirs-compilation-all-the-way-to-the-beam-bytecode/1873/7&quot;&gt;Getting each stage of Elixir’s compilation all the way to the BEAM bytecode&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;La &lt;strong&gt;Bogdan/Björn Erlang Abstract Machine&lt;/strong&gt; (BEAM) tiene un &lt;a href=&quot;http://www.cs-lab.org/historical_beam_instruction_set.html&quot;&gt;set de instrucciones&lt;/a&gt;, que constituyen su bytecode. Estos aunque están semi-documentados aquí, no están documentados oficialmente y pueden cambiar en cada release.&lt;/p&gt;

&lt;p&gt;Cuando compilas una archivo de Elixir, se crea un archivo con el mismo nombre de tu módulo, pero con la extensión &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.beam&lt;/code&gt;. Este archivo contiene el bytecode de tu programa. Para poder verlo en nuestro editor, necesitamos herramientas especiales. Para VSCode, podemos usar la extensión &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=Valentin.beamdasm&quot;&gt;BEAMdasm&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Aquí podemos ver el ejemplo de lo que genera el programa anterior:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Module:  Elixir.Hello

Attributes: &lt;span class=&quot;o&quot;&gt;[{&lt;/span&gt;vsn, &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;72315C84EFAF57A23F8E5FD7551E9C5D]&lt;span class=&quot;o&quot;&gt;}]&lt;/span&gt;

Compilation Info: &lt;span class=&quot;o&quot;&gt;[{&lt;/span&gt;version, 8.2.2&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;, &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;options, &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;no_spawn_compiler_process, from_core, no_core_prepare, no_auto_import]&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;, &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt;, /Users/hectorip/Development/elixir/hello_world/hello_world.exs&lt;span class=&quot;o&quot;&gt;}]&lt;/span&gt;


//Function  Elixir.Hello:__info__/1
label01:  func_info            Elixir.Hello __info__ 1
label02:  select_val           X[0] label09 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;attributes, label08, compile, label08, deprecated, label07, exports_md5, label06, functions, label05, macros, label07, md5, label08, module, label04, struct, label03]
label03:  move                 nil X[0]
          &lt;span class=&quot;k&quot;&gt;return
&lt;/span&gt;label04:  move                 Elixir.Hello X[0]
          &lt;span class=&quot;k&quot;&gt;return
&lt;/span&gt;label05:  move                 &lt;span class=&quot;o&quot;&gt;[{&lt;/span&gt;greet, 0&lt;span class=&quot;o&quot;&gt;}]&lt;/span&gt; X[0]
          &lt;span class=&quot;k&quot;&gt;return
&lt;/span&gt;label06:  move                 7~�t�jO&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;_���lS X[0]
          &lt;span class=&quot;k&quot;&gt;return
&lt;/span&gt;label07:  move                 nil X[0]
          &lt;span class=&quot;k&quot;&gt;return
&lt;/span&gt;label08:  move                 X[0] X[1]
          move                 Elixir.Hello X[0]
          call_ext_only        2 erlang:get_module_info/2
label09:  call_only            1 label17

//Function  Elixir.Hello:greet/0
label10:  func_info            Elixir.Hello greet 0 //line hello_world.exs, 2
label11:  move                 Hello, world! X[0]
          call_ext_only        1 Elixir.IO:puts/1 //line hello_world.exs, 3

//Function  Elixir.Hello:module_info/0
label12:  func_info            Elixir.Hello module_info 0
label13:  move                 Elixir.Hello X[0]
          call_ext_only        1 erlang:get_module_info/1

//Function  Elixir.Hello:module_info/1
label14:  func_info            Elixir.Hello module_info 1
label15:  move                 X[0] X[1]
          move                 Elixir.Hello X[0]
          call_ext_only        2 erlang:get_module_info/2

//Function  Elixir.Hello:-inlined-__info__/1-/1
label16:  func_info            Elixir.Hello &lt;span class=&quot;nt&quot;&gt;-inlined-__info__&lt;/span&gt;/1- 1
label17:  jump                 label16
          int_code_end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Como puedes ver después de las etiquetas que tienen nombres como &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;label01&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;label02&lt;/code&gt;, etc., tenemos instrucciones como &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func_info&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select_val&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;move&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call_ext_only&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call_only&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jump&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int_code_end&lt;/code&gt;, etc. y datos como &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Elixir.Hello&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hello, world!&lt;/code&gt;. Esto es lo que la maquina virtual ya puede ejecutar directamente, o se puede usar para propósitos como optimizaciones si se puede garantizar que la semántica se mantiene.&lt;/p&gt;

&lt;h3 id=&quot;ejemplo-con-javascript&quot;&gt;Ejemplo con JavaScript&lt;/h3&gt;

&lt;p&gt;También podemos ver el bytecode de JavaScript. Si tienes instalado &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node&lt;/code&gt; en tu computadora puedes correr algo como lo siguiente para ver el bytecode de JavaScript:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;node &lt;span class=&quot;nt&quot;&gt;--print-bytecode&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--eval&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;console.log('Hello, world!')&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Te dará un motón de código en bytes que es lo que el intérprete de JavaScript ejecuta. Para entender las partes que tiene podemos empezar por aquí: &lt;a href=&quot;https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775&quot;&gt;Understanding V8’s Bytecode&lt;/a&gt; y aquí &lt;a href=&quot;https://dev.to/_staticvoid/node-js-under-the-hood-8-oh-the-bytecodes-1p6p&quot;&gt;Node.js Under the Hood #8 - Understanding Bytecodes&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Como puedes, en ambos casos el bytecode no es sencillo, de hecho, pero no está diseñado para que los programadores trabajemos con él.&lt;/p&gt;

&lt;h2 id=&quot;resumen&quot;&gt;Resumen&lt;/h2&gt;

&lt;p&gt;El bytecode es un producto secundario e intermedio de la compilación en algunos lenguajes y entornos de ejecución. En algunos casos es directamente el objeto que la máquina virtual ejecuta y en otros se puede pensar como un caché de la ejecución que se puede usar en las ejecuciones posteriores de un programa para mejorar el rendimiento.&lt;/p&gt;

&lt;p&gt;A veces se puede usar el bytecode con otros propósitos, por ejemplo, para hacer optimizaciones en tiempo de ejecución, que es lo que hacen los compiladores bajo de demanda o JIt’s.&lt;/p&gt;

&lt;p&gt;Este pequeño artículo tiene el objetivo de que por lo menos veas físicamente lo que muchas veces se menciona como producto de la compilación o interpretación de un programa, pero que no se explica qué es en la mayoría de los casos.&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="bytecode" /><category term="complación" /><category term="intérprete" /><summary type="html">En algunos lenguajes de programación se genera algo que llamamos bytecode antes de que se ejecute. Hablemos de qué es para que lo entiendas mejor.</summary></entry><entry><title type="html">Qué es la compilación Just In Time (JIT)</title><link href="https://blog.thedojo.mx/2023/01/18/compilacion-just-in-time-que-es.html" rel="alternate" type="text/html" title="Qué es la compilación Just In Time (JIT)" /><published>2023-01-18T00:00:00-06:00</published><updated>2023-01-18T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2023/01/18/compilacion-just-in-time-que-es</id><content type="html" xml:base="https://blog.thedojo.mx/2023/01/18/compilacion-just-in-time-que-es.html">&lt;p&gt;Los lenguajes de programación y los compiladores son de las cosas más interesantes en el desarrollo   de software. Hace tiempo ha empezado a sonar más un término: &lt;strong&gt;JIT&lt;/strong&gt; o compilación &lt;strong&gt;Just In Time&lt;/strong&gt;, ya que varios lenguajes lo han integrado a sus entornos de ejecución, aquí la llamaremos “compilación bajo demanda” (gracias a Manuel Rubio por la sugerencia). Durante el artículo entenderás por qué creemos que esta traducción es adecuada.&lt;/p&gt;

&lt;p&gt;Este tipo de compilación es poco entendida, por eso en este artículo hablaremos de por qué es algo tan usado. Primero empecemos hablando de la compilación en general y después entendamos este &lt;strong&gt;&lt;em&gt;tipo especial de ejecución&lt;/em&gt;&lt;/strong&gt;. Pero empecemos desde las bases.&lt;/p&gt;

&lt;h2 id=&quot;qué-es-compilar&quot;&gt;¿Qué es compilar?&lt;/h2&gt;

&lt;p&gt;Compilar es &lt;strong&gt;traducir de un lenguaje a otro&lt;/strong&gt;. Lo que entendemos como lenguajes compilados generalmente son lenguajes que se  traducen de un lenguaje de programación a un lenguaje de máquina, es decir, a código binario que puede ser ejecutado por un procesador en algunos casos o a código para una máquina virtual (aquí a veces se llama &lt;em&gt;código de bytes&lt;/em&gt; o &lt;em&gt;bytecode&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;A veces usamos el término &lt;em&gt;“transpilación”&lt;/em&gt; (&lt;em&gt;transpilation&lt;/em&gt; en inglés), que se entiende como una forma de traducir o transformar de un lenguaje entendido por los humanos a otro del mismo nivel. Por ejemplo de TypeScript a JavaScript. Esto no es más que otra forma de compilación. Hablemos de cómo surgió la compilación.&lt;/p&gt;

&lt;h3 id=&quot;historia-de-la-compilación&quot;&gt;Historia de la compilación&lt;/h3&gt;

&lt;p&gt;En el capítulo 9 del libro &lt;a href=&quot;https://altenwald.com/historia-de-los-lenguajes-de-programacion&quot;&gt;“Historia de los lenguajes de programación”&lt;/a&gt; de &lt;a href=&quot;https://mobile.twoitter.com/mronerlang&quot;&gt;Manuel Rubio&lt;/a&gt;, se nos cuenta cómo la compilación nació. Al principio los programadores escribían todo lo que su programa necesitaba desde cero. Una programadora muy experimentada y que estuvo desde los comienzos de la programación, &lt;strong&gt;Grace Hopper&lt;/strong&gt;, empezó a juntar código que hacía tareas que se repetían vez tras vez y simplemente lo insertaba donde necesitaba esa tarea.&lt;/p&gt;

&lt;p&gt;Después, se dio cuenta que podía hacer un programa que hiciera lo mismo que ella hacía manualmente, pero que lo hiciera de manera más rápida y eficiente. Así nació el primer compilador” &lt;a href=&quot;https://www.computinghistory.org.uk/det/5487/Grace-Hopper-completes-the-A-0-Compiler/&quot;&gt;&lt;strong&gt;el A-0&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Se llama &lt;strong&gt;compilador&lt;/strong&gt; (Hopper acuñó el término) y no “traductor” porque más allá de simplemente pasar de un lenguaje a otro, junta (compila) todas las piezas de código invocadas en el programa original y las pone en el programa resultante. El programa original para el A-0 consistía en códigos numéricos que indicaban la subrutina a usar seguidos de los datos a introducir en cada una.&lt;/p&gt;

&lt;p&gt;Es interesante pensar que cuando &lt;strong&gt;Grace&lt;/strong&gt; tuvo la idea de crear un programa que hiciera esto, muchos se opusieron diciendo que no era posible que una computadora se programara a sí misma y que aunque lo hiciera, los programas nunca iban a ser tan buenos como los que podía hacer un programador humano.&lt;/p&gt;

&lt;p&gt;A partir de ahí, se fueron creando compiladores más avanzados y la comunidad al poco tiempo se dio cuenta de que el ahorro de tiempo era muy conveniente para todos, aunque con una pequeña penalización en el desempeño del programa final.&lt;/p&gt;

&lt;h3 id=&quot;compilación-por-adelantado&quot;&gt;Compilación por adelantado&lt;/h3&gt;

&lt;p&gt;La compilación tradicional, conocida en inglés como &lt;em&gt;“ahead of time”&lt;/em&gt; (AOT), que en español la llamaríamos &lt;strong&gt;“compilación adelantada”&lt;/strong&gt;, es la que se ha usado desde el principio de la programación. En este tipo compilación, el código fuente se traduce a código final que se ejecutará por un CPU o por una máquina virtual. El código puede ser el código binario o bytecode.&lt;/p&gt;

&lt;p&gt;Gran parte de lo que hacen los compiladores actuales hacen a parte de traducir es optimizar el código, con el objetivo de que el programa sea lo más eficiente posible en ejecución.&lt;/p&gt;

&lt;h2 id=&quot;compilación-just-in-time-jit&quot;&gt;Compilación “Just in Time” (JIT)&lt;/h2&gt;

&lt;p&gt;La compilación “Just in time”, que significa literalmente “justo a tiempo” (en español me gustaría llamarla compilación bajo demanda), más que un proceso de traducción se trata de &lt;strong&gt;optimización&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Esta compilación sucede solamente en lenguajes que usan una representación intermedia antes de que el procesador los ejecute. Esta representación intermedia normalmente es un &lt;a href=&quot;https://www.techopedia.com/definition/3760/bytecode&quot;&gt;bytecode&lt;/a&gt;. El bytecode puede ser ejecutado por una máquina virtual o intérprete. El compilador JIT transforma este bytecode en código máquina directamente para acelerar su ejecución.&lt;/p&gt;

&lt;h3 id=&quot;funcionamiento-de-un-compilador-bajo-demanda&quot;&gt;Funcionamiento de un compilador bajo demanda&lt;/h3&gt;

&lt;p&gt;Para optimizar la ejecución mientras está sucediendo el compilador JIT tiene que hacer por lo menos tres cosas:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Observar&lt;/strong&gt; la ejecución y el código para &lt;em&gt;identificar&lt;/em&gt; partes que se beneficiarían de compilar su código a código máquina. Por ejemplo, código que se ejecuta muchas veces o que se lleva la mayor parte del tiempo de ejecución. A esta etapa se le llama &lt;em&gt;profiling&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Compilar el bytecode&lt;/strong&gt; en código máquina y &lt;em&gt;optimizarlo&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Como puede que esta compilación no sea tan buena como el bytecode original, el compilador debe &lt;strong&gt;regresar&lt;/strong&gt; el bytecode original si la ejecución no mejora.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;ejemplo-con-v8&quot;&gt;Ejemplo con V8&lt;/h2&gt;

&lt;p&gt;El motor de JavaScript V8 creado por Google, es un ejemplo brillante del uso de compilación bajo demanda.&lt;/p&gt;

&lt;p&gt;En el artículo &lt;a href=&quot;/2020/05/17/que-es-un-engine-de-javascript.html&quot;&gt;“Qué es un Engine de JavaScript”&lt;/a&gt; explicamos el funcionamiento con más detalle. Pero en este diagrama puedes ver las partes principales:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/v1589700777/1_ZIH_wjqDfZn6NRKsDi9mvA_wc08nl.png&quot; alt=&quot;diagrama de funcionamiento de V8&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Después de la lectura del código fuente y la transformación en una estructura que ya puede ser ejecutada (el Abstract Syntax Tree), el código se ejecuta en el intérprete.&lt;/p&gt;

&lt;p&gt;El intérprete, llamado &lt;strong&gt;Ignition&lt;/strong&gt; genera además el bytecode que más adelante será compilado por el compilador &lt;strong&gt;TurboFan&lt;/strong&gt; en caso de que sea conveniente. TurboFan recibe las métricas de uso del bytecode (recogidas por Ignition), es decir, los resultados del profiling y basado en eso decide qué compilará a código máquina. Después de compilarlo y observar su funcionamiento (si mejoró la velocidad y se mantuvo la estabilidad) del código, V8 decide si lo mantiene o si regresa al bytecode original. Esta es la línea roja que vemos en el diagrama, cuando algo se “des-optimiza”.&lt;/p&gt;

&lt;p&gt;Y esto es básicamente el funcionamiento de un compilador bajo demanda. La observación del código en acción y la mejora en el mismo momento.&lt;/p&gt;

&lt;h2 id=&quot;otros-lenguajes-que-la-usan&quot;&gt;Otros lenguajes que la usan&lt;/h2&gt;

&lt;p&gt;Las primeras instancias de compilación bajo demanda (también llamada compilación dinámica) se vieron desde los años 60, en Lisp y más adelante con Smalltalk y Self. En este documento puedes ver una historia corta de la compilación bajo demanda y los lenguajes que lo han usado: &lt;a href=&quot;http://eecs.ucf.edu/~dcm/Teaching/COT4810-Spring2011/Literature/JustInTimeCompilation.pdf&quot;&gt;A Brief History of Just-In-Time&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;El lenguaje que popularizó el término JIT fue Java con su máquina virtual &lt;a href=&quot;https://www.oracle.com/java/technologies/whitepaper.html&quot;&gt;HotSpot&lt;/a&gt; creada en Sun Microsystems y ahora poseída por Oracle. Esta máquina virtual se caracterizó por el desempeño que logra. &lt;a href=&quot;https://dblp.org/pid/30/2083.html&quot;&gt;Lars Bak&lt;/a&gt; participó en el desaarrollo de HotSpot, V8 y recientemente en el de la máquina virtual de &lt;a href=&quot;https://dart.dev/&quot;&gt;Dart&lt;/a&gt;. Como te puedes imaginar, Dart también usa compilación bajo demanda. &lt;a href=&quot;https://luajit.org/luajit.html&quot;&gt;Lua&lt;/a&gt; también tie su compilador JIT. Y finalmente, &lt;a href=&quot;https://www.telerik.com/blogs/understanding-net-just-in-time-compilation&quot;&gt;C#&lt;/a&gt;, al ser un competidor directo de Java, tiene usar JIT para ser por lo menos tan rápido como su este.&lt;/p&gt;

&lt;p&gt;Los lenguajes que recientemente han agregado JIT a su máquina virtual o intérprete son:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Ruby con &lt;a href=&quot;https://www.infoworld.com/article/3647999/ruby-31-arrives-with-new-jit-compiler.html&quot;&gt;YJIT&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;PHP desde su versión 8: &lt;a href=&quot;https://php.watch/versions/8.0/JIT&quot;&gt;PHP 8.0&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Erlang desde su versión 24: &lt;a href=&quot;https://www.erlang.org/blog/a-first-look-at-the-jit/&quot;&gt;Erlang 24&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Como puedes ver, tanto lenguajes compilados como interpretados usan JIT. El único requisito es que el lenguaje utilice un código intermedio.&lt;/p&gt;

&lt;h2 id=&quot;desventajas&quot;&gt;Desventajas&lt;/h2&gt;

&lt;p&gt;Como te imaginarás, no todo es miel sobre hojuelas. La compilación bajo demanda tiene algunas desventajas:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Al ser un proceso de compilación dinámica, abre la puerta a algunas vulnerabilidades de seguridad, por ejemplo el &lt;a href=&quot;https://conference.hitb.org/hitbsecconf2010ams/materials/D1T2%20-%20Alexey%20Sintsov%20-%20JIT%20Spray%20Attacks%20and%20Advanced%20Shellcode.pdf&quot;&gt;JIT Spraying&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;El compilador JIT compite con el intérprete por el uso de la CPU. Esto puede afectar el rendimiento del programa.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;El consumo de recursos en general es mayor.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Puede que la forma en la que está hecha tu programa no se beneficie en absoluto de la compilación bajo demanda, por lo que incluso a veces es posible apagarlos.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Si estás en un entorno en el que algo de esto sea muy importante, considera si el entorno en el que estás trabajando puede dessactivarse el JIT. V8, por ejemplo, puede funcionar sin JIT: &lt;a href=&quot;https://v8.dev/blog/jitless&quot;&gt;JIT-less V8&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusión&quot;&gt;Conclusión&lt;/h2&gt;

&lt;p&gt;La compilación bajo demanda ha sido un gran avance en el desarrollo de software, y es un trabajo de ingeniería muy interesante.&lt;/p&gt;

&lt;p&gt;Permite que la ejecución de nuestros programas sea más eficiente y rápida.  Además, a mi punto de ver, es una maravilla de la ingeniería de software. Si quieres aprender más: puedes visitar el &lt;a href=&quot;https://v8.dev/&quot;&gt;sitio oficial de V8&lt;/a&gt;, en el que explican muchas cosas acerca del desarrollo de este sistema pionero en compilación bajo demanda.&lt;/p&gt;

&lt;p&gt;También puedes ver como funciona un compilador por adelantado todavía más antiguo y muy interesante: &lt;a href=&quot;https://developers.redhat.com/articles/2021/06/23/how-jit-compiler-boosts-java-performance-openjdk#deoptimization_and_speculation&quot;&gt;Java HotSpot VM&lt;/a&gt;.&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="jit" /><category term="compiladores" /><category term="compilers" /><category term="compilación" /><category term="just-in-time" /><summary type="html">¿Has escuchado que varios lenguajes están agregando la capacidad de compilación Just In Time a sus entornos? Hablemos de qué es y cómo te beneficia.</summary></entry><entry><title type="html">Ejercicio: programando un perceptrón con Python</title><link href="https://blog.thedojo.mx/2023/01/07/ejercicio-programando-un-perceptron.html" rel="alternate" type="text/html" title="Ejercicio: programando un perceptrón con Python" /><published>2023-01-07T00:00:00-06:00</published><updated>2023-01-07T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2023/01/07/ejercicio-programando-un-perceptron</id><content type="html" xml:base="https://blog.thedojo.mx/2023/01/07/ejercicio-programando-un-perceptron.html">&lt;p&gt;En este post platicaremos acerca de cómo funciona un perceptrón con un ejemplo de código y las técnicas que utiliza para aproximar una función a partir de datos.&lt;/p&gt;

&lt;p&gt;Si no tienes claro lo que es un perceptrón, puedes leer nuestro &lt;a href=&quot;/2021/03/25/intro-a-machine-learning-entendiendo-perceptron.html&quot; target=&quot;_blank&quot;&gt;artículo anterior&lt;/a&gt;. Ahí también explicamos las bases de funcionamiento. En este artículo lo vamos a ilustrar de la manera más sencilla posible.&lt;/p&gt;

&lt;h2 id=&quot;el-conjunto-de-datos&quot;&gt;El conjunto de datos&lt;/h2&gt;

&lt;p&gt;Recuerda que para poder crear un algoritmo de machine learning necesitamos un conjunto de datos, ya que el punto es que este algoritmo &lt;em&gt;aprenda&lt;/em&gt; de estos datos.&lt;/p&gt;

&lt;p&gt;Los datos que un perceptrón puede clasificar deben poder ser separados en mínimo dos clases por alguna característica, ya que si representáramos al perceptrón como una función, es un línea recta en un plano de dos variables (o su equivalente dependiendo del espacio y sus dimensiones, lo que en para más de tres dimensiones llamamos un &lt;em&gt;hiperespacio&lt;/em&gt; matemáticamente).&lt;/p&gt;

&lt;p&gt;No es necesario que los datos &lt;em&gt;sólo&lt;/em&gt; puedan estar divididos en dos clases, por ejemplo, imagínate un conjunto de datos que representa los dígitos escritos a mano, del 0 al 9 (este es conocido como el &lt;a href=&quot;https://www.tensorflow.org/datasets/catalog/mnist&quot;&gt;MNIST dataset&lt;/a&gt;). Cada dígito es una clase, pero un perceptrón nos puede servir para clasificar un solo número, por ejemplo, el 5. El perceptrón serviría para clasificar si un dígito es un 5 o no, lo importante es que el conjunto de datos que representa el 5 sea más o menos separable de los demás dígitos.&lt;/p&gt;

&lt;p&gt;Con esto te puedes empezar a dar cuenta de que el perceptrón es el bloque de construcción más básico de las redes neuronales. Por ejemplo, ¿cómo haríamos para clasificar todos los números del conjunto del que hablamos arriba? Necesitamos un perceptrón por cada número, y tomamos el que más confianza nos devuelva.&lt;/p&gt;

&lt;p&gt;Ahora sí veamos qué dataset usaremos nosotros. Ejemplos usando el MNIST o el &lt;a href=&quot;https://archive.ics.uci.edu/ml/datasets/iris&quot;&gt;Iris&lt;/a&gt; encontrarás en muchos lados, así que vamos a escoger uno diferente.
Este es una alternativa a Iris y se conoce como el &lt;a href=&quot;https://github.com/allisonhorst/palmerpenguins&quot;&gt;Penguin dataset&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;El conjunto de datos de los pingüinos tiene 344 registros etiquetados, cada uno con máximo 6 características (a parte de la etiqueta). Tiene 3 etiquetas diferentes: Adelie, Chinstrap y Gentoo. Las columnas del dataset son:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;species&lt;/strong&gt;: especie del pingüino, esta es la clase o etiqueta&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;island&lt;/strong&gt;: isla donde fue visto el pingüino, tiene 3 valores diferentes: Dream, Torgersen, or Biscoe&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;bill_lenth_mm&lt;/strong&gt;: longitud de la pico del pingüino&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;bill_depth_mm&lt;/strong&gt;: profundidad de la pico del pingüino&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;flipper_length_mm&lt;/strong&gt;: longitud de la aleta del pingüino&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;body_mass_g&lt;/strong&gt;: masa del cuerpo del pingüino&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;sex&lt;/strong&gt;: sexo del pingüino&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Tenemos que explorar los datos brevemente para ver qué variables podemos usar para separar. Como este no es el objetivo de este artículo vamos a ver una imagen en la que comparan por pares las variables y seleccionemos las que nos ayuden a separar mejor las clases. Vamos a hacerlo sólamente con dos variables para que el código nos quede más sencillo y se comprenda la idea principal.&lt;/p&gt;

&lt;p&gt;La siguiente imagen es una gráfica de dos variables: la anchura del pico (&lt;strong&gt;bill_depth_mm&lt;/strong&gt;) y el largo de su aleta (&lt;strong&gt;flipper_length_mm&lt;/strong&gt;). Observa qué bien separa a la clase Gentoo de las otras dos.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/v1673111878/a1f1d1b7-d87c-478d-b67a-c344c802f4d6_spefvh.png&quot; alt=&quot;Gráfica de dos variables&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Nota&lt;/strong&gt;: para el entrenamiento de una rede neuronal se hace una exploración mucho más profunda de los datos, pero para este ejemplo no es necesario.&lt;/p&gt;

&lt;h2 id=&quot;repaso-del-funcionamiento-básico&quot;&gt;Repaso del funcionamiento básico&lt;/h2&gt;

&lt;p&gt;El perceptrón es un algoritmo de aprendizaje &lt;strong&gt;supervisado&lt;/strong&gt;, por lo que necesita datos etiquetados, es decir, &lt;em&gt;las características junto con su clase&lt;/em&gt;. El trabajo del perceptrón es encontrar los parámetros para una función matemática que defina la frontera de separación entre las clases.&lt;/p&gt;

&lt;p&gt;Esta función matemática es una línea recta en un plano de dos dimensiones, o un plano en un espacio de tres dimensiones, o un &lt;strong&gt;hiperplano&lt;/strong&gt; en un espacio de más de tres dimensiones. Puedes pensar en todos estos términos matemáticos como el equivalente a una linea recta en cualquier espacio.&lt;/p&gt;

&lt;h2 id=&quot;el-algoritmo&quot;&gt;El algoritmo&lt;/h2&gt;

&lt;p&gt;El perceptron es busca ajustar una función lineal que separa las clases. En este caso separaremos “Gentoo” de “no es un Gentoo”. El algoritmos nos dirá “1” si es un Gentoo y “0” si no lo es. Una función lieneal tiene la forma:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Con un término &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wn * xn&lt;/code&gt; para cada variable de entrada, y un término &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; para el sesgo. El perceptrón ajusta los valores de &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;w1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;w2&lt;/code&gt;, y &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; para que la función lineal se ajuste a los datos.&lt;/p&gt;

&lt;p&gt;Podemos empezar combinando las dos variables que elegimos de la siguiente manera:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;penguins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'bill_depth_mm'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;penguins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'flipper_length_mm'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Nota&lt;/strong&gt;: En este ejemplo no usaremos &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;numpy&lt;/code&gt; o &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pandas&lt;/code&gt;, para hacer la programación lo más tradicional posible. Más adelante nos empezaremos a meter en &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;numpy&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pandas&lt;/code&gt; y esas cosas que parecen magia negra.&lt;/p&gt;

&lt;p&gt;Esto nos dará un número que tenemos que convertir en un 1 o un 0. Usemos una función sencilla. Todos lo números negativos los convertimos en un 0 y todos los positivos y el 0 en un 1. Esto se puede programar sencillo. Vamos a llamar a esta función &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;paso&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;paso&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ahora podemos usar esta función para convertir la salida de la función lineal en un 1 o un 0:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;clasificar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;Recibe una fila de datos y devuelve 1 si es Gentoo y 0 si no lo es&quot;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;paso&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bill_depth_mm&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flipper_length_mm&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Nuestra función de clasificación ya está lista. Pero el trabajo del perceptrón es encontrar los valores de &lt;strong&gt;los parámetros&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;w1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;w2&lt;/code&gt;, y &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;. Creemos el algoritmo que define estos valores, que llamaremos &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entrenar&lt;/code&gt;. Esta función aprende a base de prueba y error. Para aprender hace lo siguiente:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Clasifica cada dato de entrenamiento&lt;/li&gt;
  &lt;li&gt;Verifica si la etiqueta es correcta (para esto necesitamos las etiquetas de los datos de entrenamiento)&lt;/li&gt;
  &lt;li&gt;Ajusta sus parámetros: cambiar los valores de &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;w1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;w2&lt;/code&gt;, y &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; para que la función lineal se ajuste a los datos.&lt;/li&gt;
  &lt;li&gt;Repite el proceso&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Este proceso puede terminar por dos razones:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Se alcanza un número máximo de iteraciones&lt;/li&gt;
  &lt;li&gt;Se alcanza un resultado satisfactorio (ej. el número de elementos mal clasificados es menor a un umbral)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Para hacerlo sencillo vamos a hacer que el algoritmo se ejecute un número fijo de veces:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;entrenar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;datos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iteraciones&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# inicializamos los parámetros, esto puede ser aleatorio o cero, como lo hacemos aquí
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iteraciones&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;iteraciones&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;datos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;etiqueta_real&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;species&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Gentoo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;clase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clasificar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;etiqueta_real&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;# Aquí tenemos un Gentoo mal clasificado, tenemos que
&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;# aumentar w1 y w2 para que la función lineal se acerque
&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;# a la etiqueta real
&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bill_depth_mm&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flipper_length_mm&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# Valor escogido arbitrariamente
&lt;/span&gt;            &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;etiqueta_real&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;# Aquí tenemos un NO Gentoo mal clasificado, tenemos que
&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;# disminuir w1 y w2 para que la función lineal se acerque
&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;# a la etiqueta real
&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bill_depth_mm&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flipper_length_mm&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# valor escogido arbitrariamente
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Iteración&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iteraciones&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;w1:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;w2:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;b:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Podríamos decir que esto es básicamente todo el algoritmo del perceptrón. Ahora podemos entrenar nuestro perceptrón con los datos de entrenamiento. Antes le hacemos unas cuantas modificaciones para que sea más fácil de usar:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# cargar el archivo CSV con los datos de entrenamiento como diccionario, el archivo está en la carpeta data, un nivel arriba
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../data/penguins.csv&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;csvfile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;csv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DictReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;csvfile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Limpiando los los datos, eliminando los que no tienen bill_depth_mm o flipper_length_mm
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bill_depth_mm&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;NA&quot;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flipper_length_mm&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;NA&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bill_depth_mm&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bill_depth_mm&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flipper_length_mm&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flipper_length_mm&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Estos datos ya está listos para para ser usados. Ahora podemos entrenar el perceptrón:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# Escogemos las iteraciones arbitrariamente
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entrenar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Lo podemos probar con los mismos datos de entrenamiento:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;probar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;correctos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;incorrectos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;clase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clasificar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;etiqueta_real&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;species&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Gentoo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;etiqueta_real&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;correctos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;incorrectos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;

      &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Resultados:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Correctos: &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;correctos&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; - &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;correctos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;%&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Incorrectos: &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;incorrectos&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; - &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;incorrectos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;%&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;probar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Y el resultado es:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Resultados:
Correctos: 219 - 64.03508771929825%
Incorrectos: 123 - 35.96491228070175%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Parece que nuestro perceptrón no logró ni siquiera aprender bien con los datos de entrenamiento. ¿Qué pasa si aumentamos las iteraciones, digamos a 1000?&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entrenar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;probar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;El resultado es:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Resultados:
Correctos: 342 - 100%
Incorrectos: 0 - 0.0%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Parece que con las suficientes iteraciones el perceptrón logra aprender a clasificar perfectamente los datos de entrenamiento. &lt;strong&gt;Tip&lt;/strong&gt;: siempre debes dudar de un algoritmo de inteligencia artificial que clasifique perfectamente, eso puede indicar que se sobreajustó a los datos de entrenamiento y cuando encuentre datos no vistos, fallará.&lt;/p&gt;

&lt;p&gt;Para evitarlo, necesitamos probarlo con datos que no ha visto antes. Para esto vamos a dividir los datos en dos grupos, uno para entrenamiento y otro para pruebas:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# Dividir los datos en dos grupos, uno para entrenamiento y otro para pruebas
&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;random&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shuffle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;entrenamiento&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pruebas&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):]&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entrenar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entrenamiento&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;probar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pruebas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;El resultado es:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Resultados:
Correctos: 69 - 100.0%
Incorrectos: 0 - 0.0%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Y como vemos, sigue funcionando bien con este dataset sencillo. Esta es le estructura básica de un perceptrón, pero en realidad le faltan muchas partes para que funcione de manera general sin gastar demasiado tiempo de cómputo. Por ejemplo, en este código simplemente sumamos o restamos el valor de las variables a w1 y w2. Estos saltos pueden ser muy bruscos y hacernos saltar fácilmente el valor que necesitamos. Para evitar esto, se usa otro parámetro para la función de entrenamiento llamado “ritmo de aprendizaje” (learning rate - lr).&lt;/p&gt;

&lt;p&gt;Vamos a incluirlo en nuestro código:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;entrenar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;datos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iteraciones&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.01&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# inicializamos los parámetros, esto puede ser aleatorio o cero, como lo hacemos aquí
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iteraciones&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;iteraciones&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;datos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;etiqueta_real&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;species&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Gentoo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;clase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clasificar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;## Esta es la revisión de &quot;la verdad&quot;, más adelante la explicamos en la sección &quot;función de pérdida&quot;
&lt;/span&gt;            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;etiqueta_real&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;# Aquí tenemos un Gentoo mal clasificado, tenemos que
&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;# aumentar w1 y w2 para que la función lineal se acerque
&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;# a la etiqueta real
&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bill_depth_mm&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lr&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flipper_length_mm&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lr&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lr&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# Valor escogido arbitrariamente
&lt;/span&gt;            &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;etiqueta_real&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;# Aquí tenemos un NO Gentoo mal clasificado, tenemos que
&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;# disminuir w1 y w2 para que la función lineal se acerque
&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;# a la etiqueta real
&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bill_depth_mm&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lr&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flipper_length_mm&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lr&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lr&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# valor escogido arbitrariamente
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Iteración&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iteraciones&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;w1:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;w2:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;b:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Y ahora vamos a probarlo de nuevo con 100 iteraciones y el lr default:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entrenar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entrenamiento&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;probar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pruebas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;En esta versión podemos ver que con muchas menos iteraciones el perceptrón logra clasificar correctamente los datos de prueba. El resultado es:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Resultados:
Correctos: 69 - 100.0%
Incorrectos: 0 - 0.0%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;función-de-pérdida&quot;&gt;Función de pérdida&lt;/h2&gt;

&lt;p&gt;El último detalle de nuestro perceptrón es la forma en la que revisa si se está acercando a “la verdad”. En este perceptrón simplemente verificamos si la etiqueta está equivocada y elegimos si “acercar” o “alejar” la línea del punto en cuestión.&lt;/p&gt;

&lt;p&gt;Esta es una forma no tradicional de hacerlo, pero con lo que te debes quedar es que debe existir una función que te diga qué tan equivocado estás y que te ayude a acercarte a la verdad. Esta función se llama “función de pérdida” (loss function). En las siguientes versiones del perceptrón vamos a incluir una función de pérdida más sofisticada, “de verdad”.&lt;/p&gt;

&lt;h2 id=&quot;repaso&quot;&gt;Repaso&lt;/h2&gt;

&lt;p&gt;En este artículo vimos todas las partes que un perceptrón, la unidad de construcción más básica de una red neuronal. Un perceptrón tiene:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Una función de predicción. Es la que llamamos &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clasificar&lt;/code&gt; y nos dice si un punto de datos pertenece a una clase o no.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Una función de entrenamiento. Es la que llamamos &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entrenar&lt;/code&gt; y nos ayuda a ajustar los parámetros que le vamos a pasar a la función de predicción para que nos de un resultado correcto.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Una función de pérdida. Es la parte en la función &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entrenar&lt;/code&gt; que nos dice si estamos cerca o lejos de “la verdad”. Esta función es la que vamos a mejorar en las siguientes versiones del perceptrón.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Una función de activación. Esta es la que llamamos &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;paso&lt;/code&gt; y nos ayuda a transformar la salida de la función matemática pura que representa una línea en la salida final de nuestro perceptrón. En nuestro caso necesitábamos 0 o 1.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;conclusión&quot;&gt;Conclusión&lt;/h2&gt;

&lt;p&gt;Este perceptrón funciona, pero no es muy flexible, no se puede usar con otros conjuntos de datos y además con un conjunto de datos más complejo y menos separable probablemente no podría encontrar los parámetros correctos, sin embargo, sigue la arquitectura básica de un perceptrón, que era el punto de este artículo.&lt;/p&gt;

&lt;p&gt;En un siguiente artículo vamos a integrar herramientas matemáticas más poderosas, y vamos a empezar a ver qué tiene qué ver el álgebra lineal con la inteligencia artificial.&lt;/p&gt;

&lt;p&gt;Puedes ver el código completo en este &lt;a href=&quot;https://github.com/hectorip/penguins_perceptron&quot;&gt;repositorio&lt;/a&gt;.&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="machine-learning" /><category term="ia" /><category term="inteligencia-artificial" /><summary type="html">Programemos un perceptrón en Python para entender a fondo como funciona y poder construir sobre eso para temas más complejos.</summary></entry><entry><title type="html">Claridad de Saša Jurić</title><link href="https://blog.thedojo.mx/2022/12/30/claridad-en-el-codigo.html" rel="alternate" type="text/html" title="Claridad de Saša Jurić" /><published>2022-12-30T00:00:00-06:00</published><updated>2022-12-30T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2022/12/30/claridad-en-el-codigo</id><content type="html" xml:base="https://blog.thedojo.mx/2022/12/30/claridad-en-el-codigo.html">&lt;figure&gt;
    &lt;figcaption class=&quot;caption-audio&quot;&gt;Escucha este artículo:&lt;/figcaption&gt;
    &lt;audio style=&quot;width: 100%;&quot; controls=&quot;&quot; src=&quot;https://res.cloudinary.com/hectorip/video/upload/v1672460944/clarity-2_vrm0vk.wav&quot;&gt;
            &lt;a href=&quot;https://res.cloudinary.com/hectorip/video/upload/v1672460944/clarity-2_vrm0vk.wav&quot;&gt;
                Descargar audio
            &lt;/a&gt;
    &lt;/audio&gt;
&lt;/figure&gt;

&lt;p&gt;Hablemos de las cosas que hacen más entendible y claro tu código.&lt;/p&gt;

&lt;p&gt;Muchas de estas ideas están basadas en la plática &lt;a href=&quot;https://www.youtube.com/watch?v=6sNmJtoKDCo&quot;&gt;“Clarity” de Saša Jurić&lt;/a&gt; de la Elixir Conf EU de 2021, de hecho, podríamos considerar este artículo como un análisis y extensión de esa plática.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Cuando trabajamos con bases de código normalmente necesitamos entenderlas. Incluso aunque vayamos a escribir algo nuevo necesitamos entender lo demás para poder integrarlo. Esto lo hacemos mediante la lectura de código.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Los escritores del código nos transmiten información mediante ese código, lo quieran o no.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;La forma en la que obtenemos conocimiento del código es leyéndolo.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;qué-es-la-claridad-y-por-qué-es-mejor-que-el-código-limpio&quot;&gt;¿Qué es la claridad y por qué es mejor que ‘el código limpio’?&lt;/h2&gt;

&lt;p&gt;La claridad como se define en esta plática, es qué tan bien una pieza de código comunica sus verdaderas intenciones. El código claro puede ser entendido sin mucho esfuerzo por alguien que conoce bien el lenguaje: se entiende tanto el problema como la solución que el autor escogió.&lt;/p&gt;

&lt;p&gt;La claridad nos hace más eficientes y efectivos. Primero porque obtenemos información más rápido y segundo porque obtenemos la información correcta.&lt;/p&gt;

&lt;p&gt;Finalmente, la claridad le da poder al equipo porque hace que cualquiera pueda tomar el código y trabajar con él, en vez de sólo el autor, como muchos estamos acostumbrados.&lt;/p&gt;

&lt;p&gt;Para conseguir claridad se tiene que invertir tiempo constantemente. Tienes que recordar que el código es una herramienta de comunicación con otros seres humanos, no sólo con la máquina.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/c_scale,w_800/v1672409158/Screen_Shot_2022-12-28_at_9.37.57_aje64x.png&quot; alt=&quot;Claridad es más concreto que otros términos&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;prácticas-que-mejoran-la-claridad&quot;&gt;Prácticas que mejoran la claridad&lt;/h2&gt;

&lt;p&gt;Hablemos de cosas que tú y tu equipo pueden hacer para producir código más claro.&lt;/p&gt;

&lt;h3 id=&quot;revisión-de-código&quot;&gt;Revisión de código&lt;/h3&gt;

&lt;p&gt;Esto es la práctica de un equipo de integrar el código a la rama principal solamente cuando ha sido evaluado por cierto números de miembros del equipo. El foco principal de la revisión debería ser la claridad del código.&lt;/p&gt;

&lt;p&gt;Para facilitar el proceso, tanto el autor como el revisor pueden seguir ciertas reglas para que el resultado sea código más claro y la revisión sea más fácil.&lt;/p&gt;

&lt;p&gt;El que envía el código puede facilitar el trabajo del revisor de tres maneras:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Envía solicitudes de integración pequeñas: siempre es más fácil de entender poco código que mucho.&lt;/li&gt;
  &lt;li&gt;Commits pequeños como unidades de cambio más fáciles de tratar individualmente. Un commit no debería tener cambios en muchos lugares para no hacerlo demasiado difícil de entender.&lt;/li&gt;
  &lt;li&gt;Clarifica tu código lo mejor posible: la historia de los commits debería estar estructurada linealmente. Además debería revisar su código para asegurarse de que está lo más claro posible.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;El revisor:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Sugerir y mandar mejoras. El revisor debería señalar todos los puntos en los que se le hizo difícil entender el código. También podría mandar los cambios directamente, como un pull request al autor, invirtiendo los papeles temporalmente.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Sincronizar. Es importante tener sesiones si algo no se puede resolver. Estas sesiones de pair programming servirán para clarificar todo aquello que siga siendo confuso.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;prácticas-en-el-código&quot;&gt;Prácticas en el código&lt;/h3&gt;

&lt;p&gt;Saša sugiere seguir las prácticas de progrmación comunes &lt;strong&gt;aplicables al código&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Nombrar variables y funciones de manera explicativa.&lt;/li&gt;
  &lt;li&gt;Seguir los idiomas y patrones de programación &lt;em&gt;aplicables&lt;/em&gt; a tu caso.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;separación-de-responsabilidades&quot;&gt;Separación de responsabilidades&lt;/h3&gt;

&lt;p&gt;Pero además, podemos seguir lo que en español llamamos “separación de responsabilidades” (en inglés “separation of concerns”). Esta idea Dijkstra lo mencionó en su artículo &lt;a href=&quot;https://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD447.html&quot;&gt;On the scientific thougth&lt;/a&gt;. Dijkstra se refería a la forma de pensar en los asuntos complejos desde diferentes ángulos para poder “ignorar” temporalmente los aspectos que no tienen que ver con ese ángulo. Esto permitirá que podamos entender mejor el sistema entero poco a poco.&lt;/p&gt;

&lt;p&gt;En el código lo podemos aplicar haciendo que nuestro código esté separado en módulos que sólo abarquen un aspecto del problema. Esto es imposible de hacer perfectamente, pero nuestro código debería tender hacia allá lo más posible. Por ejemplo, algo que normalmente se hace muy bien es separar el código que maneja la lógica de los datos de la interfaz. Recuerda: &lt;strong&gt;esto es importante porque permitirá al lector solo lidiar con un problema a la vez&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Si ponemos todos los conceptos posibles de programación en una pieza de código (aquí cito directamente a Saša) “¿Quién va a ser capaz de entender algo de eso?”&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/c_scale,w_800/v1672409162/Screen_Shot_2022-12-30_at_8.05.42_ycvhe7.png&quot; alt=&quot;Imagen: Separación de responsabilidades en una base de código&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Advertencia&lt;/strong&gt;: Una idea que Saša menciona bastante es la de no seguir arquitecturas o ideas sólo porque un líder de opinión o alguien con autoridad lo dice. Si haces esto &lt;strong&gt;puede que la parte más compleja de tu código sea tu arquitectura&lt;/strong&gt;, lo cuál es un grave error porque el trabajo de la arquitectura deberías ser crear un sistema más claro.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Consider te actual situation you’re dealing with, [..], don’t just do something because some thought leader or authority says so, even if that person is me. Just think contextually, think inside of your situation.” - Saša Jurić&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Considera tu situación actual, [..], no hagas algo sólo porque un líder de opinión o alguien con autoridad lo dice, incluso si esa persona soy yo. Simplemente piensa contextualmente, piensa en tu situación.” - Saša Jurić&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;testing&quot;&gt;Testing&lt;/h2&gt;

&lt;p&gt;¿Para qué creamos tests? Obviamente, para probar. ¿Pero qué queremos probar? Saša afirma que queremos probar &lt;strong&gt;el comportamiento del software&lt;/strong&gt;. Así, las “unidades” que queremos probar son las unidades de comportamiento y no las unidades de código. Otra recomendación es evitar hacer mocks agresivos, solamente en dónde sea estrictamente necesario para lograr comportamientos repetibles. Esto es porque, el uso de dobles en los tests (como los mocks) complica el código de pruebas, pero también complica el código de producción.&lt;/p&gt;

&lt;p&gt;Cuando los tests son demasiado complicados o están ligados a la implementación en vez del al comportamiento externo, vas a tener que dividirte entre arreglar los test o arreglar el código de producción, lo cuál es frustrante y una mala idea para tu productividad en general. Un test debe ser fácil de entender y comunicar exactamente lo que está probando, nada más, nada menos.&lt;/p&gt;

&lt;p&gt;Recomendación: Libro &lt;a href=&quot;https://www.manning.com/books/unit-testing&quot;&gt;Unit Testing&lt;/a&gt; de Vladimir Khorikov. Saša lo recomienda como una muy buena lectura.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/c_scale,w_800/v1672450947/Screen_Shot_2022-12-30_at_12.03.25_nedtbg.png&quot; alt=&quot;Recomendación de libro TDD por Saša Jurić: Unit Testing de editorial Manning&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusión&quot;&gt;Conclusión&lt;/h2&gt;

&lt;p&gt;Una de las tareas más importantes cuando hacemos código es hacer que comunique claramente el problema que resuelve y cómo lo resuelve. Si hacemos eso, lograremos que nuestro equipo o nosotros mismos podamos continuar con el trabajo y lo mejor: evolucionarlo.&lt;/p&gt;

&lt;p&gt;En la siguiente imagen verás el resumen de las recomendaciones de Saša Jurić para escribir código más claro:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/c_scale,w_800/v1672450967/Screen_Shot_2022-12-30_at_18.48.20_hekzsv.png&quot; alt=&quot;Usa el código para comunicarte, revisa el código, separación de responsabilidades y prueba el comportamiento del código&quot; /&gt;.&lt;/p&gt;

&lt;p&gt;Puedes ver la charla completa en &lt;a href=&quot;https://www.youtube.com/watch?v=6sNmJtoKDCo&quot;&gt;YouTube&lt;/a&gt;. &lt;a href=&quot;https://twitter.com/mronerlang&quot;&gt;Manuel Rubio&lt;/a&gt; y yo platicamos extensamente sobre ese tema:&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/Gswx3ko3A_E&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;Finalmente, te recomiendo mucho el artículo en el que Manuel Rubio hizo su propio resumen en &lt;a href=&quot;https://altenwald.org/2021/09/27/claridad/&quot;&gt;el blog de Altenwald&lt;/a&gt;.&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="claridad" /><category term="código-claro" /><category term="pláticas" /><summary type="html">Todos quisiéramos tener bases de código perfectas, fáciles de mantener y totalmente claras. Esto es casi imposible, pero podemos acercarnos. Vemos cómo.</summary></entry><entry><title type="html">Explicaciones elocuentes</title><link href="https://blog.thedojo.mx/2022/12/26/explicaciones-elocuentes.html" rel="alternate" type="text/html" title="Explicaciones elocuentes" /><published>2022-12-26T00:00:00-06:00</published><updated>2022-12-26T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2022/12/26/explicaciones-elocuentes</id><content type="html" xml:base="https://blog.thedojo.mx/2022/12/26/explicaciones-elocuentes.html">&lt;p&gt;Aunque el principal trabajo de un desarrollador es comunicar sus pensamientos a la computadora a través de instrucciones precisas (el código), ningún trabajo serio o que valga la pena se puede hacer solo. Casi siempre formamos parte de un equipo, puede ser con otros roles o con más desarrolladores. Para trabajar efectivamente, hay que comunicarse lo mejor posible. &lt;a href=&quot;https://blog.thedojo.mx/2021/07/14/desarrolladores-de-los-que-puedes-aprender-russ-olsen.html&quot;&gt;Russ Olsen&lt;/a&gt; tiene una plática llamada &lt;a href=&quot;https://www.youtube.com/watch?v=80EE4mZmp3A&quot;&gt;Eloquent Explanations&lt;/a&gt; en la que nos da consejos sobre cómo comunicarnos claramente, además de que da razones por las que es importante hacerlo.&lt;/p&gt;

&lt;p&gt;En este artículo resumiremos esta charla con algunas adaptaciones y extensiones.&lt;/p&gt;

&lt;h2 id=&quot;la-comunicación-transmisión-conocimiento&quot;&gt;La comunicación: transmisión conocimiento&lt;/h2&gt;

&lt;p&gt;Lo que nos limita para construir software es conocimiento. Conocimiento sobre el dominio, el negocio o el sistema que estamos construyendo. Por lo tanto, compartir el conocimiento es una de las mejores formas de ayudar al equipo a avanzar. La principal forma de compartirlo es con explicaciones (por eso la charla se llama así). Russ comparte cinco consejos para mejorar nuestras explicaciones, de las que hablaremos ahora.&lt;/p&gt;

&lt;h2 id=&quot;1-traza-un-plan-para-explicar&quot;&gt;1: traza un plan para explicar&lt;/h2&gt;

&lt;p&gt;Debemos tener un &lt;strong&gt;plan&lt;/strong&gt; o &lt;strong&gt;estructura&lt;/strong&gt; para compartir el conocimiento. Russ propone algunas estructuras, como &lt;em&gt;“Zomm In”&lt;/em&gt;, &lt;em&gt;“Zoom Out”&lt;/em&gt; y &lt;em&gt;“simple to complex”&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;zoom-in-y-zoom-out&quot;&gt;Zoom In y Zoom Out&lt;/h3&gt;

&lt;p&gt;Empieza en el contexto más amplio (o lo que llamaríamos de más alto nivel, pegado al negocio) y termina en los detalles. Por ejemplo:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Queremos vender zapatos&lt;/li&gt;
  &lt;li&gt;Por eso estamos construyendo un eCommerce&lt;/li&gt;
  &lt;li&gt;Por eso necesitamos este botón de “Pagar”&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Zoom Out es lo mismo, pero en sentido contrario, empiezas en los detalles y terminas en el contexto más amplio. Es importante no empezar por en medio y avanzar para un lado y luego para el otro, ya que esto no sigue un orden lógico que permita a tus oyentes seguir el hilo de la explicación.&lt;/p&gt;

&lt;h3 id=&quot;de-lo-simple-a-lo-complejo&quot;&gt;De lo simple a lo complejo&lt;/h3&gt;

&lt;p&gt;Empieza explicando lo más básico, sin saltarte nada. Este método puede implicar ocultar información intencionalmente o explicarla en &lt;strong&gt;términos inexactos&lt;/strong&gt;, que cuando llegue el momento se tendrán que aclarar y expandir. Quiero recalcar este punto: &lt;strong&gt;a veces es importante, casi imprescindible&lt;/strong&gt; dar información inexacta con tal de que la explicación no sea demasiado compleja al principio.&lt;/p&gt;

&lt;p&gt;Por ejemplo, cuando explicamos las variables a personas que están entrando en la programación les decimos que son como “cajitas” que guardan valores, una explicación por demás inexacta, pero que no vale la pena corregir porque si no  tendríamos que explicar todo el modelo de organización de memoria de los lenguajes y los entornos de ejecución.&lt;/p&gt;

&lt;h2 id=&quot;2-se-ágil-explica-mide-ajuste-y-repite&quot;&gt;2: Se ágil: explica, mide ajuste y repite&lt;/h2&gt;

&lt;p&gt;Para mejorar tus explicaciones, las debes tratar como el desarrollo de software: explica, mide, ajusta y repite. Busca señales sobre si tu explicación está funcionando: las preguntas van cambiando, &lt;em&gt;no te miran raro&lt;/em&gt; y no hay un silencio mortal. Estas señales que todos hemos vivido en algún punto de nuestra vida son la medida precisa de si tu explicación está funcionando. Si ves que algo no funciona porque no produce preguntas o hace que todos se queden callados, busca otra forma de explicarlo.&lt;/p&gt;

&lt;p&gt;También, las explicaciones y analogías que ves que tienen éxito las puedes ir guardando y puliendo.&lt;/p&gt;

&lt;h3 id=&quot;25-la-maldición-del-conocimiento&quot;&gt;2.5: la maldición del conocimiento&lt;/h3&gt;

&lt;p&gt;Cuando explicamos algo que conocemos muy bien, puede que nos saltemos información que no tenemos presente que necesitamos sabes, justo por el dominio que tenemos del problema. Tenemos que ser cuidadosos en esto e intentar dar la mayor cantidad de información posible, sobre todo si nuestra audiencia es nueva en el tema.&lt;/p&gt;

&lt;p&gt;A veces parece que lo que estamos diciendo es obvio, pero aquí &lt;strong&gt;Russ Olsen&lt;/strong&gt; menciona una frase muy interesante: &lt;strong&gt;“nadie en esta sala nació con ese conocimiento codificado en su ADN”&lt;/strong&gt;, esto nos debe recordar que a nosotros también nos tienen que explicar cosas que para otros parecen obvias.&lt;/p&gt;

&lt;h2 id=&quot;3-explicar-es-un-deporte-con-límite-de-tiempo&quot;&gt;3: Explicar es un deporte con límite de tiempo&lt;/h2&gt;

&lt;p&gt;Imagínate que cuando estamos explicando algo estamos en un partido de algún deporte que tiene límite de tiempo estricto. Como tenemos un tiempo muy limitado para explicar lo que queremos antes de perder la atención de la persona, por lo que tenemos que seguir dos estrategias:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;comprimir la información&lt;/li&gt;
  &lt;li&gt;decir primero lo más importante.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Con eso ahorrarás tiempo en la explicación, y si pierdes la atención de la persona, al menos habrás dicho lo más importante.&lt;/p&gt;

&lt;p&gt;La &lt;strong&gt;terminología&lt;/strong&gt; (palabras especiales de un área del conocimiento) es un obstáculo para los que están empezando, y sólo quitará tiempo y poder a tu explicación, aburriendo o comunicando muy poco en un espacio grande de tiempo. &lt;strong&gt;Evítala si tu auditorio no está familiarizado con esta MUY familiarizado con ella.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Hay una buena noticia: puedes re-iniciar el reloj y comprarte más tiempo si logras que las personas a las que les estás explicando tengan pequeñas victorias, entendiendo progresivamente el tema en cuestión. Al mantenerlas ilusionadas con el tema, puedes seguir manteniendo su atención.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/c_scale,w_800/v1672066869/russ_oo_rjxxdl.jpg&quot; alt=&quot;Captura de cuadro de video mostrando un reloj con 0 segundos restantes.&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-repite-para-énfasis-y-para-dar-contexto&quot;&gt;4: Repite para énfasis y para dar contexto&lt;/h2&gt;

&lt;p&gt;El &lt;strong&gt;“Don’t repeat yourself”&lt;/strong&gt; (No te repitas a ti mismo) es para las máquinas, los humanos sí que necesitamos repetición.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/c_scale,w_800/v1672066971/E5_hHP9WEAENUF2_homosz.jpg&quot; alt=&quot;Captura de cuadro de video mostrando que no somos máquinas&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Las personas prosperan [o crecen] en la redundancia.” - Russ Olsen&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Podemos repetir algo para:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Dar énfasis. Si quieres resaltar algo, una de las mejores maneras es repetirlo.&lt;/li&gt;
  &lt;li&gt;Para dar contexto. Puedes repetir algo para recordar a las personas sobre algo que ya se mencionó para darle más conexto a algo que estás a punto de decir.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5-muéstrate-humano&quot;&gt;5: Muéstrate humano&lt;/h2&gt;

&lt;p&gt;Las explicaciones que causan una reacción emocional en los que escuchan, como las que incluyen humor, las que demuestran sentimientos o conectan en un nivel más humano con las personas &lt;strong&gt;son las que dejan las cosas grabadas&lt;/strong&gt;. Una broma puede a hacer que alguien recuerde lo que explciaste por décadas.&lt;/p&gt;

&lt;p&gt;Hazles saber por qué importa lo que estás diciendo, muestra el interés o el amor que tienes por el tema.&lt;/p&gt;

&lt;p&gt;Esto nos deja una conclusión muy importante. &lt;strong&gt;Si no te interesa lo que estás explicando, a las personas que te escuchan tampoco tiene por qué interesarles.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusión&quot;&gt;Conclusión&lt;/h2&gt;

&lt;p&gt;Saber explicarnos es esencial para realizar un buen trabajo de equipo, y todos los trabajos serios, grandes y que valen la pena requieren de un equipos si los queremos lograr en un tiempo razonable. Nadie nace sabiéndose explicar, es por eso que debemos trabajar en esto y mejorar con la práctica. &lt;strong&gt;Una buena explicación puede cambiar tu compañía, tu equipo o incluso el mundo.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Te repito que puedes ver la plática aquí: &lt;a href=&quot;https://www.youtube.com/watch?v=80EE4mZmp3A&quot;&gt;Eloquent Explanations&lt;/a&gt;, de nuevo gracias a &lt;a href=&quot;&quot;&gt;@russolsen&lt;/a&gt; por sus contribuciones a la comunidad y por pláticas tan buenas.&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><summary type="html">Comunicar claramente y de manera efectiva es una de las tareas más importantes de los desarrolladores. Hablemos de las técnicas que puedes seguir para mejorar en este aspecto.</summary></entry></feed>