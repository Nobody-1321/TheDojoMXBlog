<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://blog.thedojo.mx/feed.xml" rel="self" type="application/atom+xml" /><link href="https://blog.thedojo.mx/" rel="alternate" type="text/html" /><updated>2025-01-01T14:47:54-06:00</updated><id>https://blog.thedojo.mx/feed.xml</id><title type="html">The Dojo MX Blog</title><author><name>Héctor Patricio</name><uri>https://github.com/hectorip</uri></author><entry><title type="html">Un concepto importante: los buffers</title><link href="https://blog.thedojo.mx/2024/12/30/un-concepto-importante-los-buffers.html" rel="alternate" type="text/html" title="Un concepto importante: los buffers" /><published>2024-12-30T00:00:00-06:00</published><updated>2024-12-30T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2024/12/30/un-concepto-importante-los-buffers</id><content type="html" xml:base="https://blog.thedojo.mx/2024/12/30/un-concepto-importante-los-buffers.html"><![CDATA[<p>El concepto de buffer es usado por todos lados en el desarrollo de software, pero siento
que es un concepto poco entendido. En este artículo vamos a hablar de qué son los buffers,
para qué se usan y cómo pueden ayudarte a resolver problemas y diseñar mejor software.</p>

<h2 id="qué-es-un-buffer">¿Qué es un buffer?</h2>

<p>Primero hablemos de dónde viene la idea de los buffers. Un buffer es un concepto importante en
teoría de sistemas. Los buffers se utilizan para almacenar temporalmente datos, asegurando que
eventualmente lleguen a su destino final. Esto ocurre a una velocidad o ritmo diferente al
que fueron generados originalmente.</p>

<p>Traducir la palabra <em>“buffer”</em> es difícil, porque no hay un concepto en español que abarque
todos los usos que se le dan en el desarrollo de software.Algunos ejemplos de uso de buffers en el desarrollo de software son:</p>

<ul>
  <li>Amortiguador</li>
  <li>Almacén temporal</li>
  <li>Memoria intermedia</li>
  <li>Regulador</li>
</ul>

<p>Esta última palabra te puede empezar a sonar, ya que en el desarrollo de software usamos
los buffers para <em>regular</em> el flujo de datos entre diferentes sistemas o componentes.
Los buffers causan retrasos intencionales en el flujo de datos.</p>

<p>Empecemos a hablar de cómo se usan en el desarrollo de software.</p>

<h2 id="buffers-en-acción">Buffers en acción</h2>

<p>Estos son algunos ejemplos de este concepto que seguro conoces o has visto aplicados en
software. Recuerda que lo que estamos buscando entender es el concepto, por lo que vamos a
explicar cómo el ejemplo es un buffer, pero no vamos a entrar en detalles de la implementación.</p>

<h3 id="escritura-en-archivos">Escritura en archivos</h3>

<p>Cuando escribimos en un archivo, los sistemas operativos usan buffers para guardar los datos
en memoria antes de escribirlos en su destino final, ya que si escribiera directamente en el disco
byte por byte, sería muy lento. Además, escribir directamente en el disco por cada byte que un
programa mande a escribir causaría problemas de estabilidad y rendimiento. Aquí no tenemos que
explicar mucho por qué un buffer, ya que es el ejemplo más común. Incluso en varios lenguajes
de programación los objetos que se usan para escribir en los archivos tienen “Buffer” o “Buffered”
en su nombre.</p>

<h3 id="uso-de-servicios-remotos">Uso de servicios remotos</h3>

<p>Usar un servicio o una función a través de la red (un servicio remoto) es costoso en tiempo
y recursos en comparación con cualquier cálculo local que se haga. Por eso es buena idea
usar buffers para guardar información antes de hacer una llamada a un servicio remoto.
Por ejemplo, en desarrollo web, cuando se hace un auto-completado o búsqueda mientras se sigue
escribiendo, el programa espera a que el campo tenga un número de caracteres para hacer
una llamada al servicio de búsqueda que pueda tener sentido.</p>

<h3 id="caching">Caching</h3>

<p>Este ejemplo no podía faltar. El caché es un tipo de buffer que guarda información <em>temporalmente</em>
con varios objetivos:</p>

<ol>
  <li>Ahorrar cómputo</li>
  <li>Acelerar el acceso a la información</li>
  <li>Evitar la sobrecarga de los recursos</li>
</ol>

<p>Como sabemos, lo más difícil del cachee es decidir primero qué guardar y luego cómo
refrescarlo para que se no sea obsoleto.</p>

<h3 id="buffering-de-contenido-multimedia">Buffering de contenido multimedia</h3>

<p>Debido a que el contenido multimedia es muy pesado, un buen reproductor o sistema de streaming
casi siempre incluye un buffer que va descargando el contenido a mayo velocidad y un poco
adelantado para tener un reproducción fluida. Si no lo incluimos, estamos a merced de la velocidad
y las intermitencias de la red.</p>

<h2 id="cómo-pueden-ayudarte-a-diseñar-mejor-software">¿Cómo pueden ayudarte a diseñar mejor software?</h2>

<p>Escribir software usando buffers es más complejo que hacerlo sin ellos, ya que son una pieza más
que puede causar problemas y que en algún momento vas a tener que depurar. Pero los buffers complican
el código y las pruebas de software, son indispensables para el buen rendimiento y la estabilidad de los
sistemas. Incluso algunos lenguajes de programación como Java, tienen buffers incorporados en su
librería estándar.</p>

<p>Recuerda, usar buffers te va a ayudar a escribir software:</p>

<ul>
  <li>Más estable</li>
  <li>Con mejor rendimiento</li>
  <li>Más resiliente</li>
  <li>Más eficiente</li>
</ul>

<p>Así que te conviene buscar oportunidades para usarlos lo mejor posible.</p>

<h2 id="conclusión">Conclusión</h2>

<p>Los buffers son interesantes. Son una herramienta poderosa que puedes usar para resolver
problemas con mejor calidad y que te permiten crear características arquitectónicas
deseables, a costa de hacer el código un poco más complejo. Sin embargo, si los ocultas
correctamente detrás de interfaces efectivas, los documentas bien y los pruebas,
te ayudarán mucho.</p>]]></content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="software-development" /><category term="programming" /><category term="técnicas-de-programación" /><category term="buffer" /><summary type="html"><![CDATA[Los buffers son una herramienta poderosa que puedes usar para resolver problemas. Hablemos de algunos ejemplos y cómo te pueden ayudar a diseñar mejor software.]]></summary></entry><entry><title type="html">¿Qué son los requerimientos funcionales?</title><link href="https://blog.thedojo.mx/2024/11/23/que-son-los-requerimientos-funcionales.html" rel="alternate" type="text/html" title="¿Qué son los requerimientos funcionales?" /><published>2024-11-23T00:00:00-06:00</published><updated>2024-11-23T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2024/11/23/que-son-los-requerimientos-funcionales</id><content type="html" xml:base="https://blog.thedojo.mx/2024/11/23/que-son-los-requerimientos-funcionales.html"><![CDATA[<p><strong>“Requerimientos funcionales”</strong> es una expresión muy rebuscada para un concepto
muy sencillo relacionado con el diseño de los sistemas de software: <strong>las
cosas que tu sistema HACE</strong>.</p>

<p>En este artículo hablaremos de formas de encontrarlos, definirlos, documentarlos
y tenerlos listos para la siguiente etapa del desarrollo de software.</p>

<h2 id="cómo-definir-las-funciones-de-un-sistemas">Cómo definir las funciones de un sistemas</h2>

<p>La primera tarea como arquitecto de software tiene que ver con la de
<strong>entender completamente</strong> lo que el software tiene que HACER. El software
normalmente tiene unas pocas funciones principales, pero muchas tareas
secundarias o terciarias que las soportan, y es por eso que descubrirlas
y describirlas todas no es una tarea sencilla.</p>

<h2 id="cómo-encontrarlos">Cómo encontrarlos</h2>

<p>La forma más eficiente de encontrar los requerimientos funcionales o funciones
que debe tener tu sistema es viviendo el proceso o problema que tu sistema va a
resolver. Es por esto que algunos de los mejores sistemas son creados por gente
que “se rasca su propia comezón” (<em>“scratch their own itch”</em>). Es decir, que
resuelven un problema que ellos mismos viven o han vivido, y que por eso
mismo <strong>entienden a fondo</strong>.</p>

<p>Una de las ventajas de atender un problema que tú vives, es que tienes
retroalimentación inmediata sobre si el sistema resuelve el problema o no.</p>

<p>Pero esto no siempre es posible, sobre todo cuando construyes software como
profesión, porque no siempre puedes dedicar tiempo y recursos suficientes para
tú realizar la operación de lo que quieres resolver, o simplemente no es práctico.
Así que la segunda mejor opción que tenemos es <strong>platicar con los usuarios</strong>.</p>

<p>Aquí es donde entran un montón de habilidades “blandas”. Un mejor nombre para estas
habilidades es <em>“habilidades personales e interpersonales”</em>. O habilidades básicas
humanas. Así que, a menos que tengas a alguien en tu equipo que lo haga por ti,
(y que siempre vaya a estar contigo), te conviene desarrollarlas.</p>

<h2 id="cómo-documentarlos">Cómo documentarlos</h2>

<p>No existe una forma aceptada por todos para documentar nada en el software,
dependiendo de la cultura del equipo y de la empresa en general. Veamos algunas
de las formas más comunes. Cabe mencionar que estas formas no son excluyentes,
se pueden combinar para ver diferentes aspectos de una misma función.</p>

<h3 id="historias-de-usuario">Historias de Usuario</h3>

<p>En este estilo de documentación, describes las funciones del sistema desde la
perspectiva del usuario. Se lleva muy bien con procesos modernos de desarrollo de
productos digitales, relacionados con el desarrollo ágil de software.</p>

<p>Tienen el siguiente formato:</p>

<ul>
  <li>Como [rol de usuario]</li>
  <li>Quiero [acción/función]</li>
  <li>Para [beneficio/valor]</li>
</ul>

<p>Como puedes ver, antes de empezar a crear historias de usuario, debes por lo menos
tener un idea de las personas que van a usar el sistema y lo roles que desempeñan.
Después, describes la función que va a realizar, desde su punto de vista, pero
también intentando mostrar cómo funcionará internamente el sistema para cumplir
con esa función.</p>

<p>Y finalmente, la razón de existencia de esta función: cómo es que beneficia al usuario
o la empresa que crea el software. Esta última parte es muy importante, ya que nos
hace pensar en si realmente es necesario tener esta función o no.</p>

<h3 id="casos-de-uso">Casos de Uso</h3>

<p>Este tipo de documentación viene de la época en la que se prefería el desarrollo en cascada,
pero a mi me sigue pareciendo muy útil. Es más formal y detallada, incluye:</p>

<ul>
  <li>Actores (usuarios o sistemas externos) involucrados</li>
  <li>Flujo principal: el caso en el que todo sale bien</li>
  <li>Flujos alternativos: los casos en los que algo sale mal o se manejan de otra manera</li>
  <li>Precondiciones y postcondiciones: cómo está el sistema antes y después de la ejecución</li>
</ul>

<p>En muchos sistemas de documentación, los casos de uso requieren un identificador para
referirse a ellos en etapas posteriores, como cuando se hacen pruebas o se crean
tareas específicas para el equipo de desarrollo.</p>

<p>Los recomiendo mucho en el caso de sistemas o funciones críticas, en donde es
necesario pensar más a profundidad antes de empezar a desarrollar.
Puedes encontrar un ejemplo y una plantilla aquí:
<a href="https://lsi2.ugr.es/~mvega/docis/casos%20de%20uso.pdf">Casos de uso</a>.</p>

<h2 id="cómo-mantenerlos-actualizados">Cómo mantenerlos actualizados</h2>

<p>El software es dinámico, y no basta con definir o documentar cómo funciona una
sola vez, tenemos que mantener actualizadas las funciones documentadas del
sistema o agregar nuevas conforme vayan apareciendo.</p>

<p>Aquí tienes algunas sugerencias para mantener actualizados los requerimientos:</p>

<h3 id="revisar-y-actualizar">Revisar y actualizar</h3>

<p>Si tienes suficiente personal, siempre debería haber un owner de la documentación
y esta persona debería revisar y asegurarse que los diferentes miembros del equipo
mantengan actualizadas las funciones documentadas y documenten las nuevas.</p>

<h3 id="control-de-versiones">Control de versiones</h3>

<p>Es buena idea mantener los documentos de requerimientos bajo control de versiones,
igual que el código. De hecho, una de las mejores formas de hacer documentación es
tratarla exactamente como código, como se sugiere en <a href="https://www.writethedocs.org/guide/docs-as-code/">Docs as Code</a>.</p>

<p>Cada cambio debería ir acompañado de:</p>

<ul>
  <li>Fecha del cambio</li>
  <li>Razón del cambio</li>
  <li>Persona responsable</li>
  <li>Impacto en el sistema</li>
</ul>

<h3 id="trazabilidad">Trazabilidad</h3>

<p>Puedes mantener una matriz de trazabilidad que conecte los requerimientos con:</p>

<ul>
  <li>El código que los implementa</li>
  <li>Las pruebas que los verifican</li>
  <li>Otra documentación relacionada</li>
</ul>

<p>Para que esta matriz sea útil, se debe de incluir su actualización en el proceso
de desarrollo y considerarse dentro de la definición de “terminado” de una tarea (<em>definition of done</em>).
Esto es buena idea sólo si tienes un equipo grande y un proyecto complejo, ya que requiere
bastante trabajo en sí mismo.</p>

<h3 id="comunicación-efectiva">Comunicación efectiva</h3>

<p>Esto es esencial para todos los procesos de desarrollo de software, pero debes asegurarte
que mientras más avance tu proyecto y más gente se involucre, más se haga:</p>

<ul>
  <li>Que todos los cambios en los requerimientos sean comunicados a equipo de desarrollo y puestos en un documento que los describa</li>
  <li>Que las personas involucradas en el proyecto sepan de los cambios y sientan que su voz es escuchada, también registrando sus comentarios y sugerencias</li>
</ul>

<p>Es importante dejar la registro de la comunicación y las decisiones tomadas para que el
conocimiento del software sea accesible para todos.</p>

<h3 id="una-alternativa-design-documents">Una alternativa: Design Documents</h3>

<p>Los Design Documents son documentos que se usan en algunas big techs para documentar cómo se
va implementar una función. Como es natural, estos documentos son bastante técnicos y
algo tardados, pero incluyen por lo menos una descripción de la función que se quiere
implementar y <em>cómo se va a implementar</em>.</p>

<p>Están pensados para obtener consenso sobre la forma en la que se va a hacer algo y
son una buena idea si tienes un equipo de desarrollo maduro que puede llegar rápido
a compromisos para lograr implementar algo.</p>

<p>Un conjunto histórico de estos documentos, puede ser una buena alternativa para
documentar los requerimientos funcionales de un sistema.</p>

<h2 id="conclusión">Conclusión</h2>

<p>Entender lo que necesitamos que haga nuestro software es el primer paso para crear
software útil. Los requisitos funcionales o funciones y su documentación son una herramienta
para mantener un registro histórico y asegurarnos de que entendemos lo que se requiere.
Esto también puede servir para obtener aprobación de las personas interesadas en que
el software se realice y evitar malentendidos en el futuro.</p>

<p>También facilitan la estimación de recursos y tiempos, y permiten un desarrollo más eficiente
y enfocado. Finalmente, mejoran la comunicación entre todas las partes involucradas.</p>

<p>Es importante dedicar el tiempo y esfuerzo necesarios para documentarlos adecuadamente
(en mi opinión más como una herramienta de entendimiento que como una obligación) y mantenerlos
actualizados durante la vida del proyecto. Un sistema bien diseñado comienza con funciones
bien definidas, entendidas y gestionadas.</p>]]></content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="arquitectura" /><summary type="html"><![CDATA[El análisis de requerimientos es una parte fundamental del desarrollo de software y es importantísima para crear sistemas exitosos.]]></summary></entry><entry><title type="html">¿Qué es la programación asíncrona?</title><link href="https://blog.thedojo.mx/2024/10/31/que-es-la-programacion-asincrona.html" rel="alternate" type="text/html" title="¿Qué es la programación asíncrona?" /><published>2024-10-31T00:00:00-06:00</published><updated>2024-10-31T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2024/10/31/que-es-la-programacion-asincrona</id><content type="html" xml:base="https://blog.thedojo.mx/2024/10/31/que-es-la-programacion-asincrona.html"><![CDATA[<p>La programación asíncrona es uno de los primeros temas avanzados que encontrarás
al programar, especialmente si desarrollas aplicaciones web. Esto es aún más
común si haces <strong>JavaScript</strong>, que es un lenguaje que se usa en entornos de
ejecución asíncronos.</p>

<p>En este artículo la explicaremos para que puedas programar de manera asíncrona
con seguridad.</p>

<h2 id="por-qué-existe---el-caso-de-la-programación-asíncrona">¿Por qué existe? - El caso de la programación asíncrona</h2>

<p>Imagínate un proceso de la vida real en el que tengas una conjunto de recursos
limitados, que sean completamente necesarios para terminar el trabajo. Por ejemplo,
imagina que quieres hacer una comida especial, en la que necesitas usar un horno.
En el horno puedes poner un platillo a la vez, ya que requiere un tiempo y temperatura
específica. Pero este platillo especial tal vez va acompañado de una sopa que puedes
hacer mientras el platillo principal está en el horno.</p>

<p>En términos computacionales, estas dos tareas están sucediendo de manera concurrente,
aunque tú literalmente no estés haciendo ambas cosas al mismo tiempo. No vale la pena que
te sientes a esperar a que el lomo del horno esté listo para empezar a hacer la sopa.
Puedes hacer la sopa mientras esperas, ya que no ocupan los mismos recursos.</p>

<p>Exactamente pasa lo mismo en los programas de computadora, se tienen que ejecutar tareas
que usan recursos compartidos o lentos, como por ejemplo el sistema de archivos o la red.
En la programación web también se da que el programa está esperando la respuesta de el
usuario y mientras tanto puede seguir haciendo otras cosas. Aquí es donde entra la programación
asíncrona.</p>

<h2 id="qué-es-la-programación-asíncrona">¿Qué es la programación asíncrona?</h2>

<p>Para entenderla primero tenemos que entender la programación tradicional o
síncrona (creo que la palabra correcta en español es <em>sincrónica</em>).</p>

<p>En la programación tradicional, las cosas siempre suceden en un orden estricto:
una instrucción empieza y hasta que no se termina, no se ejecuta la siguiente.
Observa el siguiente código, en Python, para a abrir un arhivo:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="sh">"</span><span class="s">archivo.txt</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">r</span><span class="sh">"</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">file</span><span class="p">.</span><span class="nf">read</span><span class="p">()</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Archivo leído</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Log final</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>El resultado de este código es:</p>

<pre><code class="language-log">Archivo leído
Log final
</code></pre>

<p>En este código todo sucede de manera perfectamente secuencial.</p>

<p>Pero en lenguajes con programación asíncrona, esta operación que es tardada
en términos computacionales se puede hacer de manera asíncrona, es decir
fuera de orden.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">fs</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">fs</span><span class="p">.</span><span class="nf">readFile</span><span class="p">(</span><span class="dl">"</span><span class="s2">archivo.txt</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">utf8</span><span class="dl">"</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Archivo leído</span><span class="dl">"</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Esperando a que se lea el archivo</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<p>El resultado de este código es:</p>

<pre><code class="language-log">Esperando a que se lea el archivo
Archivo leído
</code></pre>

<p>Observa cómo en esta versión, el código que está ANTES: <code class="language-plaintext highlighter-rouge">console.log("Archivo leído")</code>,
se ejecuta DESPUÉS. Esto es una demostración de código asíncrono.</p>

<p>La explicación a esto está en que con la programación asíncrona podemos modificar
<strong>cuándo se ejecutan las cosas</strong>. Pero otra visión es que se pueden ejecutar cosas
en diferentes “lados” o “momentos” y tú elegir <strong>cuándo</strong> usas los resultados de
la ejecución.</p>

<p>Usamos este ejemplo de abrir un archivo porque por su naturaleza es lento (comparado)
con cálculos u operaciones comunes.</p>

<p>La <strong>programación asíncrona</strong> es un forma de ejecutar las acciones de tu programa en
la que no se espera siempre que una acción o instrucción termine para continuar
con el programa.</p>

<p>Como vimos en el primer ejemplo, en la programación síncrona (también llamada
<em>bloqueante</em> [blocking]), ninguna acción comienza hasta que le previa haya terminado.
En la programación asíncrona, con técnicas o palabras reservadas específicas le
indicamos al motor de ejecución que no es necesario a que una acción termine para
continuar con la siguiente, pero también le podemos decir qué hacer cuando la
acción termine. Por esto mismo, la programación asíncrona también se conoce como
<em>no bloqueante</em> (non-blocking).</p>

<h2 id="para-qué-sirve-la-programación-asíncrona">Para qué sirve la programación asíncrona</h2>

<p>Veamos las restricciones que tenemos, para entender por qué es útil. Cuando
creas un sistema, la velocidad de ejecución puede verse limitada por dos
categorías de cosas:</p>

<ul>
  <li>De los cálculos que estás haciendo</li>
  <li>De la información que estás obteniendo o guardando en algún lugar</li>
</ul>

<p>En el primer caso, llamamos a la ejecución <strong>CPU bound</strong> y en el segundo <strong>I/O bound</strong>.
En español me gusta llamarle <strong>limitado por el procesador</strong> y <strong>limitado por la entrada
y salida de datos</strong>.</p>

<h3 id="cpu-bound---limitado-por-la-cantidad-de-cálculos-que-puedes-hacer">CPU bound - limitado por la cantidad de cálculos que puedes hacer</h3>

<p>Cuando tu programa es pesado en los cálculos que tiene que hacer, como cuando
tienes que procesar multimedia, hacer multiplicación de matrices o cosas
similares, puedes decir que tu programa es <strong>CPU bound</strong>, o que está limitado por
el poder de procesamiento. Es decir, mientras más poderoso sea el procesador,
más rápido será tu programa. Esto también es cierto si tienes múltiples
procesadores <em>y puedes distribuir el cómputo entre ellos</em>, por ejemplo:</p>

<ul>
  <li>Si tienes un procesador con múltiples cores o múltiples hilos de ejecución físicos</li>
  <li>Si tienes múltiples computadoras en una red</li>
</ul>

<p>En el primer caso, necesitas una plataforma que te ayude a utilizar el poder
de procesamiento de los múltiples cores, sea implícitamente o explícitamente. Por
ejemplo plataformas como la <strong>máquina virtual de Erlang</strong> (llamada BEAM), automáticamente distribuyen
la carga en los múltiples cores disponibles. En otros lenguajes como en Python,
tienes que hacerlo explícitamente, pero incluso eso tiene limitaciones. Pero
esto que te estoy diciendo es <strong>programación concurrente</strong>.</p>

<p>La programación asíncrona se puede ver como una herramienta para manejar la
programación concurrente y hacerla más sencilla. Piénsala como en una capa de
abstracción sobre la programación concurrente, que te permite <strong>expresar de forma
explícita</strong> que otras partes del programa <em>pueden</em> estarse ejecutando en otro
tiempo o en otro <em>espacio</em> (proceso o hilo).</p>

<h3 id="io-bound---limitado-por-la-velocidad-de-entrada-y-salida-de-datos">I/O bound - limitado por la velocidad de entrada y salida de datos</h3>

<p>Cuando un programa consume o produce mucha información tiene que
ponerla en algún lugar. Este lugar puede ser:</p>

<ul>
  <li>La memoria RAM</li>
  <li>El disco duro (o sistema de archivos)</li>
  <li>La red (mandarla o pedirla a otra computadora)</li>
</ul>

<p>Cuando tu programa hace mucho esto, se dice que el programa está limitado por la
velocidad de entrada y salida de datos, o <strong>I/O bound</strong>.</p>

<p>La programación asíncrona te puede ayudar de manera más sencilla, sobre todo en
el caso de las peticiones de red. ¿Cómo? Justo en el ejemplo que vimos antes de abrir
un archivo: mientras esperas a que el disco duro lea el archivo y lo mande por el bus
de datos y se cargue en la memoria RAM (que son AÑOS computacionalmente hablando),
podemos seguir haciendo otras cosas. Igual que en el caso anterior, estos procesos
son concurrentes, y una de las maneras más sencillas de expresarlo es con la programación
asíncrona, en el que simplemente decimos que en algún momento <em>podemos</em> usar el resultado
de la lectura del archivo.</p>

<p>Exactamente pasa lo mismo en el caso de las peticiones de red (que son EONES comparadas con
la lectura de archivos o cálculos comunes). De hecho, el manejo de esas peticiones y de
todo lo relacionado con entrada y salida de datos es uno de los secretos de por qué
Node.js es tan bueno para manejar peticiones HTTP.</p>

<h2 id="conclusión">Conclusión</h2>

<p>Entender la programación asíncrona es esencial en la programación moderna, muchos
lenguajes y sobre todo <em>entornos de ejecución</em> lo implementan. Entenderla y usarla
te ayudará a crear programas más eficientes y que cumplan con el rendimiento que
tus usuario esperan. En un artículo futuro veremos una comparación entre programación
asíncrona y programación concurrente manejada de otras maneras.</p>]]></content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="async/await" /><category term="concurrencia" /><category term="javascript" /><summary type="html"><![CDATA[Entender la programación asíncrona es un requisito si eres un desarrollador de software que quiere sacar el mejor rendimiento de una computadora, hablemos de qué es y cómo dominarla.]]></summary></entry><entry><title type="html">¿Qué es la búsqueda binaria?</title><link href="https://blog.thedojo.mx/2024/10/26/que-es-la-busqueda-binaria.html" rel="alternate" type="text/html" title="¿Qué es la búsqueda binaria?" /><published>2024-10-26T00:00:00-06:00</published><updated>2024-10-26T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2024/10/26/que-es-la-busqueda-binaria</id><content type="html" xml:base="https://blog.thedojo.mx/2024/10/26/que-es-la-busqueda-binaria.html"><![CDATA[<p>Uno de los algoritmos más fáciles de entender, que incluso sin preparación
aplicamos en la vida real y que se enseña en las primeras clases de programación
es la <strong>búsqueda binaria</strong>. Vamos a hablar de este algoritmo y su relación
profunda con las ciencias de la computación y la información en general.</p>

<h2 id="búsqueda-binaria-en-la-vida-real">Búsqueda binaria en la vida real</h2>

<p>¿Alguna ves has jugado “Adivina Quién”? Es un juego de mesa en el
que cada jugador tiene un tablero con un conjunto de personajes con
características físicas distintas, como el color de pelo, diferentes
accesorios, y otros rasgos distintivos. Cada jugador escoge secretamente
un personaje y el otro lo tiene que adivinar, haciendo preguntas que
le permitan ir eliminando a los personajes que el otro jugador no ha elegido.
¿Cuál es la mejor estrategia para adivinar con la menor cantidad de
preguntas? Podrías pensar que es por cosas muy distintivas, por ejemplo,
si hay dos personajes con sombrero, y preguntas si tiene sombrero, puede
parecer una buena estrategia, pero no lo es.</p>

<p>En este caso, suponiendo que tenemos 40 personajes y solo dos tienen sombrero y
suponiendo que tienes 40 personajes, sólo 5% de las veces te ayudará reducir
significativamente el número de personajes, por lo que la mayoría de las veces
será una pregunta extra si la haces inicialmente. Lo mejor es empezar por las
características que dividan el conjunto de personajes en dos grupos más o menos
iguales. Por ejemplo, si hay 40 personajes y 20 tienen el pelo largo y 20 el corto,
la pregunta si el personaje tiene el pelo largo, te dejará con 20 personajes.
La siguiente pregunta debería ser algo similar.</p>

<p>Esto es exactamente lo que hace la búsqueda binaria, ir partiendo el conjunto
de elementos en dos grupos más o menos iguales e ir eliminando la mitad en cada
paso.</p>

<h2 id="búsqueda-binaria-en-la-computación">Búsqueda binaria en la computación</h2>

<p>El algoritmo de búsqueda binaria se aplica para encontrar un valor en una
colección <em>ordenada</em> de elementos. Esto es para tener una forma sencilla de
eliminar la mitad del espacio de búsqueda en cada paso. Y puedes pensar justamente
que la necesidad de tener que ordenar los elementos es precisamente una de sus
des</p>

<h2 id="implementación-en-pseudocódigo">Implementación en pseudocódigo</h2>

<p>Aquí puedes ver una implementación de la búsqueda binaria en pseudocódigo:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>búsqueda_binaria(arreglo, elemento_buscado):
    inicio = 0
    fin = longitud(arreglo) - 1
    mientras inicio &lt;= fin:
        medio = (inicio + fin) // 2  # división entera

        si arreglo[medio] == elemento_buscado:
            retornar medio
        sino si arreglo[medio] &lt; elemento_buscado:
            inicio = medio + 1
        sino:
            fin = medio - 1
    retornar -1  # Elemento no encontrado
</code></pre></div></div>

<p>En pocas palabras, nombramos dos índices, <code class="language-plaintext highlighter-rouge">inicio</code> y <code class="language-plaintext highlighter-rouge">fin</code>, que van a ser
los que nos dicen en qué parte vamos a buscar. Después, calculamos el centro
de la lista, sumando el inicio y el fin y dividiendo entre dos. Otra forma de
calcularlo sería restando el inicio y el fin, dividiendo entre dos y sumándole
el inicio. Estas dos formas son equivalentes.</p>

<p>Ahora, comparamos el elemento buscado con el elemento en el centro. Si es igual,
hemos encontrado el elemento y terminamos. Si es menor, tenemos que agarrar 
la parte de la lista que está a la derecha, es decir, los elementos mayores.
Para esto, el inicio es un elemento a la derecha del medio (<code class="language-plaintext highlighter-rouge">inicio = medio + 1</code>)
y el fin se queda igual. Si el elemento buscado es mayor, tenemos que agarrar
la parte de lista que está a la izquierda, y ahora el que cambia es el fin.</p>

<p>De esta manera, en cada paso nuestro espacio de búsqueda se reduce a la mitad.</p>

<p>Si llegamos a un punto en el que el inicio es mayor que el fin, entonces no
encontramos el elemento y retornamos -1 (el -1 es una forma de que el
programa nos diga que no encontramos el elemento, muy usada en programación).</p>

<h2 id="complejidad">Complejidad</h2>

<p>Con un arreglo pequeño pensarás que la búsqueda binaria es más lenta una búsqueda
aleatoria o secuencial y así es, pero recuerda que los algoritmos eficientes
se notan cuando el tamaño de los datos crece.</p>

<p>Al ir cortando sucesivamente a la mitad el espacio de búsqueda, la complejidad
de la búsqueda binaria crece en forma logarítmica.</p>

<p>Expliquemos un poco eso. Un logaritmo es la función que nos ayuda a encontrar
el exponente al que hay que elevar un número para obtener otro. En la búsqueda
binaria, el número que queremos “obtener” (en verdad, es recorrer) es el número
de elementos en el arreglo que vamos a buscar.</p>

<p>Suponiendo que en cada paso hacemos más o menos 5 operaciones, por ejemplo,
para buscar en un arreglo de 1000 elementos y tomando en cuenta lo que hemos
visto de cómo se va reduciendo el espacio de búsqueda, tendríamos la siguiente
sucesión:</p>

<p>Elementos por buscar: 1000</p>

<p>Operaciones totales: 5</p>

<hr />

<p>Elementos por buscar: 500</p>

<p>Operaciones totales: 10</p>

<hr />

<p>Elementos por buscar: 250</p>

<p>Operaciones totales: 15</p>

<hr />

<p>Elementos por buscar: 125</p>

<p>Operaciones totales: 20</p>

<hr />

<p>Elementos por buscar: 62</p>

<p>Operaciones totales: 25</p>

<hr />

<p>Elementos por buscar: 31</p>

<p>Operaciones totales: 30</p>

<hr />

<p>Elementos por buscar: 15</p>

<p>Operaciones totales: 35</p>

<hr />

<p>Elementos por buscar: 7</p>

<p>Operaciones totales: 40</p>

<hr />

<p>Elementos por buscar: 3</p>

<p>Operaciones totales: 45</p>

<hr />

<p>Elementos por buscar: 1</p>

<p>Operaciones totales: 50</p>

<hr />

<p>Observa cómo es que el número de operaciones no creció al mismo ritmo que el número de
elementos. El número de operaciones creció sumó sólo 5 operaciones cada que duplicamos
el número de elementos. Aquí es donde está el logaritmo, como estamos duplicando o
multiplicando por dos, la base de nuestro logaritmo es el 2. ¿Cuánto “pasos” vamos a
tener que hacer? Cuantas veces tengamos que duplicar el número de elementos para llegar
al número total de elementos del arreglo en el peor de los casos. Esto es el logaritmo
base 2.</p>

<p>Así que la complejidad de la búsqueda binaria es \(O(\log n)\). Donde \(n\) es el
número de elementos en el arreglo.</p>

<h2 id="implementaciones">Implementaciones</h2>

<p>Vamos a ver dos implementaciones en Python, una iterativa y otra recursiva.</p>

<p>Empezamos con la iterativa:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">arreglo</span><span class="p">,</span> <span class="n">elemento_buscado</span><span class="p">):</span>
    <span class="n">inicio</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">fin</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">arreglo</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">inicio</span> <span class="o">&lt;=</span> <span class="n">fin</span><span class="p">:</span>
        <span class="n">medio</span> <span class="o">=</span> <span class="p">(</span><span class="n">inicio</span> <span class="o">+</span> <span class="n">fin</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">arreglo</span><span class="p">[</span><span class="n">medio</span><span class="p">]</span> <span class="o">==</span> <span class="n">elemento_buscado</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">medio</span>
        <span class="k">elif</span> <span class="n">arreglo</span><span class="p">[</span><span class="n">medio</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">elemento_buscado</span><span class="p">:</span>
            <span class="n">inicio</span> <span class="o">=</span> <span class="n">medio</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fin</span> <span class="o">=</span> <span class="n">medio</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

</code></pre></div></div>

<p>Y la versión recursiva:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">arreglo</span><span class="p">,</span> <span class="n">elemento_buscado</span><span class="p">,</span> <span class="n">inicio</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fin</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">fin</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">fin</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">arreglo</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">inicio</span> <span class="o">&gt;</span> <span class="n">fin</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">medio</span> <span class="o">=</span> <span class="p">(</span><span class="n">inicio</span> <span class="o">+</span> <span class="n">fin</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">arreglo</span><span class="p">[</span><span class="n">medio</span><span class="p">]</span> <span class="o">==</span> <span class="n">elemento_buscado</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">medio</span>
    <span class="k">elif</span> <span class="n">arreglo</span><span class="p">[</span><span class="n">medio</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">elemento_buscado</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">arreglo</span><span class="p">,</span> <span class="n">elemento_buscado</span><span class="p">,</span> <span class="n">medio</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fin</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">arreglo</span><span class="p">,</span> <span class="n">elemento_buscado</span><span class="p">,</span> <span class="n">inicio</span><span class="p">,</span> <span class="n">medio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>Debido a la sintaxis de Python, la versión recursiva es un poco más verbosa,
por el manejo que tienes que hacer de los parámetros por defecto, pero si no
fuera por eso, en general me gusta más la versión recursiva.</p>

<p>Finalmente, si quieres hacer un programa que funcione con esta forma de búsqueda,
tienes que asegurarte de que las inserciones en el arreglo sean ordenadas, una forma
sencilla es usar un algoritmo parecido para encontrar el lugar adecuado para insertarlo.</p>

<h2 id="uso-en-el-mundo-real">Uso en el mundo real</h2>

<p>Lo que vimos en la sección anterior es para que entiendas cómo funciona, pero
lenguajes como Python, Ruby y otros, probablemente ya tengan implementaciones de
este algoritmo muy común. Por ejemplo, en Python tenemos el módulo <code class="language-plaintext highlighter-rouge">bisect</code> que 
permite hacer lo mismo con muchas menos líneas. Ejemplo:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">bisect</span>

<span class="n">lista</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="n">elemento</span> <span class="o">=</span> <span class="mi">5</span>

<span class="n">indice</span> <span class="o">=</span> <span class="n">bisect</span><span class="p">.</span><span class="nf">bisect_left</span><span class="p">(</span><span class="n">lista</span><span class="p">,</span> <span class="n">elemento</span><span class="p">)</span> <span class="c1"># en realidad nos dice el valor más pequeño que es mayor o igual al elemento buscado
</span>
<span class="c1"># si el índice es más grande que el número de elementos, no está en la lista
</span><span class="k">if</span> <span class="n">indice</span> <span class="o">!=</span> <span class="nf">len</span><span class="p">(</span><span class="n">lista</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lista</span><span class="p">[</span><span class="n">indice</span><span class="p">]</span> <span class="o">==</span> <span class="n">elemento</span><span class="p">:</span> 
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">El elemento </span><span class="si">{</span><span class="n">elemento</span><span class="si">}</span><span class="s"> está en el índice </span><span class="si">{</span><span class="n">indice</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">El elemento </span><span class="si">{</span><span class="n">elemento</span><span class="si">}</span><span class="s"> no está en la lista</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>Puedes ver más detalles del módulo <code class="language-plaintext highlighter-rouge">bisect</code> en la <a href="https://docs.python.org/3/library/bisect.html">documentación oficial</a>.</p>

<h2 id="conclusión">Conclusión</h2>

<p>La búsqueda binaria es uno de los algoritmos que todos los desarrolladores deberíamos conocer.
Espero que este artículo te haya ayudado a entender cómo funciona y su importancia.</p>]]></content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="algoritmos" /><category term="búsqueda" /><summary type="html"><![CDATA[Hablemos de un algoritmo sencillo que incluso utilizamos en la vida real pero que es muy importante en el mundo de la computación.]]></summary></entry><entry><title type="html">Desarrolladores que deberías admirar: Martin Kleppmann</title><link href="https://blog.thedojo.mx/2024/10/20/desarrolladores-que-deberias-admirar-martin-kleppmann.html" rel="alternate" type="text/html" title="Desarrolladores que deberías admirar: Martin Kleppmann" /><published>2024-10-20T00:00:00-06:00</published><updated>2024-10-20T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2024/10/20/desarrolladores-que-deberias-admirar-martin-kleppmann</id><content type="html" xml:base="https://blog.thedojo.mx/2024/10/20/desarrolladores-que-deberias-admirar-martin-kleppmann.html"><![CDATA[<p><strong>Martin Kleppmann</strong> es un desarrollador de software, investigador y profesor muy prolífico.
Hablemos de su trabajo, ideas y de por qué es alguien que podrías admirar.</p>

<h2 id="su-carrera">Su carrera</h2>

<p>Martin ha desarrollado su carrera e investigación alrededor del software deTambién trabaja en seguridad de sistemas distribuidos, un tema relacionado al anterior,
pero digamos que para temas de mayor escala.</p>

<p>Es profesor en la <strong>Universidad de Cambridge</strong>, pero parece que nunca se ha separado de la industria,
por ejemplo, como emprendedor, fundó Rapportive: una empresa que creó un plug-in que te permitía
ver los detalles de tus contactos directamente en tu bandeja de entrada de email. Rapportive fue
adquirida por LinkedIn por nada más y nada menos que por 15 millones de dólares.</p>

<p>También ha participado en proyectos de código abierto, con los siguientes proyectos:</p>

<ol>
  <li><a href="https://automerge.org/"><strong>Automerge</strong></a>: una biblioteca para crear software local-first, que es principalmente 
un CRDT (Conflict-free Replicated Data Type), es decir, una estructura de datos que sirve para sincronizar
información entre varios procesos que compartan esta misma estructura, de manera automática. Está disponible
para JavaScript, Swift y Rust.</li>
  <li><a href="https://avro.apache.org/docs/"><strong>Apache Avro</strong></a>: un formato de serialización de datos que compite con
protocol buffers y JSON, usado principalmente en el campo de ciencia e ingeniería de datos.</li>
  <li><a href="https://samza.apache.org/"><strong>Apache Samza</strong></a>: es un framework para procesar flujos de datos
de manera distribuida en tiempo real, que puede cooperar con Kafka y otros sistemas de procesamiento de datos.</li>
</ol>

<p>Kleppmann también es un gran contribuidor a la comunidad tanto con pláticas y artículos como con un libro que
es por lo que más se le conoce: <a href="https://dataintensive.net/">Designing Data-Intensive Applications</a>.</p>

<h2 id="ideas-sobre-el-desarrollo-de-software">Ideas sobre el desarrollo de software</h2>

<p>Martin es un gran proponente de los sistemas distribuidos en todas sus formas y de todos los aspectos realacionados
con estos, desde los temas conceptuales hasta la implementación y la seguridad. Actualmente está trabajando
con <em>local-first</em> software, que es aquel funciona principalmente en un entorno local, pero que puede
aprovechar las ventajas de tener una conexión a una red para hacer diferentes operaciones,
como sincronizar datos o colaborar en tiempo real.</p>

<p>En su libro <a href="https://dataintensive.net/">Designing Data-Intensive Applications</a> analiza las características
de software que manejan grandes cantidades de datos, y que cumple con tres características arquitectónicas: disponibilidad, escalabilidad y mantenibilidad. Este libro ha sido muy influyente en la industria, sobre todo
para aquellos que quieren mejorar sus habilidades de diseño de software relacionadas con sistemas de backend
distribuidos y bases de datos.</p>

<p>Si quieres aprender más acerca de todos los temas que hemos mencionado, que giran alrededor de sistemas
distribuidos, manejo de grandes cantidades de datos, diseño de software y software local-first, te recomiendo
ver la <a href="https://www.youtube.com/playlist?list=PLeKd45zvjcDHJxge6VtYUAbYnvd_VNQCx">lista de reproducción de videos</a>.</p>

<h2 id="curiosidades">Curiosidades</h2>

<p>Muchas personas buenas en el campo de la computación son buenas en otras cosas o tienen múltiples intereses.
Martin es un gran músico, compuso una ópera llamada “Die Türme des Februar”, que se estrenó en 2007.</p>

<h2 id="referencias">Referencias</h2>

<ul>
  <li><a href="https://martin.kleppmann.com/">Página personal de Martin Kleppmann</a></li>
  <li><a href="https://dataintensive.net/">Designing Data-Intensive Applications</a></li>
  <li><a href="https://twitter.com/martinkl">Twitter de Martin Kleppmann</a></li>
  <li><a href="https://github.com/mrkleppmann">GitHub de Martin Kleppmann</a></li>
</ul>]]></content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="Martin-Kleppmann" /><category term="bases-de-datos" /><category term="sistemas-distribuidos" /><category term="software-local-first" /><summary type="html"><![CDATA[Hablemos de Martin Kleppmann, uno de los desarrolladores e investigadores de software más influyentes en el panorama actual de las bases de datos y sistemas que usan datos.]]></summary></entry><entry><title type="html">Los diferentes grados de diseño de software</title><link href="https://blog.thedojo.mx/2024/10/19/los-diferentes-grados-de-diseno-de-software.html" rel="alternate" type="text/html" title="Los diferentes grados de diseño de software" /><published>2024-10-19T00:00:00-06:00</published><updated>2024-10-19T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2024/10/19/los-diferentes-grados-de-diseno-de-software</id><content type="html" xml:base="https://blog.thedojo.mx/2024/10/19/los-diferentes-grados-de-diseno-de-software.html"><![CDATA[<p>Hay una confusión enorme sobre el diseño de software. Cuando se habla de arquitectura, se empieza
a hablar de patrones de diseño, infraestructura, y otras cosas con las que no nos conviene
meternos en ese nivel.</p>

<p>Es por eso que en este artículo vamos a proponer una taxonomía para los diferentes grados de diseño
de software. Pero antes hablemos de por qué te conviene hacer una distinción clara.</p>

<p>También presentaremos una serie de recursos que puedes usar más para aprender de cada uno de
estos niveles de abstracción en el diseño de software.</p>

<h2 id="por-qué-te-conviene-distinguir-los-grados-de-diseño-de-software">Por qué te conviene distinguir los grados de diseño de software</h2>

<p>Lo primero que debemos entender es que hacer software <strong>implica</strong> diseñar software. Las raíces
de la palabra diseñar son las mismas que las de la palabra designar: las dos cosas tienen que ver
con <strong>decisiones</strong>. Cuando <em>diseñamos</em> entendemos que estamos tomando decisiones y documentándolas
por adelantado. Pero aunque ni las tomemos por adelantado, ni las documentemos, esas decisiones
están ahí y por lo tanto el diseño existe.</p>

<p>Teniendo esto presente, nos conviene ponerle atención al diseño desde el principio, para crear
software que <strong>cumpla tanto con las funciones como con las características que se esperan de él</strong>.</p>

<p>¿Ahora bien, por dónde empezamos a diseñar? Es aquí en donde entran los grados de abstracción
en diseño: conocer el nivel que necesitamos nos ayudará a empezar en el lugar adecuado.</p>

<h2 id="los-grados-de-abstracción-en-diseño-de-software">Los grados de abstracción en diseño de software</h2>

<p>Hablemos de cada uno de los grados de abstracción en diseño de software, qué es lo que se espera
y cómo contribuya a la solución final.</p>

<h3 id="arquitectura-de-soluciones">Arquitectura de soluciones</h3>

<p>El propósito del software o de cualquier sistema es resolver problemas para un usuario. Estos
sistemas están dentro de un contexto completo que le da sentido a su existencia. Es en este nivel
en donde se define la arquitectura de la solución.</p>

<p>Tomando en cuenta el contexto completo de dónde va a funcionar el software, la organización
o los individuos que lo van a usar, el contexto social, económico e incluso político, se define
la arquitectura de la solución, es decir, se toman en cuenta los componentes principales que van
influir en que el software pueda cumplir con su propósito.</p>

<p>Este nivel de diseño es el más alto relacionado con el software y requiere capacidad técnica, pero
también amplias capacidades a nivel de negocio, administración y otros campos relacionados con
el funcionamiento de las organizaciones.</p>

<p>Lo anterior implica que este nivel es poco específico en cuanto los detalles de la solución,
pero tiene gran impacto tanto en el que software cumpla con lo que se espera de él, como con
conseguir los recursos necesarios para su desarrollo. Además las decisiones que se toman aquí
tienen un gran impacto en los negocios que solicitan el software.</p>

<p>¿Qué tanto debe saber sobre <em>construcción de software</em> un arquitecto de soluciones? Como dijimos,
este nivel requiere poca especificidad técnica, pero gran capacidad para combinar conocimientos
de lo que es posible construir con el software, el contexto del negocio y proyección de los cambios
que el entorno va a sufrir. Este es un rol más amplio que profundo.</p>

<p>Un arquitecto de soluciones debe ser el traductor entre lo que el negocio necesita, tomando en cuenta
el contexto amplio de este, y el tipo de software que se puede construir o adquirir.</p>

<h4 id="recursos-para-aprender-arquitectura-de-soluciones">Recursos para aprender arquitectura de soluciones</h4>

<p>En esta sección te presento algunos recursos que te pueden ayudar a aprender sobre este nivel de
abstracción en el diseño de software, pero recuerda que nada sustituye la experiencia práctica:</p>

<ul>
  <li>
    <p><a href="https://www.oreilly.com/library/view/solution-architecture-foundations/9781780175676/">Solution Architecture Foundations</a>. Este libro es una excelente introducción a la arquitectura de soluciones y tiene
un enfoque práctico.</p>
  </li>
  <li>
    <p><a href="https://press.stripe.com/an-elegant-puzzle">An Elegant Puzzle: Systems of Engineering Management</a>. Está escrito
por un ingeniero de software y líder de ingeniería en grandes empresas de software. Este libre es un conjunto de
ensayos sobre la administración de equipos de ingeniería, pero también incluye valiosas lecciones sobre
cómo guiar a una organización en la que su principal activo es el software.</p>
  </li>
</ul>

<h3 id="arquitectura-de-software">Arquitectura de software</h3>

<p>El siguiente nivel de abstracción es la arquitectura de software. Esta actividad es una de las
más mal entendidas y por lo tanto mal ejecutadas a mi parecer. La arquitectura tiene que ver
con las características que una pieza de software demuestra a nivel estructural, es decir,
cualidades que surgen de la interacción de sus componentes.</p>

<p>Un error muy común al intentar practicar la arquitectura de software es irse demasiado rápido
a los detalles de implementación (si vamos a usar tal o cuál patrón de diseño, etc). Mi propuesta
es que la arquitectura de software se practique en un nivel de abstracción más alto, es decir,
más cerca de las necesidades del negocio.</p>

<p>Por lo tanto, la principal actividad en este nivel es transformar las necesidades del negocio en
características de software. A estas características las llamamos <strong>atributos de estructurales o
de calidad</strong>. Pero la arquitectura de software también se encarga de lograr que el software haga
las cosas que el negocio necesita.</p>

<p>También toma en cuenta la estructura de la organización y su composición para definir <em>la forma</em>
en que el software se va a desarrollar.</p>

<p>¿Qué tanto debe saber sobre <em>construcción de software</em> un arquitecto de software? Un arquitecto de
software, según la tradición medieval, es <em>el constructor principal</em>. Por lo tanto, debe tener 
una muy amplia experiencia técnica, conocer cómo funcionan la mayoría de los componentes principales
comunes del software, pero también debe tener experiencia tratando con las necesidades del negocio.</p>

<p>Un arquitecto es el principal traductor entre lo que el negocio necesita y <em>cómo</em> se puede
<strong>construir</strong> o <strong>armar</strong> un sistema que cumpla con esas necesidades.</p>

<h4 id="recursos-para-aprender-arquitectura-de-software">Recursos para aprender arquitectura de software</h4>

<p>En este apartado hay muchos recursos, los que yo te recomiendo son:</p>

<ul>
  <li>
    <p><a href="https://www.oreilly.com/library/view/software-architecture-in/9780136885979/">Software Architecture in Practice, 4th Edition</a>. Si
tuviera la necesidad de elegir un solo libro para aprender arquitectura de software,
este sería el que recomendaría. Analiza todos los aspectos fundamentales para construir
una arquitectura de software sin centrarse en el conocimiento trivial del que muchos creen que se trata
la arquitectura.</p>
  </li>
  <li>
    <p><a href="https://www.oreilly.com/library/view/fundamentals-of-software/9781098175504/">Fundamentals of Software Architecture</a>.
En este libro encontrarás todas las ideas fundamentales clásicas sobre arquitectura de software, y los
términos que se usan para habla sobre estos temas.</p>
  </li>
  <li>
    <p><a href="https://www.georgefairbanks.com/book/">Just Enough Software Architecture: A Risk-Driven Approach</a>. Aquí
encontrarás un enfoque diferente para la arquitectura de software: el enfocado en los riesgos. Este libro te
ayudará a encontrar el equilibrio al tomar decisiones en tu arquitectura.</p>
  </li>
</ul>

<h3 id="diseño-de-sistemas">Diseño de sistemas</h3>

<p>Una vez que sabemos qué características y funciones debe tener el software y cómo las vamos a lograr
debemos de ponerle nombre y detalles a cada pieza de software. De esto se encarga el diseño de sistemas.</p>

<p>Este, para mi, es el nivel más clásico y conocido en el diseño de software y el que más le emociona
a la mayoría de los desarrolladores. Es aquí donde dices que vas usar tal o cuál base de datos específica,
si vas a usar réplicas de lectura, cómo vas a manejar a un millón de usuarios concurrentes, e incluso
detalles de bajo nivel como el almacenamiento de datos y el tipo de infraestructura que vas a usar.</p>

<p>También es aquí donde muchas de las entrevistas de trabajo se centran cuando se quiere poner a prueba
la capacidad técnica de un desarrollador puro, ya que es un paso intermedio entre la arquitectura, que
tiene que ver mucho con el negocio, y la programación, que es todo lo que haría un desarrollador que a
penas está empezando.</p>

<p>Demostrar habilidad en este nivel es un proxy para entender qué tanto has desarrollado software, pero
tristemente, al igual que todas las medidas que se convierten en el objetivo, ha perdido gran parte
de su capacidad evaluadora ya que se puede simular fácilmente (estudiando los problemas clásicos de
entrevistas).</p>

<p>¿Vale la pena estudiarlo aisladamente? Sí, pero es no es suficiente. Este nivel no se trata de seguir
recetas de diseño de sistemas, aunque se pueda entender así, sino de conocer cómo se implementan las
soluciones arquitectónicas ahora con los detalles de implementación. Así que su verdadero valor viene
de la <strong>experiencia</strong> desarrollando software.</p>

<p>Creo que esta pregunta ya es obvia, pero demos una respuesta explícita al igual que en las otras
secciones: ¿Qué tanto debe saber sobre <em>construcción de software</em> un diseñador de sistemas? Mucho,
y mientras más experiencia real tenga, mejor.</p>

<p>Un diseñador de software lleva la visión arquitectónica dibujada en papel a su forma final, lista
para ser implementada.</p>

<h4 id="recursos-para-aprender-diseño-de-sistemas">Recursos para aprender diseño de sistemas</h4>

<p>El área de diseño de sistemas es muy amplia y recomiendo mucho estudiarla por partes. Primero,
puedes empezar por los problemas clásicos, usando uno de los libros que te prepara para entrevistas
como referencia, pero después tienes que profundizar:</p>

<ul>
  <li>
    <p><a href="https://www.oreilly.com/library/view/acing-the-system/9781633439108/">Acing the System Design Interview</a>.
Este libro te prepara para las entrevistas de trabajo, tocando todos los temas fundamentales de diseño de
sistemas.</p>
  </li>
  <li>
    <p><a href="https://www.oreilly.com/library/view/acing-the-system/9781633439108/">System Design Interview – An Insider’s Guide</a>. Otro 
libro que te prepara para la entrevista de diseño, pero es un poco más informal que
el anterior. Tiene una segunda parte que puedes encotrar aquí: <a href="https://amzn.to/3Ysb0ux">System Design Interview - An Insider’s Guide: Volume 2</a>.</p>
  </li>
</ul>

<p>Ahora sí, podemos empezar a profundizar:</p>

<ul>
  <li>
    <p><a href="https://dataintensive.net/">Designing Data-Intensive Applications</a>. Este trata sobre el diseño de sistemas
de alta disponibilidad, escalabilidad y mantenibilidad y que tratan con muchos datos. Analiza cómo se usan
los sistemas que manejan datos para lograrlos y se va a un poco más abajo para que veas cómo están construidos,
así que también te prepara para el nivel de abajo.</p>
  </li>
  <li>
    <p><a href="https://www.oreilly.com/library/view/building-microservices-2nd/9781492034018/">Building Microservices</a>. Una
de las formas más comunes de diseñar sistemas a grana escala es usando microservicios. Aunque no siempre los
vayas a usar, entender los patrones fundamentales y los problemas que resuelven te ayudará a implementar esos
principios en otros contextos.</p>
  </li>
  <li>
    <p><a href="https://www.oreilly.com/library/view/foundations-of-scalable/9781098106058/">Foundations of Scalable Systems</a>.
La escalabilidad es un tema clave en el diseño de sistemas, entender los medios para lograrla te ayudará
a ser un mejor diseñador.</p>
  </li>
</ul>

<h3 id="diseño-de-código">Diseño de código</h3>

<p>Para mi, el siguiente nivel tiene que ver con la <strong>implementación de los diseños</strong>. La pregunta en este
nivel es: ¿Cómo cumplo con las características y funcione que se esperan de esta pieza de software?</p>

<p>Ya dijimos que el software siempre tiene que ver con decisiones, de hecho podríamos decir que una
base de código es un conjunto de decisiones registradas en un lenguaje de programación. Un programador
que quiere cumplir con las funciones y características que se esperan de sus programas hace bien
en tomar decisiones por adelantado y en adoptar un conjunto de prácticas que le ayuden a cumplir
con lo que casi siempre se espera de esos sistemas de software.</p>

<p>En esta parte es donde se aplican los patrones de diseño, los principios de división modular y de
separación modular, donde se eligen nombres y donde se escoge el mejor algoritmo para resolver un problema
específico. El comportamiento alto nivel de los sistemas depende completamente de las decisiones que
se tomen a esta nivel y que se cumpla con lo que se espera de cada uno de los componentes.</p>

<p>Aquí es donde se elige si se usa un bubble sort, un merge sort o un quicksort para ordenar una lista,
si se usa la cierto módulo de terceros para una funcionalidad o si mejor lo implementamos.</p>

<p>La pregunta de las otras secciones no aplica aquí, este nivel es el más técnico y en el que se
está poniendo en práctica todo lo que sabemos de construcción de software.</p>

<p>Un programador, usa el diseño para lograr que cada pieza de software cumpla con lo que se espera de ella.</p>

<h4 id="recursos-para-aprender-diseño-de-código">Recursos para aprender diseño de código</h4>

<p>En este nivel vamos a encontrar muchos recursos, pero muchos de ellos se contradicen entre sí, por lo que
creo que es fundamental escoger una escuela de pensamiento y seguirla, pero también echarle un vistazo 
a las otras y contrastar los puntos de vista, para que generes tu propio estilo.</p>

<p>A continuación recomiendo mis libros favoritos en este nivel:</p>

<ul>
  <li>
    <p><a href="https://milkov.tech/assets/psd.pdf">A Philosophy of Software Design</a>. Este es mi libro favorito respecto
a diseño de código porque creo que viene de alguien con experiencia y errores reales. Contradice muchos consejos
encontrados en “Clean Code”, que es el libro más admirado en este aspecto, pero que creo que ha envejecido muy
mal.</p>
  </li>
  <li>
    <p><a href="https://www.patkua.com/blog/book-review-modern-software-engineering/">Modern Software Engineering</a>. Te presenta
las prácticas más modernas para desarrollar software, igual, escrito por un ingeniero de software con mucha experiencia.</p>
  </li>
</ul>

<p>En <a href="https://blog.thedojo.mx/2023/05/25/libros-que-todo-desarrollador-de-software-deberia-leer-desarrollo.html">este artículo</a> te
recomiendo otros libros que te pueden ayudar a mejorar tu diseño de código.</p>

<h2 id="conclusión">Conclusión</h2>

<p>En cada nivel de diseño requerimos diferentes tipos de conocimiento y habilidades. Estas cuatro niveles
no son necesariamente niveles secuenciales de desarrollo de carrera. Es decir, un muy buen programador
no tiene por qué aprender a diseñar a nivel de sistemas, por ejemplo, podría dedicarse a cada vez
diseñar mejor componentes individuales o incluso algoritmos específicos. Por ejemplo, los desarrolladores
de drivers o contribuidores individuales en equipos gigantes que se dedican una parte del sistema.</p>

<p>También, si estás implementando software con un objetivo ya definido, es poco probable que necesites aprender
sobre arquitectura de soluciones o arquitectura de software a muy alto nivel, ese aprendizaje sólo
te distraerá del conocimiento que realmente necesitas para resolver el problema.</p>

<p>Y también funciona en la otra dirección. Conocer los detalles de implementación de cierto algoritmo
no te hará un mejor arquitecto de software o de soluciones.</p>

<p>Así que ya sabes, ningún conocimiento es mejor que otro aunque puede que algunos piensen que así sea,
cada uno tiene su lugar y su propósito.</p>]]></content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="diseño-de-software" /><category term="arquitectura-de-software" /><summary type="html"><![CDATA[Hablemos de los diferente niveles de diseño de software y cómo puedes aprender cada uno de ellos.]]></summary></entry><entry><title type="html">¿Cómo funciona un intérprete?</title><link href="https://blog.thedojo.mx/2024/09/28/como-funciona-un-interprete.html" rel="alternate" type="text/html" title="¿Cómo funciona un intérprete?" /><published>2024-09-28T00:00:00-06:00</published><updated>2024-09-28T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2024/09/28/como-funciona-un-interprete</id><content type="html" xml:base="https://blog.thedojo.mx/2024/09/28/como-funciona-un-interprete.html"><![CDATA[<p>Un intérprete es un programa que lee código fuente y se encarga de
ejecutarlo. En este artículo vamos a hablar de sus etapas y las principales
tareas que realiza, para darte la idea de cómo funciona y si lo deseas, puedas
tener idea de cómo hacerlo tu mismo.</p>

<p>Empecemos por hablar de la diferencia con un compilador.</p>

<h2 id="intérprete-vs-compilador">Intérprete vs compilador</h2>

<p>Ambos tipos de programas tienen la característica de recibir
código fuente, pero la diferencia está en lo que devuelven, y por lo tanto
en las etapas que les permiten lograrlo.</p>

<p><strong>Un compilador traduce</strong> el código fuente a otro lenguaje, normalmente a un
lenguaje máquina que puede ser ejecutado por un procesador de una arquitectura
específica. Pero esto no es necesariamente así, ya que la principal tarea del<br />
compilador es <strong>traducir</strong>. Un ejemplo es el compilador de Java:
no compila al lenguaje de una arquitectura de procesador específica, sino a
bytecode que puede ser ejecutado por la JVM. Si no sabes que es el bytecode,
hablamos de él <a href="/2023/01/22/entendiendo-el-bytecode.html">en este artículo</a>.</p>

<p>Los compiladores tradicionales compilan el código fuente a código máquina,
es decir, a las instrucciones que un procesador puede ejecutar directamente. Así,
si quieres ejecutar un programa de C o de C++ en un procesador con arquitectura
x86, necesitas un compilador traduzca para las instrucciones de esta arquitectura.
Si después requieres ese mismo programa para ARM, necesitas compilar de nuevo.</p>

<p>Un intérprete también recibe el código fuente, pero en lugar de devolver la
traducción en otro lenguaje, <strong>ejecuta</strong> el código fuente directamente. A veces
este proceso tiene como producto secundario la traducción del código fuente
en un lenguaje intermedio, pero su objetivo principal es <strong>la ejecución</strong>.</p>

<p>Ahora sí hablemos de las etapas de un intérprete.</p>

<h2 id="las-etapas-de-un-intérprete">Las etapas de un intérprete</h2>

<p>Para ejecutar el código de un programa, podemos dividir el trabajo en varios
pasos. Para entenderlo pongamos un ejemplo. Supongamos que alguien te pide
que hagas una tarea, por ejemplo, un trabajo escolar. Si tú fueras el intérprete,
tendrías que hacer más o menos los siguientes pasos:</p>

<ol>
  <li>Leer las instrucciones de la tarea.</li>
  <li>Entender claramente y sin ambigüedades lo que se te pide.</li>
  <li>Crear un plan para ejecutar la tarea.</li>
  <li>Ejecutar uno a uno los pasos del plan.</li>
</ol>

<p>Esos son los pasos que un intérprete hace para ejecutar un programa.</p>

<ol>
  <li><strong>Tokenización</strong>: Leer el código en fuente y transformarlo en una forma
que pueda entender.</li>
  <li><strong>Parsing</strong>: Convertir el código fuente en una estructura de datos que pueda
ser ejecutada. En nuestro plan esto serían los pasos 2 y 3.</li>
  <li><strong>Ejecución</strong>: Ejecutar uno a uno los pasos del plan para lograr el resultado.</li>
</ol>

<h3 id="parsing-o-parseo---análisis-léxico-y-sintáctico">Parsing o Parseo - Análisis léxico y sintáctico</h3>

<p>A veces a la etapa completa de leer el código fuente y convertirlo en una
estructura de datos que pueda ser ejecutada se le llama <strong>Parsing</strong>.</p>

<p>¿Cómo puede un programa informático leer un programa y entenderlo? Lo hace de forma
limitada, claro, pero lo suficiente para poder ejecutar el código. Un lenguaje
de programación es un lenguaje creado a partir de un alfabeto (un conjunto de símbolos),
que a su vez forman palabras y estas palabras forman sentencias. Un <strong>programa</strong>, por
lo tanto, es una secuencia de sentencias.</p>

<p>Para que un intérprete “entienda” un programa, la primera etapa consiste en
convertir el código fuente (un conjunto de símbolos), en una secuencia de
palabras conocidas por el intérprete. Esto es un tipo de clasificación de
las palabras. A la representación interna de estas palabras en el intérprete
se le llama <strong>tokens</strong>. Debido a que en un lenguaje es muy importante el orden
de las palabras, esta clasificación debe mantener el orden de las palabras. Como te
imaginarás, este proceso es al que se le llama <strong>tokenización</strong>.</p>

<p>Después de tener la lista de palabras conocidas, necesitamos “entenderlas”. Como un
lenguaje tiene una estructura, esta estructura.</p>

<p>Después, este conjunto de <em>tokens</em> es convertido en una estructura de datos
llamada el <strong>Árbol de Sintaxis Abstracta</strong> o <strong>AST</strong> (Abstract Syntax Tree). Este
proceso se llama <strong>parsing</strong>, que en inglés significa “analizar”.</p>

<h3 id="construcción-del-ast">Construcción del AST</h3>

<p>Ya con la lista ordenada de tokens que representan el programa, tenemos que construir la
estructura de datos que representa las operaciones que vamos a ejecutar, <strong>el
AST</strong>.</p>

<p>Esta estructura se parece a un árbol, con cada nodo representando una operación
que a su vez puede estar compuesta de más operaciones, es una
estructura recursiva. Por ejemplo, si tenemos un programa muy sencillo como
<code class="language-plaintext highlighter-rouge">a = 1 + 2</code>, el AST podría verse así:</p>

<p><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,q_69,w_600/v1727416535/Screenshot_2024-09-26_at_23.54.41_spehcz.png" alt="AST de a = 1 + 2" class="align-center" /></p>

<p>En el esquema anterior puedes ver lo que más o menos es un árbol de sintaxis abstracta:
una estructura que nos va ayudar a ejecutar el programa. Para mi, este es el centro
tanto de un compilador como de un intérprete, si tienes bien definido este árbol (y por
lo tanto todas las operaciones que son posibles de representar en él), tienes hecho
la mitad del trabajo, tanto para compilar a otro lenguaje como para ejecutar
directamente el trabajo.</p>

<p>Pasemos a la siguiente etapa.</p>

<h3 id="ejecución">Ejecución</h3>

<p>Lo que sigue es lo más sencillo de entender (pero tal vez no de <em>implementar</em>): la ejecución
del programa. El intérprete debe tener la capacidad de actuar sobre el sistema operativo para
ejecutar las operaciones representadas en el AST. Si el intérprete corre
en alguna otra cosa que no sea directamente el sistema operativo, por ejemplo
en una máquina virtual, u otro programa, las acciones son diferentes, pero la
idea es la misma: debe tener la capacidad de actuar sobre el programa en el que corra.</p>

<h3 id="opcional-optimización">Opcional: optimización</h3>

<p>Varios de los intérpretes modernos tienen que se usan en entornos de producción, tienen
una etapa que no es absolutamente necesaria, pero que da una ventaja significativa en el
rendimiento y uso común: la <strong>optimización del la ejecución</strong>.</p>

<p>Estas optimizaciones pueden darse desde mejoras en el AST hasta la generación de código
específico para la arquitectura del procesador en el que se ejecute el programa y ejecutarlo
inmediatamente. Hablamos de esta última técnica.</p>

<h4 id="compilación-just-in-time-jit">Compilación Just In Time (JIT)</h4>

<p>Una forma de optimización usada por los intérpretes y máquinas virtuales es lo
que se conoce como <strong>Just In Time Compilation</strong>. La idea es sencilla:</p>

<ol>
  <li>Se ejecuta el código fuente original mientras se observa el comportamiento de 
este programa con un perfilador (o profiler).</li>
  <li>Una vez que el perfilador detecta cosas que se pueden optimizar, un compilador
especializado en la arquitectura del procesador en el que el intérprete está
corriendo genera código máquina específico para es arquitectura de las partes
que se pueden optimizar.</li>
  <li>El código máquina optimizado se ejecuta mientras se sigue observando el
comportamiento del programa.</li>
  <li>Si el programa no se comporta de la forma esperada, esta parte de la ejecución
se cancela y se vuelve a ejecutar el código fuente original.</li>
</ol>

<p>Tenemos un artículo completo sobre JIT <a href="2023/01/18/compilacion-just-in-time-que-es.html">en este enlace</a>.</p>

<h2 id="conclusión">Conclusión</h2>

<p>Ahora entiendes mejor cómo funcionan los intérpretes de manera general. Este
conocimiento te puede ayudar cuando trabajes con ellos y probablemente tengas
algún problema directamente relacionado con su funcionamiento interno.</p>

<p>También tienes el conocimiento básico para avanzar a aprender cómo hacer el tuyo
en caso de que lo necesites. En un artículo futuro hablaré sobre cómo hacer un intérprete
de un lenguaje de programación sencillo, para entender todavía mejor el funcionamiento.</p>]]></content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="compiladores" /><category term="intérprete" /><category term="lenguajes-de-programación" /><summary type="html"><![CDATA[Hablemos brevemente de las etapas de una de las formas de correr tu código: un intérprete.]]></summary></entry><entry><title type="html">¿Cómo funciona TensorFlow?</title><link href="https://blog.thedojo.mx/2024/09/16/como-funciona-tensorflow.html" rel="alternate" type="text/html" title="¿Cómo funciona TensorFlow?" /><published>2024-09-16T00:00:00-06:00</published><updated>2024-09-16T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2024/09/16/como-funciona-tensorflow</id><content type="html" xml:base="https://blog.thedojo.mx/2024/09/16/como-funciona-tensorflow.html"><![CDATA[<p><strong>TensorFlow</strong> es una de las herramientas más populares e influyentes
en el campo de la del aprendizaje automático. En este artículo vamos a ver
qué es exactamente y cómo funciona.</p>

<h2 id="qué-es-tensorflow">¿Qué es TensorFlow?</h2>

<p>Siempre que hablamos de TensorFlow se dice que es una “biblioteca (o librería)
para hacer aprendizaje automático, pero este definición no es muy
explícita y por eso vamos a ver <em>cómo nos permite</em> crear modelos de
aprendizaje.</p>

<p>Para crear modelos de aprendizaje automático, tenemos que hacer muchos cálculos
matemáticos, la gran mayoría son operaciones de multiplicación de matrices.
Estos cálculos no son eficientes en un procesador tradicional y por eso se
requiere de toda la ayuda que se pueda conseguir para hacerlos lo más rápido
posible y gastando menos energía.</p>

<p>Es aquí donde entra <strong>TensorFlow</strong>, una biblioteca que permite <em>representar</em> estos
cálculos mediante grafos de cómputo y después ejecutarlos en procesadores
especializados como tarjetas gráficas y otros procesadores eficientes en
operaciones matemáticas pesadas. Además, TensorFlow abstrae al usuario final (tú),
de los detalles de implementación de muchas funciones y operaciones matemáticas
que se usan mucho en el aprendizaje automático. Y finalmente, con su <em>API</em> de alto
nivel, <strong>Keras</strong>, te permite crear diferentes tipos de redes neuronales sin
que tengas que pelearte con los detalles de implementación.</p>

<p>Y es aquí donde empieza lo interesante. ¿Qué es un grafo de cómputo? ¿Cómo
llegamos a él y para qué nos sirve? Veamos.</p>

<h2 id="grafos-de-cómputo-de-tensorflow">Grafos de cómputo de TensorFlow</h2>

<p>Para entenderlo, vamos a ver un ejemplo sencillo de un cálculo y su
representación, por ejemplo, sumemos dos números, que llamaremos X y Y.</p>

<p>¿Cómo representa TensorFlow esto? Este es el grafo de cómputo que podemos ver con
una herramienta de análisis de TensorFlow llamada TensorBoard:</p>

<p><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_250/v1726379906/Screenshot_2024-09-14_at_23.53.34_1_izykn5.png" alt="Imagen de un grafo de cómputo de TensorFlow" class="align-center" /></p>

<p>Puedes pensar en este grafo como una serie de nodos que representan cada uno
una operación sobre conjuntos de datos numéricos llamados tensores. Cuando
ejecutamos este grafo, los tensores <em>fluyen</em> por estos nodos, transformándose
en cada uno, hasta que obtenemos el resultado final de la operación. (Los nodos
que dicen <code class="language-plaintext highlighter-rouge">Identity</code> son operaciones de copia o lectura de valores, útiles para
el funcionamiento interno de  TensorFlow).</p>

<p>La otra cosa que podemos notar hasta abajo de la gráfica son los dos nodos que
representan nuestros números simples: X scalar y Y scalar, ya que los definimos
como números simples, que también pueden pensarse como tensores de una dimensión.</p>

<p>Formalmente, TensorFlow te da una serie de estructuras de datos, que puedes
ir construyendo poco a poco para definir todas las operaciones que necesites hacer.</p>

<p>En una red neuronal, estos grafos son mucho más complicados, pero justo ese es
el trabajo de TensorFlow: ayudarte a definirlos y a ejecutarlos en el hardware
más conveniente para tu proyecto.</p>

<p>Usar los grafos de cómputo de TF te permite varias cosas más:</p>

<ul>
  <li><strong>Optimización de las operaciones</strong>: TensorFlow tiene todo un sistema de optimización
llamado <code class="language-plaintext highlighter-rouge">Grappler</code>, que se encarga varias optimizaciones.</li>
  <li><strong>Paralelización</strong>. Con las operaciones divididas, TensorFlow puede verificar
qué operaciones son independientes y puede ejecutarlas en otros procesadores
si están disponibles.</li>
  <li><strong>Exportación</strong>. Una vez teniendo las operaciones definidas en un grafo, no necesitamos
de Python para ejecutarlas, así que TensorFlow puede ejecutarlas en otros dispositivos
y usando otros lenguajes.</li>
</ul>

<p>Esta definición de grafos de cómputo no es la única forma de trabajar con TensorFlow,
ya que desde su versión 2.0, también permite trabajar con un modo más imperativo,
que se siente más integrado con Python y más dinámico: la ejecución adelantada (en
inglés: <em>eager execution</em>). Con esta forma de ejecución, las operaciones se van
ejecutando inmediatamente después de definirlas. Esto es más fácil de programar y
de leer, pero deja poco espacio para la optimización. Es justamente como la comparación
entre un lenguaje compilado y uno interpretado.</p>

<h2 id="tensorflow-y-keras">TensorFlow y Keras</h2>

<p>Keras era otra biblioteca que se creó por separado, para hacer más fácil de usar
la versión 1.0 de TensorFlow, que era bastante más verbosa de programar (por sólo
soportar grafos de cómputo estáticos).Sin embargo, en la versión 2.0 de TensorFlow,
Keras se volvió parte del paquete.</p>

<p>Keras te permite crear modelos de aprendizaje profundo de manera sencilla. Es la
manera fácil de usar TensorFlow, pero también te permite complicarte tanto como quieras
o necesites (esperamos que sea esto último). Keras usa el principio de “revelación
progresiva de la complejidad”, lo que significa que puedes empezar de manera muy
sencilla e ir aprendiendo cosas conforme vayas avanzando en hacer cosas más complejas.</p>

<p>Así que la forma más común de usar TensorFlow para crear tus modelos de machine
learning es mediante la interfaz de Keras, que además de todo te provee de
utilidades que son de uso muy común en las redes neuronales. Por ejemplo, provee
regularizadores, inicializadores, funciones de activación, optimizadores, y muchas
utilidades más. Es por eso que ya casi no se concibe el uso de TensorFlow para
casos comunes sin usar Keras.</p>

<h2 id="tensorflow-y-mlir">TensorFlow y MLIR</h2>

<p>MLIR es una herramienta para crear compiladores hecha por parte del mismo
equipo que hizo LLVM, la infraestructura para compiladores que está detrás
de la mayoría de los compiladores modernos.</p>

<p>La especialidad de MLIR es hacer traducciones para arquitecturas de hardware no
tradicionales,usando un lenguaje intermedio multi-capa al que le puedes agregar
más plugins para diferentes arquitecturas de ejecutores. MLIR es muy usado
para computación de alto rendimiento, justamente la que necesitamos para
crear modelo de aprendizaje automático complejos en tiempos y con costos
razonables.</p>

<p>Así que TensorFlow, aprovechando este sistema, usa MLIR para compilar los
grafos de cómputo y los modelos para hardware específico, para que se pueda
obtener el mejor rendimiento posible.</p>

<h2 id="tensorflow-y-su-relación-con-el-hardware">TensorFlow y su relación con el hardware</h2>

<p>Después de la sección anterior, es muy probable que la relación de TF con
el hardware quede muy clara: TensorFlow ayuda a que se pueda compilar
de mejor manera el código con los cálculos para poder ejecutarlo
en el hardware especializado.</p>

<p><strong>IF</strong> soporta gran variedad de tipos de hardware y es por eso que hasta el
momento es la biblioteca de machine learning con mejor soporte para
distribuir tus modelos en diferentes dispositivos, desde procesadores
especializados hasta que corran directamente en tu teléfono o navegador.</p>

<h2 id="conclusión">Conclusión</h2>

<p>Si quieres hacer machine learning, lo más probable es que tengas que
aprender TensorFlow, una herramienta muy útil para hacer los modelos usados
hoy.</p>

<p>Espero que lo que hablamos sobre TensorFlow en este artículo te haya ayudado
a entenderlo un poco más. En otro artículo hablaremos de su competidor
más directo: <strong>PyTorch</strong>.</p>]]></content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="tensorflow" /><category term="machine-learning" /><category term="ai" /><category term="deep-learning" /><summary type="html"><![CDATA[TensorFlow permite crear modelos de aprendizaje automático sin que te tengas que plear con la forma en la que se hacen los cálculos en los ejecutores. Hablemos más de cómo funciona.]]></summary></entry><entry><title type="html">Por qué debes leer Designing Data-intensive Applications</title><link href="https://blog.thedojo.mx/2024/08/30/por-que-debes-leer-designing-data-intensive-applications.html" rel="alternate" type="text/html" title="Por qué debes leer Designing Data-intensive Applications" /><published>2024-08-30T00:00:00-06:00</published><updated>2024-08-30T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2024/08/30/por-que-debes-leer-designing-data-intensive-applications</id><content type="html" xml:base="https://blog.thedojo.mx/2024/08/30/por-que-debes-leer-designing-data-intensive-applications.html"><![CDATA[<p>Uno de los libros más recomendados para todos los desarrolladores modernos
es “Designing Data-intensive Applications” de <a href="https://martin.kleppmann.com/">Martin Kleppmann</a>.
En este artículo corto vamos a hablar de por qué vale la pena leerlo.</p>

<h2 id="quién-es-martin-kleppmann">¿Quién es Martin Kleppmann?</h2>

<p><strong>Martin</strong> es un desarrollador, investigador, escritor y profesor de ciencias
de la computación bastante prolífico. Actualmente trabaja en la <a href="https://www.cst.cam.ac.uk/">Universidad
de Cambridge</a> y ha trabajado en empresas como
<a href="https://www.crunchbase.com/organization/rapportive">Rapportive</a>(que él fundó
y fue comprada por LinkedIn, y también trabajó ahí).</p>

<p>Es también al autor de <a href="https://roundrobin.pub/">Secret Colors</a>. Un libro de
criptografía de llave pública y llave privada para niños, de la editorial
Round Robin.</p>

<p><strong>Kleppmann</strong> es un experto en todo lo que tiene que ver con estructuras
y manejo de datos. En el presente (2024), su interés está en la
coordinación de datos entre sistemas locales, es decir, el software
funciona principalmente en un dispositivo que puede estar o no
conectado a una red y después puede sincronizarse con otros sistemas
remotos, para adquirir más funciones como respaldos o sincronización.</p>

<p>Pero su trabajo más notable hasta el momento es <strong>Designing Data-intensive
Applications</strong> (<em>DDiA</em> a partir de ahora). Veamos por qué.</p>

<h2 id="de-qué-trata-designing-data-intensive-applications">¿De qué trata Designing Data-intensive Applications?</h2>

<p>Podemos resumir <em>DDiA</em> como un libro de diseño de software enfocado en los
datos y sus interacciones. Es un libro de diseño en el sentido amplio:
abarca desde la arquitectura de software, hasta la elección de algoritmos
para lograr las características arquitectónicas deseadas.</p>

<p>El libro tiene tres grandes partes:</p>

<ol>
  <li>
    <p>En la primera habla de los principios fundamentales de los sistemas que hacen
uso intensivo de datos. Habla de las características arquitectónicas
que los sistemas intensivos es datos deben tener para ser usables. También
se sientan las formas básicas de almacenar y representar datos a diferentes
niveles.</p>
  </li>
  <li>
    <p>En la segunda parte, se habla de sistemas distribuidos y sus implicaciones
y las dificultades que conllevan. Aquí se tratan temas como replicación,
particiones y transacciones. También se tratan los temas fundamentales para
tener datos confiables: consistencia y consenso.</p>
  </li>
  <li>
    <p>Aquí se habla de sistemas que derivan datos de otros datos, como índices,
caches y cosas similares, como puedes notar, elementos que son fundamentales
en cualquier sistema de software serio moderno.</p>
  </li>
</ol>

<p>Se habla de todo lo necesario para aprender el manejo
de grandes cantidades de datos, desde las formas de modelarlos y almacenarlos,
hasta distribuirlos y procesarlos para crear subproductos útiles.</p>

<h2 id="el-estilo-del-libro">El estilo del libro</h2>

<p>DDiA tiene un estilo bastante relajado, nada acercado a la academia, más bien,
es amigable y fácil de leer. Además tiene un poco de humor sutil que hará el libro
todavía más disfrutable.</p>

<p>Para complementar, el libro tiene imágenes, algunas dibujadas a mano que
te ayudan a ubicarte en el gran esquema de todas las ideas que trata.</p>

<p>Así que si te preocupa que sea un libro denso, para nada lo es.</p>

<h2 id="qué-beneficios-obtendrás-al-leerlo">Qué beneficios obtendrás al leerlo</h2>

<p>Si eres un desarrollador de software con experiencia, especialmente en el
backend, podrás profundizar tu experiencia en el entendimiento de la forma
en la que se tratan los datos para crear sistemas confiables, escalables y
mantenibles. Toma en cuenta que este libro, como su nombre lo dice
está enfocado en el <strong>diseño</strong>. Este libro te dará ideas prácticas para
aplicarlas a tus proyectos.</p>

<p>Si estás en cualquier otra área del desarrollo de software, este libro te
ayudará a entender mejor cómo funciona la capa de almacenamiento de datos
en cualquier sistema y puede ayudarte a hacerlo mejor en tu área, porque
en todas las capas y áreas del desarrollo necesitamos tratar con datos,
a veces poco, a veces mucho.</p>

<h2 id="conclusiones">Conclusiones</h2>

<p>Si quieres leer un libro sobre diseño de software, no puedes fallar con
<strong>Designing Data-intensive Applications</strong>. Vale mucho más la pena que otros
libros de diseño de software por su profundidad y practicidad, además de
que te va a dar de qué platicar con otros desarrolladores de software
que pueden estar en el mismo camino de desarrollo profesional que tú.</p>]]></content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="Matin-Kleppmann" /><category term="dato" /><category term="bases-de-datos" /><summary type="html"><![CDATA[Platiquemos de uno de esos libros que todo desarrollador sabe que debe leer, que puede ayudarte a entender las aplicaciones modernas.]]></summary></entry><entry><title type="html">Alternativas a Git</title><link href="https://blog.thedojo.mx/2024/07/18/alternativas-a-git.html" rel="alternate" type="text/html" title="Alternativas a Git" /><published>2024-07-18T18:00:00-06:00</published><updated>2024-07-18T18:00:00-06:00</updated><id>https://blog.thedojo.mx/2024/07/18/alternativas-a-git</id><content type="html" xml:base="https://blog.thedojo.mx/2024/07/18/alternativas-a-git.html"><![CDATA[<p>Git es una herramienta que se considera <em>obligatoria</em> para los desarrolladores
modernos por ser el programa usado para versionamiento de código usado por
la mayoría de los proyectos.</p>

<p>Pero no es ningún secreto que Git es una herramienta difícil de comprender y
que el 90% de los desarrolladores le dan <strong>el uso más básico</strong>, temiendo romper algo
y por eso tener que usar comandos más avanzados.</p>

<p>Hablemos de por qué es así y después veamos algunas alternativas interesantes.</p>

<h2 id="los-orígenes-de-git">Los orígenes de Git</h2>

<p>Al igual que otros sistemas de control de versiones, Git nació como soporte al
desarrollo de uno de los proyectos de software más importantes de todos los
tiempos: el kernel de Linux. Fue creado por <strong>Linus Torvalds</strong>.</p>

<p>Su objetivo no era ser una herramienta de uso masivo y fácil de usar, sino
trabajar sin las limitantes de las herramientas que existían en ese momento.
Y claramente, Linus lo creó a su manera. Algo interesante es que se llama
“Git” porque en inglés británico es una palabra despectiva que se usa para
llamar a alguien tonto o desagradable. Linus nombra sus proyectos como a sí
mismo, y como cualquiera lo podría llamar así a él, decidió ponerle ese nombre
a su sistema de manejo de versiones.</p>

<p><strong>Git</strong> empezó a ser usado por la comunidad de Linux en 2005 y después por otros
proyectos Open Source, pero su éxito se disparó cuando en 2008 surgió GitHub
que facilitó su uso. Por ser una herramienta tan útil, ahora la tenemos como el
estándar en versionmiento de código.</p>

<p>Pero no es el único sistema de control de versiones moderno, hablemos de
dos alternativas.</p>

<h2 id="fossil">Fossil</h2>

<p>Fossil fue creado por el autor de SQLite, <a href="https://www.hwaci.com/drh/"><strong>Richard Hipp</strong></a>, y al igual que Git,nació
para soportar a este proyecto de software libre, el principal de su Hipp.</p>

<p>Al buscar un sistema de control de versiones moderno, Richard no encontró nada que lo convenciera
al cien por ciento, por lo que decidió crear Fossil, con las siguientes características:</p>

<ol>
  <li><strong>Integración de Wiki y Tickets</strong>: Fossil tiene incluye estas herramientas a las que Hipp y
su equipo estaban acostumbrados.</li>
  <li><strong>Foro y chat</strong>: Fossil está pensado para también ser el centro de conversación del proyecto.</li>
  <li><strong>Autosync</strong>: permite que los cambios se sincronicen automáticamente sin tener que andar haciendo
magia con las ramas y los commits.</li>
</ol>

<p>Personalmente, me gusta mucho la idea de tener todo integrado en un mismo
sistema, y pienso que el que sistemas como Jira y Confluence se integren directamente
con GitHub, Bitbucket y cosas similares, es una señal de que esta integración
es un muy buena idea que ayuda a que el proceso de software sea más fluido.</p>

<p>Puedes encontrar más información en <a href="https://fossil-scm.org/">fossil-scm.org</a>,
para instalarlo por tu cuenta. Pero también existe una versión hosteada en la
que de manera gratuita podrás tener el servicio de Fossil, equivalente a
GitHub: <a href="https://chiselapp.com/">Chisel</a>.</p>

<h2 id="pijul">Pijul</h2>

<p>Pijul es un sistema de control de versiones pensado para ser lo más fácil de usar.
Tiene un fundamento matemático: la teoría de parches (patch theory), lo cuál te da
garantías interesantes, como la facilidad de uso y la reducción de errores
catastróficos. Combina las dos formas principales en las que se han creado sistemas
control de versiones: los sistemas basados en spapshots (como la mayoría de los
sistemas de control de versiones más conocidos, incluido Git) y los sistemas
basados en parches (como <a href="https://darcs.net/">Darcs</a>, un SVC poco conocido pero
más fácil de usar).</p>

<p>Los sistemas basados en snapshots son más rápidos pero más frágiles y difíciles de
usar y los basado en parches son lentos. Es por eso que Pijul cobina lo mejor de ambos
tipos de sistemas y mientras se mantiene lo suficientemente rápido sigue siendo fácil
de usar incluso en situaciones en las que Git se vuelve complejo, como en merges,
conflictos y cherry-picks. En un post posterior hablaremos ge Pijul.</p>

<p>Puedes encontrarlo en <a href="https://pijul.org/">pijul.org</a>, te recomiendo
que si quieres probar algo fundamentalmente diferente a Git, pero con las mismas
funciones externas, le des una oportunidad.</p>

<h2 id="conclusión">Conclusión</h2>

<p>No vamos a reemplazar a Git en el corto plazo y probablmente nunca lo hagamos
por lo extendido que está su uso (piensa en el efecto Lindsey), pero es bueno
saber que existen alternativas. Estas herramientas
nos enseñan cosas interesantes sobre el desarrollo de software, como que casi
siempre hay más de una forma de lograr lo que queremos.
Ojalá que en el futuro, Git tome algunas de las ideas de estos proyectos y mejore su
experiencia de usuario.</p>]]></content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="git" /><category term="version-control" /><category term="fossil" /><category term="pijul" /><summary type="html"><![CDATA[Git es una herramienta compleja, ya que no fue pensada desde el principio para tener buena experiencia de usuario, veamos algunas alternativas.]]></summary></entry></feed>