<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="es" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>The Dojo MX Blog</title>
<meta name="description" content="">


  <meta name="author" content="Héctor Patricio">
  


<meta property="og:type" content="website">
<meta property="og:locale" content="es">
<meta property="og:site_name" content="The Dojo MX Blog">
<meta property="og:title" content="The Dojo MX Blog">
<meta property="og:url" content="https://blog.thedojo.mx/feed.json">













<link rel="canonical" href="https://blog.thedojo.mx/feed.json">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": null,
      "url": "https://blog.thedojo.mx/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="The Dojo MX Blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    
<!-- favicon -->
<link rel="apple-touch-icon" sizes="180x180" href="/assets/images/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicons/favicon-16x16.png">
<link rel="manifest" href="/assets/images/favicons/site.webmanifest">
<link rel="mask-icon" href="/assets/images/favicons/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="/assets/images/favicons/favicon.ico">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/assets/images/favicons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">
<!-- end favicon -->
<!-- for mathjax support -->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZNSYMJDY5S"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-ZNSYMJDY5S');
</script>

<!-- Hotjar Tracking Code for blog.thedojo.mx -->
<script>
    (function(h,o,t,j,a,r){
        h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
        h._hjSettings={hjid:1217463,hjsv:6};
        a=o.getElementsByTagName('head')[0];
        r=o.createElement('script');r.async=1;
        r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
        a.appendChild(r);
    })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9860440966400421"
     crossorigin="anonymous"></script>

<script src="/assets/js/sharect.min.js"></script>
<!-- Fathom - beautiful, simple website analytics -->
   <script src="https://cdn.usefathom.com/script.js" data-site="NGGHUUZH" defer></script>
<!-- / Fathom -->
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "url": "https://blog.thedojo.mx/feed.json",
      "name": null,
      "headline": null,
      "keywords": "",
      "description": "",
      "articleBody": "{\n  \"version\": \"https://jsonfeed.org/version/1\",\n  \"title\": {{ site.title | jsonify }},\n  \"description\": {% if site.description %}{{ site.description | jsonify }}{% endif %},\n  \"home_page_url\": \"{{ site.url }}\",\n  \"feed_url\": \"{{ site.url }}/feed.json\",\n  \"favicon\": \"{{ site.url}}/favicon.png\",\n  {% if site.author %}\n  \"author\": {\n    \"name\": {{ site.author | jsonify }}\n  },\n  {% endif %}\n  \"items\": [\n    \n    {% for post in site.posts limit:10 %}\n    {\n      \"id\": \"{{ post.url | prepend: site.baseurl | prepend: site.url }}\",\n      \"url\": \"{{ post.url | prepend: site.baseurl | prepend: site.url }}\",\n      \"title\": {{ post.title | jsonify }},\n      \"content_html\": {{ post.content | jsonify  }},\n      \"date_published\": \"{{ post.date | date_to_rfc822 }}\"\n      }{% unless forloop.last %},{% endunless %}\n    {% endfor %}\n  ]\n}",
      "datePublished": null,
      "dateModified": null,
      "author": {
        "@type": "Person",
        "name": null,
        "givenName": null,
        "email": null
      },
      "publisher": {
        "@type": "Organization",
        "name": "The Dojo MX Blog",
        "url": "https://blog.thedojo.mx",
        "logo": {
          "@type": "ImageObject",
          "width": 32,
          "height": 32,
          "url": "https://blog.thedojo.mx/icon/favicon.ico"
        }
      },
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://blog.thedojo.mx/feed.json"
      },
      "image": {
        "@type": "ImageObject",
        "width": 1200,
        "height": 400,
        "url": ""
      }
    }
</script>



  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Saltar a navegación principal</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Saltar a contenido</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Saltar a pie</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="https://res.cloudinary.com/hectorip/image/upload/v1554098427/TheDojo/the-dojo-transparent.png" alt="The Dojo MX Blog"></a>
        
        <a class="site-title" href="/">
          The Dojo MX Blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/latest">Todos los posts</a>
            </li><li class="masthead__menu-item">
              <a href="/about">Acerca de</a>
            </li><li class="masthead__menu-item">
              <a href="https://thedojo.mx">Cursos</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Alternar búsqueda</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Alternar menú</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  


  <article class="page h-entry" itemscope itemtype="https://schema.org/CreativeWork">
    
    
    
    

    <div class="page__inner-wrap">
      
        <header>
          
          

        </header>
      

      <section class="page__content e-content" itemprop="text">
        
        <div style="border: 1px solid gray; border-radius: 4px; margin: 20px; padding: 5px;">
          Visita nuestro canal de YouTube para encontrar temas similares en video:<a href="https://youtube.com/thedojomx"> The Dojo MX en YouTube </a>

        </div>
        {
  "version": "https://jsonfeed.org/version/1",
  "title": "The Dojo MX Blog",
  "description": ,
  "home_page_url": "https://blog.thedojo.mx",
  "feed_url": "https://blog.thedojo.mx/feed.json",
  "favicon": "https://blog.thedojo.mx/favicon.png",
  
  "author": {
    "name": {"name":"Héctor Patricio","avatar":"/assets/images/me.jpg","bio":"Desarrollador de software, tech lead @ HAL y The Dojo MX","uri":"https://github.com/hectorip","home":"https://til.hectorip.com/"}
  },
  
  "items": [
    
    
    {
      "id": "https://blog.thedojo.mx/2024/09/28/como-funciona-un-interprete.html",
      "url": "https://blog.thedojo.mx/2024/09/28/como-funciona-un-interprete.html",
      "title": "¿Cómo funciona un intérprete?",
      "content_html": "<p>Un intérprete es un programa que lee código fuente y se encarga de\nejecutarlo. En este artículo vamos a hablar de sus etapas y las principales\ntareas que realiza, para darte la idea de cómo funciona y si lo deseas, puedas\ntener idea de cómo hacerlo tu mismo.</p>\n\n<p>Empecemos por hablar de la diferencia con un compilador.</p>\n\n<h2 id=\"intérprete-vs-compilador\">Intérprete vs compilador</h2>\n\n<p>Ambos tipos de programas tienen la característica de recibir\ncódigo fuente, pero la diferencia está en lo que devuelven, y por lo tanto\nen las etapas que les permiten lograrlo.</p>\n\n<p><strong>Un compilador traduce</strong> el código fuente a otro lenguaje, normalmente a un\nlenguaje máquina que puede ser ejecutado por un procesador de una arquitectura\nespecífica. Pero esto no es necesariamente así, ya que la principal tarea del<br />\ncompilador es <strong>traducir</strong>. Un ejemplo es el compilador de Java:\nno compila al lenguaje de una arquitectura de procesador específica, sino a\nbytecode que puede ser ejecutado por la JVM. Si no sabes que es el bytecode,\nhablamos de él <a href=\"/2023/01/22/entendiendo-el-bytecode.html\">en este artículo</a>.</p>\n\n<p>Los compiladores tradicionales compilan el código fuente a código máquina,\nes decir, a las instrucciones que un procesador puede ejecutar directamente. Así,\nsi quieres ejecutar un programa de C o de C++ en un procesador con arquitectura\nx86, necesitas un compilador traduzca para las instrucciones de esta arquitectura.\nSi después requieres ese mismo programa para ARM, necesitas compilar de nuevo.</p>\n\n<p>Un intérprete también recibe el código fuente, pero en lugar de devolver la\ntraducción en otro lenguaje, <strong>ejecuta</strong> el código fuente directamente. A veces\neste proceso tiene como producto secundario la traducción del código fuente\nen un lenguaje intermedio, pero su objetivo principal es <strong>la ejecución</strong>.</p>\n\n<p>Ahora sí hablemos de las etapas de un intérprete.</p>\n\n<h2 id=\"las-etapas-de-un-intérprete\">Las etapas de un intérprete</h2>\n\n<p>Para ejecutar el código de un programa, podemos dividir el trabajo en varios\npasos. Para entenderlo pongamos un ejemplo. Supongamos que alguien te pide\nque hagas una tarea, por ejemplo, un trabajo escolar. Si tú fueras el intérprete,\ntendrías que hacer más o menos los siguientes pasos:</p>\n\n<ol>\n  <li>Leer las instrucciones de la tarea.</li>\n  <li>Entender claramente y sin ambigüedades lo que se te pide.</li>\n  <li>Crear un plan para ejecutar la tarea.</li>\n  <li>Ejecutar uno a uno los pasos del plan.</li>\n</ol>\n\n<p>Esos son los pasos que un intérprete hace para ejecutar un programa.</p>\n\n<ol>\n  <li><strong>Tokenización</strong>: Leer el código en fuente y transformarlo en una forma\nque pueda entender.</li>\n  <li><strong>Parsing</strong>: Convertir el código fuente en una estructura de datos que pueda\nser ejecutada. En nuestro plan esto serían los pasos 2 y 3.</li>\n  <li><strong>Ejecución</strong>: Ejecutar uno a uno los pasos del plan para lograr el resultado.</li>\n</ol>\n\n<h3 id=\"parsing-o-parseo---análisis-léxico-y-sintáctico\">Parsing o Parseo - Análisis léxico y sintáctico</h3>\n\n<p>A veces a la etapa completa de leer el código fuente y convertirlo en una\nestructura de datos que pueda ser ejecutada se le llama <strong>Parsing</strong>.</p>\n\n<p>¿Cómo puede un programa informático leer un programa y entenderlo? Lo hace de forma\nlimitada, claro, pero lo suficiente para poder ejecutar el código. Un lenguaje\nde programación es un lenguaje creado a partir de un alfabeto (un conjunto de símbolos),\nque a su vez forman palabras y estas palabras forman sentencias. Un <strong>programa</strong>, por\nlo tanto, es una secuencia de sentencias.</p>\n\n<p>Para que un intérprete “entienda” un programa, la primera etapa consiste en\nconvertir el código fuente (un conjunto de símbolos), en una secuencia de\npalabras conocidas por el intérprete. Esto es un tipo de clasificación de\nlas palabras. A la representación interna de estas palabras en el intérprete\nse le llama <strong>tokens</strong>. Debido a que en un lenguaje es muy importante el orden\nde las palabras, esta clasificación debe mantener el orden de las palabras. Como te\nimaginarás, este proceso es al que se le llama <strong>tokenización</strong>.</p>\n\n<p>Después de tener la lista de palabras conocidas, necesitamos “entenderlas”. Como un\nlenguaje tiene una estructura, esta estructura.</p>\n\n<p>Después, este conjunto de <em>tokens</em> es convertido en una estructura de datos\nllamada el <strong>Árbol de Sintaxis Abstracta</strong> o <strong>AST</strong> (Abstract Syntax Tree). Este\nproceso se llama <strong>parsing</strong>, que en inglés significa “analizar”.</p>\n\n<h3 id=\"construcción-del-ast\">Construcción del AST</h3>\n\n<p>Ya con la lista ordenada de tokens que representan el programa, tenemos que construir la\nestructura de datos que representa las operaciones que vamos a ejecutar, <strong>el\nAST</strong>.</p>\n\n<p>Esta estructura se parece a un árbol, con cada nodo representando una operación\nque a su vez puede estar compuesta de más operaciones, es una\nestructura recursiva. Por ejemplo, si tenemos un programa muy sencillo como\n<code class=\"language-plaintext highlighter-rouge\">a = 1 + 2</code>, el AST podría verse así:</p>\n\n<p><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,q_69,w_600/v1727416535/Screenshot_2024-09-26_at_23.54.41_spehcz.png\" alt=\"AST de a = 1 + 2\" class=\"align-center\" /></p>\n\n<p>En el esquema anterior puedes ver lo que más o menos es un árbol de sintaxis abstracta:\nuna estructura que nos va ayudar a ejecutar el programa. Para mi, este es el centro\ntanto de un compilador como de un intérprete, si tienes bien definido este árbol (y por\nlo tanto todas las operaciones que son posibles de representar en él), tienes hecho\nla mitad del trabajo, tanto para compilar a otro lenguaje como para ejecutar\ndirectamente el trabajo.</p>\n\n<p>Pasemos a la siguiente etapa.</p>\n\n<h3 id=\"ejecución\">Ejecución</h3>\n\n<p>Lo que sigue es lo más sencillo de entender (pero tal vez no de <em>implementar</em>): la ejecución\ndel programa. El intérprete debe tener la capacidad de actuar sobre el sistema operativo para\nejecutar las operaciones representadas en el AST. Si el intérprete corre\nen alguna otra cosa que no sea directamente el sistema operativo, por ejemplo\nen una máquina virtual, u otro programa, las acciones son diferentes, pero la\nidea es la misma: debe tener la capacidad de actuar sobre el programa en el que corra.</p>\n\n<h3 id=\"opcional-optimización\">Opcional: optimización</h3>\n\n<p>Varios de los intérpretes modernos tienen que se usan en entornos de producción, tienen\nuna etapa que no es absolutamente necesaria, pero que da una ventaja significativa en el\nrendimiento y uso común: la <strong>optimización del la ejecución</strong>.</p>\n\n<p>Estas optimizaciones pueden darse desde mejoras en el AST hasta la generación de código\nespecífico para la arquitectura del procesador en el que se ejecute el programa y ejecutarlo\ninmediatamente. Hablamos de esta última técnica.</p>\n\n<h4 id=\"compilación-just-in-time-jit\">Compilación Just In Time (JIT)</h4>\n\n<p>Una forma de optimización usada por los intérpretes y máquinas virtuales es lo\nque se conoce como <strong>Just In Time Compilation</strong>. La idea es sencilla:</p>\n\n<ol>\n  <li>Se ejecuta el código fuente original mientras se observa el comportamiento de \neste programa con un perfilador (o profiler).</li>\n  <li>Una vez que el perfilador detecta cosas que se pueden optimizar, un compilador\nespecializado en la arquitectura del procesador en el que el intérprete está\ncorriendo genera código máquina específico para es arquitectura de las partes\nque se pueden optimizar.</li>\n  <li>El código máquina optimizado se ejecuta mientras se sigue observando el\ncomportamiento del programa.</li>\n  <li>Si el programa no se comporta de la forma esperada, esta parte de la ejecución\nse cancela y se vuelve a ejecutar el código fuente original.</li>\n</ol>\n\n<p>Tenemos un artículo completo sobre JIT <a href=\"2023/01/18/compilacion-just-in-time-que-es.html\">en este enlace</a>.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>Ahora entiendes mejor cómo funcionan los intérpretes de manera general. Este\nconocimiento te puede ayudar cuando trabajes con ellos y probablemente tengas\nalgún problema directamente relacionado con su funcionamiento interno.</p>\n\n<p>También tienes el conocimiento básico para avanzar a aprender cómo hacer el tuyo\nen caso de que lo necesites. En un artículo futuro hablaré sobre cómo hacer un intérprete\nde un lenguaje de programación sencillo, para entender todavía mejor el funcionamiento.</p>\n",
      "date_published": "Sat, 28 Sep 2024 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2024/09/16/como-funciona-tensorflow.html",
      "url": "https://blog.thedojo.mx/2024/09/16/como-funciona-tensorflow.html",
      "title": "¿Cómo funciona TensorFlow?",
      "content_html": "<p><strong>TensorFlow</strong> es una de las herramientas más populares e influyentes\nen el campo de la del aprendizaje automático. En este artículo vamos a ver\nqué es exactamente y cómo funciona.</p>\n\n<h2 id=\"qué-es-tensorflow\">¿Qué es TensorFlow?</h2>\n\n<p>Siempre que hablamos de TensorFlow se dice que es una “biblioteca (o librería)\npara hacer aprendizaje automático, pero este definición no es muy\nexplícita y por eso vamos a ver <em>cómo nos permite</em> crear modelos de\naprendizaje.</p>\n\n<p>Para crear modelos de aprendizaje automático, tenemos que hacer muchos cálculos\nmatemáticos, la gran mayoría son operaciones de multiplicación de matrices.\nEstos cálculos no son eficientes en un procesador tradicional y por eso se\nrequiere de toda la ayuda que se pueda conseguir para hacerlos lo más rápido\nposible y gastando menos energía.</p>\n\n<p>Es aquí donde entra <strong>TensorFlow</strong>, una biblioteca que permite <em>representar</em> estos\ncálculos mediante grafos de cómputo y después ejecutarlos en procesadores\nespecializados como tarjetas gráficas y otros procesadores eficientes en\noperaciones matemáticas pesadas. Además, TensorFlow abstrae al usuario final (tú),\nde los detalles de implementación de muchas funciones y operaciones matemáticas\nque se usan mucho en el aprendizaje automático. Y finalmente, con su <em>API</em> de alto\nnivel, <strong>Keras</strong>, te permite crear diferentes tipos de redes neuronales sin\nque tengas que pelearte con los detalles de implementación.</p>\n\n<p>Y es aquí donde empieza lo interesante. ¿Qué es un grafo de cómputo? ¿Cómo\nllegamos a él y para qué nos sirve? Veamos.</p>\n\n<h2 id=\"grafos-de-cómputo-de-tensorflow\">Grafos de cómputo de TensorFlow</h2>\n\n<p>Para entenderlo, vamos a ver un ejemplo sencillo de un cálculo y su\nrepresentación, por ejemplo, sumemos dos números, que llamaremos X y Y.</p>\n\n<p>¿Cómo representa TensorFlow esto? Este es el grafo de cómputo que podemos ver con\nuna herramienta de análisis de TensorFlow llamada TensorBoard:</p>\n\n<p><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_250/v1726379906/Screenshot_2024-09-14_at_23.53.34_1_izykn5.png\" alt=\"Imagen de un grafo de cómputo de TensorFlow\" class=\"align-center\" /></p>\n\n<p>Puedes pensar en este grafo como una serie de nodos que representan cada uno\nuna operación sobre conjuntos de datos numéricos llamados tensores. Cuando\nejecutamos este grafo, los tensores <em>fluyen</em> por estos nodos, transformándose\nen cada uno, hasta que obtenemos el resultado final de la operación. (Los nodos\nque dicen <code class=\"language-plaintext highlighter-rouge\">Identity</code> son operaciones de copia o lectura de valores, útiles para\nel funcionamiento interno de  TensorFlow).</p>\n\n<p>La otra cosa que podemos notar hasta abajo de la gráfica son los dos nodos que\nrepresentan nuestros números simples: X scalar y Y scalar, ya que los definimos\ncomo números simples, que también pueden pensarse como tensores de una dimensión.</p>\n\n<p>Formalmente, TensorFlow te da una serie de estructuras de datos, que puedes\nir construyendo poco a poco para definir todas las operaciones que necesites hacer.</p>\n\n<p>En una red neuronal, estos grafos son mucho más complicados, pero justo ese es\nel trabajo de TensorFlow: ayudarte a definirlos y a ejecutarlos en el hardware\nmás conveniente para tu proyecto.</p>\n\n<p>Usar los grafos de cómputo de TF te permite varias cosas más:</p>\n\n<ul>\n  <li><strong>Optimización de las operaciones</strong>: TensorFlow tiene todo un sistema de optimización\nllamado <code class=\"language-plaintext highlighter-rouge\">Grappler</code>, que se encarga varias optimizaciones.</li>\n  <li><strong>Paralelización</strong>. Con las operaciones divididas, TensorFlow puede verificar\nqué operaciones son independientes y puede ejecutarlas en otros procesadores\nsi están disponibles.</li>\n  <li><strong>Exportación</strong>. Una vez teniendo las operaciones definidas en un grafo, no necesitamos\nde Python para ejecutarlas, así que TensorFlow puede ejecutarlas en otros dispositivos\ny usando otros lenguajes.</li>\n</ul>\n\n<p>Esta definición de grafos de cómputo no es la única forma de trabajar con TensorFlow,\nya que desde su versión 2.0, también permite trabajar con un modo más imperativo,\nque se siente más integrado con Python y más dinámico: la ejecución adelantada (en\ninglés: <em>eager execution</em>). Con esta forma de ejecución, las operaciones se van\nejecutando inmediatamente después de definirlas. Esto es más fácil de programar y\nde leer, pero deja poco espacio para la optimización. Es justamente como la comparación\nentre un lenguaje compilado y uno interpretado.</p>\n\n<h2 id=\"tensorflow-y-keras\">TensorFlow y Keras</h2>\n\n<p>Keras era otra biblioteca que se creó por separado, para hacer más fácil de usar\nla versión 1.0 de TensorFlow, que era bastante más verbosa de programar (por sólo\nsoportar grafos de cómputo estáticos).Sin embargo, en la versión 2.0 de TensorFlow,\nKeras se volvió parte del paquete.</p>\n\n<p>Keras te permite crear modelos de aprendizaje profundo de manera sencilla. Es la\nmanera fácil de usar TensorFlow, pero también te permite complicarte tanto como quieras\no necesites (esperamos que sea esto último). Keras usa el principio de “revelación\nprogresiva de la complejidad”, lo que significa que puedes empezar de manera muy\nsencilla e ir aprendiendo cosas conforme vayas avanzando en hacer cosas más complejas.</p>\n\n<p>Así que la forma más común de usar TensorFlow para crear tus modelos de machine\nlearning es mediante la interfaz de Keras, que además de todo te provee de\nutilidades que son de uso muy común en las redes neuronales. Por ejemplo, provee\nregularizadores, inicializadores, funciones de activación, optimizadores, y muchas\nutilidades más. Es por eso que ya casi no se concibe el uso de TensorFlow para\ncasos comunes sin usar Keras.</p>\n\n<h2 id=\"tensorflow-y-mlir\">TensorFlow y MLIR</h2>\n\n<p>MLIR es una herramienta para crear compiladores hecha por parte del mismo\nequipo que hizo LLVM, la infraestructura para compiladores que está detrás\nde la mayoría de los compiladores modernos.</p>\n\n<p>La especialidad de MLIR es hacer traducciones para arquitecturas de hardware no\ntradicionales,usando un lenguaje intermedio multi-capa al que le puedes agregar\nmás plugins para diferentes arquitecturas de ejecutores. MLIR es muy usado\npara computación de alto rendimiento, justamente la que necesitamos para\ncrear modelo de aprendizaje automático complejos en tiempos y con costos\nrazonables.</p>\n\n<p>Así que TensorFlow, aprovechando este sistema, usa MLIR para compilar los\ngrafos de cómputo y los modelos para hardware específico, para que se pueda\nobtener el mejor rendimiento posible.</p>\n\n<h2 id=\"tensorflow-y-su-relación-con-el-hardware\">TensorFlow y su relación con el hardware</h2>\n\n<p>Después de la sección anterior, es muy probable que la relación de TF con\nel hardware quede muy clara: TensorFlow ayuda a que se pueda compilar\nde mejor manera el código con los cálculos para poder ejecutarlo\nen el hardware especializado.</p>\n\n<p><strong>IF</strong> soporta gran variedad de tipos de hardware y es por eso que hasta el\nmomento es la biblioteca de machine learning con mejor soporte para\ndistribuir tus modelos en diferentes dispositivos, desde procesadores\nespecializados hasta que corran directamente en tu teléfono o navegador.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>Si quieres hacer machine learning, lo más probable es que tengas que\naprender TensorFlow, una herramienta muy útil para hacer los modelos usados\nhoy.</p>\n\n<p>Espero que lo que hablamos sobre TensorFlow en este artículo te haya ayudado\na entenderlo un poco más. En otro artículo hablaremos de su competidor\nmás directo: <strong>PyTorch</strong>.</p>\n",
      "date_published": "Mon, 16 Sep 2024 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2024/08/30/por-que-debes-leer-designing-data-intensive-applications.html",
      "url": "https://blog.thedojo.mx/2024/08/30/por-que-debes-leer-designing-data-intensive-applications.html",
      "title": "Por qué debes leer Designing Data-intensive Applications",
      "content_html": "<p>Uno de los libros más recomendados para todos los desarrolladores modernos\nes “Designing Data-intensive Applications” de <a href=\"https://martin.kleppmann.com/\">Martin Kleppmann</a>.\nEn este artículo corto vamos a hablar de por qué vale la pena leerlo.</p>\n\n<h2 id=\"quién-es-martin-kleppmann\">¿Quién es Martin Kleppmann?</h2>\n\n<p><strong>Martin</strong> es un desarrollador, investigador, escritor y profesor de ciencias\nde la computación bastante prolífico. Actualmente trabaja en la <a href=\"https://www.cst.cam.ac.uk/\">Universidad\nde Cambridge</a> y ha trabajado en empresas como\n<a href=\"https://www.crunchbase.com/organization/rapportive\">Rapportive</a>(que él fundó\ny fue comprada por LinkedIn, y también trabajó ahí).</p>\n\n<p>Es también al autor de <a href=\"https://roundrobin.pub/\">Secret Colors</a>. Un libro de\ncriptografía de llave pública y llave privada para niños, de la editorial\nRound Robin.</p>\n\n<p><strong>Kleppmann</strong> es un experto en todo lo que tiene que ver con estructuras\ny manejo de datos. En el presente (2024), su interés está en la\ncoordinación de datos entre sistemas locales, es decir, el software\nfunciona principalmente en un dispositivo que puede estar o no\nconectado a una red y después puede sincronizarse con otros sistemas\nremotos, para adquirir más funciones como respaldos o sincronización.</p>\n\n<p>Pero su trabajo más notable hasta el momento es <strong>Designing Data-intensive\nApplications</strong> (<em>DDiA</em> a partir de ahora). Veamos por qué.</p>\n\n<h2 id=\"de-qué-trata-designing-data-intensive-applications\">¿De qué trata Designing Data-intensive Applications?</h2>\n\n<p>Podemos resumir <em>DDiA</em> como un libro de diseño de software enfocado en los\ndatos y sus interacciones. Es un libro de diseño en el sentido amplio:\nabarca desde la arquitectura de software, hasta la elección de algoritmos\npara lograr las características arquitectónicas deseadas.</p>\n\n<p>El libro tiene tres grandes partes:</p>\n\n<ol>\n  <li>\n    <p>En la primera habla de los principios fundamentales de los sistemas que hacen\nuso intensivo de datos. Habla de las características arquitectónicas\nque los sistemas intensivos es datos deben tener para ser usables. También\nse sientan las formas básicas de almacenar y representar datos a diferentes\nniveles.</p>\n  </li>\n  <li>\n    <p>En la segunda parte, se habla de sistemas distribuidos y sus implicaciones\ny las dificultades que conllevan. Aquí se tratan temas como replicación,\nparticiones y transacciones. También se tratan los temas fundamentales para\ntener datos confiables: consistencia y consenso.</p>\n  </li>\n  <li>\n    <p>Aquí se habla de sistemas que derivan datos de otros datos, como índices,\ncaches y cosas similares, como puedes notar, elementos que son fundamentales\nen cualquier sistema de software serio moderno.</p>\n  </li>\n</ol>\n\n<p>Se habla de todo lo necesario para aprender el manejo\nde grandes cantidades de datos, desde las formas de modelarlos y almacenarlos,\nhasta distribuirlos y procesarlos para crear subproductos útiles.</p>\n\n<h2 id=\"el-estilo-del-libro\">El estilo del libro</h2>\n\n<p>DDiA tiene un estilo bastante relajado, nada acercado a la academia, más bien,\nes amigable y fácil de leer. Además tiene un poco de humor sutil que hará el libro\ntodavía más disfrutable.</p>\n\n<p>Para complementar, el libro tiene imágenes, algunas dibujadas a mano que\nte ayudan a ubicarte en el gran esquema de todas las ideas que trata.</p>\n\n<p>Así que si te preocupa que sea un libro denso, para nada lo es.</p>\n\n<h2 id=\"qué-beneficios-obtendrás-al-leerlo\">Qué beneficios obtendrás al leerlo</h2>\n\n<p>Si eres un desarrollador de software con experiencia, especialmente en el\nbackend, podrás profundizar tu experiencia en el entendimiento de la forma\nen la que se tratan los datos para crear sistemas confiables, escalables y\nmantenibles. Toma en cuenta que este libro, como su nombre lo dice\nestá enfocado en el <strong>diseño</strong>. Este libro te dará ideas prácticas para\naplicarlas a tus proyectos.</p>\n\n<p>Si estás en cualquier otra área del desarrollo de software, este libro te\nayudará a entender mejor cómo funciona la capa de almacenamiento de datos\nen cualquier sistema y puede ayudarte a hacerlo mejor en tu área, porque\nen todas las capas y áreas del desarrollo necesitamos tratar con datos,\na veces poco, a veces mucho.</p>\n\n<h2 id=\"conclusiones\">Conclusiones</h2>\n\n<p>Si quieres leer un libro sobre diseño de software, no puedes fallar con\n<strong>Designing Data-intensive Applications</strong>. Vale mucho más la pena que otros\nlibros de diseño de software por su profundidad y practicidad, además de\nque te va a dar de qué platicar con otros desarrolladores de software\nque pueden estar en el mismo camino de desarrollo profesional que tú.</p>\n",
      "date_published": "Fri, 30 Aug 2024 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2024/07/18/alternativas-a-git.html",
      "url": "https://blog.thedojo.mx/2024/07/18/alternativas-a-git.html",
      "title": "Alternativas a Git",
      "content_html": "<p>Git es una herramienta que se considera <em>obligatoria</em> para los desarrolladores\nmodernos por ser el programa usado para versionamiento de código usado por\nla mayoría de los proyectos.</p>\n\n<p>Pero no es ningún secreto que Git es una herramienta difícil de comprender y\nque el 90% de los desarrolladores le dan <strong>el uso más básico</strong>, temiendo romper algo\ny por eso tener que usar comandos más avanzados.</p>\n\n<p>Hablemos de por qué es así y después veamos algunas alternativas interesantes.</p>\n\n<h2 id=\"los-orígenes-de-git\">Los orígenes de Git</h2>\n\n<p>Al igual que otros sistemas de control de versiones, Git nació como soporte al\ndesarrollo de uno de los proyectos de software más importantes de todos los\ntiempos: el kernel de Linux. Fue creado por <strong>Linus Torvalds</strong>.</p>\n\n<p>Su objetivo no era ser una herramienta de uso masivo y fácil de usar, sino\ntrabajar sin las limitantes de las herramientas que existían en ese momento.\nY claramente, Linus lo creó a su manera. Algo interesante es que se llama\n“Git” porque en inglés británico es una palabra despectiva que se usa para\nllamar a alguien tonto o desagradable. Linus nombra sus proyectos como a sí\nmismo, y como cualquiera lo podría llamar así a él, decidió ponerle ese nombre\na su sistema de manejo de versiones.</p>\n\n<p><strong>Git</strong> empezó a ser usado por la comunidad de Linux en 2005 y después por otros\nproyectos Open Source, pero su éxito se disparó cuando en 2008 surgió GitHub\nque facilitó su uso. Por ser una herramienta tan útil, ahora la tenemos como el\nestándar en versionmiento de código.</p>\n\n<p>Pero no es el único sistema de control de versiones moderno, hablemos de\ndos alternativas.</p>\n\n<h2 id=\"fossil\">Fossil</h2>\n\n<p>Fossil fue creado por el autor de SQLite, <a href=\"https://www.hwaci.com/drh/\"><strong>Richard Hipp</strong></a>, y al igual que Git,nació\npara soportar a este proyecto de software libre, el principal de su Hipp.</p>\n\n<p>Al buscar un sistema de control de versiones moderno, Richard no encontró nada que lo convenciera\nal cien por ciento, por lo que decidió crear Fossil, con las siguientes características:</p>\n\n<ol>\n  <li><strong>Integración de Wiki y Tickets</strong>: Fossil tiene incluye estas herramientas a las que Hipp y\nsu equipo estaban acostumbrados.</li>\n  <li><strong>Foro y chat</strong>: Fossil está pensado para también ser el centro de conversación del proyecto.</li>\n  <li><strong>Autosync</strong>: permite que los cambios se sincronicen automáticamente sin tener que andar haciendo\nmagia con las ramas y los commits.</li>\n</ol>\n\n<p>Personalmente, me gusta mucho la idea de tener todo integrado en un mismo\nsistema, y pienso que el que sistemas como Jira y Confluence se integren directamente\ncon GitHub, Bitbucket y cosas similares, es una señal de que esta integración\nes un muy buena idea que ayuda a que el proceso de software sea más fluido.</p>\n\n<p>Puedes encontrar más información en <a href=\"https://fossil-scm.org/\">fossil-scm.org</a>,\npara instalarlo por tu cuenta. Pero también existe una versión hosteada en la\nque de manera gratuita podrás tener el servicio de Fossil, equivalente a\nGitHub: <a href=\"https://chiselapp.com/\">Chisel</a>.</p>\n\n<h2 id=\"pijul\">Pijul</h2>\n\n<p>Pijul es un sistema de control de versiones pensado para ser lo más fácil de usar.\nTiene un fundamento matemático: la teoría de parches (patch theory), lo cuál te da\ngarantías interesantes, como la facilidad de uso y la reducción de errores\ncatastróficos. Combina las dos formas principales en las que se han creado sistemas\ncontrol de versiones: los sistemas basados en spapshots (como la mayoría de los\nsistemas de control de versiones más conocidos, incluido Git) y los sistemas\nbasados en parches (como <a href=\"https://darcs.net/\">Darcs</a>, un SVC poco conocido pero\nmás fácil de usar).</p>\n\n<p>Los sistemas basados en snapshots son más rápidos pero más frágiles y difíciles de\nusar y los basado en parches son lentos. Es por eso que Pijul cobina lo mejor de ambos\ntipos de sistemas y mientras se mantiene lo suficientemente rápido sigue siendo fácil\nde usar incluso en situaciones en las que Git se vuelve complejo, como en merges,\nconflictos y cherry-picks. En un post posterior hablaremos ge Pijul.</p>\n\n<p>Puedes encontrarlo en <a href=\"https://pijul.org/\">pijul.org</a>, te recomiendo\nque si quieres probar algo fundamentalmente diferente a Git, pero con las mismas\nfunciones externas, le des una oportunidad.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>No vamos a reemplazar a Git en el corto plazo y probablmente nunca lo hagamos\npor lo extendido que está su uso (piensa en el efecto Lindsey), pero es bueno\nsaber que existen alternativas. Estas herramientas\nnos enseñan cosas interesantes sobre el desarrollo de software, como que casi\nsiempre hay más de una forma de lograr lo que queremos.\nOjalá que en el futuro, Git tome algunas de las ideas de estos proyectos y mejore su\nexperiencia de usuario.</p>\n",
      "date_published": "Thu, 18 Jul 2024 18:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2024/03/30/5-platicas-de-strageloop-que-tienes-que-ver.html",
      "url": "https://blog.thedojo.mx/2024/03/30/5-platicas-de-strageloop-que-tienes-que-ver.html",
      "title": "5 pláticas de StrageLoop que tienes que ver",
      "content_html": "<p><em>StrangeLoop</em> fue una de las mejores conferencias de tecnología del mundo\nporque en ella se tratan temas poco comunes relacionados con la\ncomputación, el desarrollo de software e incluso el arte, y lo mejor: la\ncombinación entre entras cosas.</p>\n\n<p>Si te gusta reflexionar sobre temas profundos de la computación,\nte recomiendo mucho que le eches un ojo a las pláticas de esta conferencia,\nla mayoría están disponibles en su canal de\n<a href=\"https://youtube.com/@StrangeLoopConf\">YouTube</a>.</p>\n\n<p>En este artículo te recomendaré cinco de las que me han parecido las mejores\npláticas de la conferencia. Todas están en inglés, aunque parece que puedes poner\ntraducción automática en YouTube. Empecemos.</p>\n\n<h2 id=\"el-desastre-en-el-que-estamos-metidos---joe-armstrong\">El desastre en el que estamos metidos - Joe Armstrong</h2>\n\n<p>Esta es la plática más representativa de todas las ediciones de StrangeLoop.\nSu título original es <strong>“The Mess We’re In”</strong>.\n<strong>Joe Armstrong</strong> fue el creador del lenguaje Erlang y una gran figura en la\nindustria del desarrollo de software, co-creador del lenguaje Erlang y de su máquina\nvirtual, que aún hoy siguen esando adelantados a su tiempo.</p>\n\n<p>Joe habla de lo complejo que es el ambiente en el que los desarrolladores\ntrabajamos, recordándonos la complejidad de las computadoras.\nLa plática nos hace ver por qué es un milagro que existan sistemas funcionales\ny lo frágiles que son.</p>\n\n<p>Armstrong explora varios problemas, incluído el problema medioambiental\nque las computadoras pueden generar con su consumo de energía.</p>\n\n<p>Esta imagen tiene un resumen de los problemas que menciona:</p>\n\n<p><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_1200/v1709865988/Screenshot_2024-03-07_at_20.40.20_vsidm5.png\" alt=\"Resumen de la charla de Joe Armostrong\" class=\"align-center\" /></p>\n\n<p>Si quieres cobrar conciencia o recordar la complejidad a la que nos \nenfrentamos, pero sobre todo entender  puedes ver la charla aquí: <a href=\"https://www.youtube.com/watch?v=lKXe3HUG2l4\">The Mess We’re In</a></p>\n\n<h2 id=\"deja-de-escribir-programas-muertos---jack-rusher\">Deja de escribir programas muertos - Jack Rusher</h2>\n\n<p><strong>Jack Rusher</strong> nos habla de cómo muchas de las cosas a las que ya estamos\nacostumbrados como programadores en realidad son cosas que hemos heredado de las\nlimitaciones que teníamos en el pasado, y que no hemos hecho el esfuerzo por cambiar.</p>\n\n<p>Gran parte de lo que hacemos y creemos muy normal son fósiles de que nos tienen\natados al pasado, pero ahora tenemos la capacidad de hacer muchas cosas más\ndinámicas e interesantes.</p>\n\n<p>Esta plática te puede abrir la mente respecto a nuevas formas de programar y\nte presenta entornos modernos, dinámicos y no convencionales que pueden cambiar\nla forma en la que trabajamos.</p>\n\n<p>La puedes ver aquí: <a href=\"https://youtu.be/8Ab3ArE8W3s?si=7MprB-mKxO0M4-A0\">Stop Writing dead programs</a></p>\n\n<h2 id=\"desarrollo-de-juegos-en-8-bits---kevin-zurawel\">Desarrollo de juegos en 8 bits - Kevin Zurawel</h2>\n\n<p>El desarrollo de software siempre ha estado limitado por el hardware en el\nque se va a ejecutar, pero como la mayoría de veces las computatadoras\nson mucho más poderosas de lo que necesitamos, no nos damos cuenta la mayoría\nde los desarrolladores de software.</p>\n\n<p>El desarrollo de juegos para plataformas antiguas (claro, modernas en su tiempo)\npresentaba retos muy interesantes para los desarrolladores, de los cuáles\npodemos aprender sobre todo para tener idea de los compromisos que se\ntienen que hacer para lograr cosas increíbles para la época.</p>\n\n<p>Kevin Zurawel es un experto en desarrollo de juegos y actualmente tiene una\npágina dedicada al desarrollo de juegos retro llamada <a href=\"https://famicom.party/\">Famicom.party</a>.</p>\n\n<p>Si quieres aprender más sobre el desarrollo de software en condiciones\nextremadamente limitadas puedes verla aquí:\n<a href=\"https://youtu.be/TPbroUDHG0s?si=clvg5je8GDoC4dMS\">Game Development in Eight Bits</a></p>\n\n<h2 id=\"haciendo-fáciles-las-cosas-difíciles---julia-evans\">Haciendo fáciles las cosas difíciles - Julia Evans</h2>\n\n<p>Saber explicar cosas complejas es una de las habilidades más importantes que\nse pueden tener como miembro de un equipo de desarrollo. <a href=\"https://jvns.ca/\">Julia Evans</a>\nes una de las mejores personas en el mundo en hacer esto.</p>\n\n<p><strong>“Algunas veces me tardo 10 años en aprender cosas básicas”</strong>, dice Julia en\nesta conferencia, y creo que es algo con lo que todos nos podemos\nidenfificar, porque todos nos enfrentamos con este ripo de situaciones.</p>\n\n<p>Durante la plática, Julia analiza el comportamiento de herramientas\nque usamos continuamente, nos hace ver cómo tinen un comportamiento\nno esperado y cómo podemos mejorar nuestro <strong>entendimiento</strong>.</p>\n\n<p>También nos habla de la importancia de usar herramientas que reduzcan\nla carga cognitiva mediante permitirte la inspección detallada de lo que\nestá pasando.</p>\n\n<p>Julia Evans es una gran contribuidora a la comunidad de desarrollo de\nsoftware con sus explicaciones y herramientas esclarecedoras sobre\ntemas comunes pero a la vez complejos del desarrollo de software.</p>\n\n<p>Si quieres aprender más sobre cómo simplificarte las cosas complejas \ndel desarrollo de software, puedes ver la charla aquí:\n<a href=\"https://youtu.be/30YWsGDr8mA?si=8j32cj6MKGXRQRoX\">Making hard things easy</a></p>\n\n<h2 id=\"una-probadita-de-tipos-dependientes---david-christiansen\">Una probadita de tipos dependientes - David Christiansen</h2>\n\n<p>Los sistemas de tipos siempre han sido algo que causa fuertes reacciones\nen los programadores, sea en contra o a favor. Mi teoría es que la mayoría\nde las personas que los odian es porque no han (o hemos) trabajado con un buen\nsistema de tipos.</p>\n\n<p>Hay lenguajes con sistemas de tipos muy avanzados que te permiten de verdad\nhacer cosas útiles, y los más avanzados son los que tienen <strong>sistemas de\ntipos dependientes</strong>. Estos sistemas de tipos te permiten crear diseños con\ntus programas de tal manera que el compilador puede comprobar muchas cosas\npor adelantado.</p>\n\n<p>Si nunca has escuchado de ellos, esta plática es una muy buena introducción\njunto con una colección de lenguajes que los tienen.Puedes verla aquí:\n<a href=\"https://youtu.be/VxINoKFm-S4?si=rG-zQi0P3Sl6fMSb\">A Little Taste of Dependent Types</a>.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>Aprender de los grandes presentadores y pensadores que han presentado en StrangeLoop\nes una gran idea que no tiene ningún costo. No te pierdas la oportunidad de dejar que\nte hagan pensar en cosas profundas de tu profesión, y que te lleven por lugares\nque tal vez ni siquiere habías pensado que existían.</p>\n\n",
      "date_published": "Sat, 30 Mar 2024 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2024/03/09/que-producimos-los-desarrolladores-de-software.html",
      "url": "https://blog.thedojo.mx/2024/03/09/que-producimos-los-desarrolladores-de-software.html",
      "title": "¿Qué producimos los desarrolladores de software?",
      "content_html": "<p>Para algunos, la respuesta a la pregunta del título es simplemente “<em>software</em>”,\nporque parece tan obvia que el mismo nombre lo dice. Y aunque el <strong>software</strong>\ntiene una definición concreta, en este artículo vamos a desmunazar los productos\nde un proceso de desarrollo de software. Lo que quiero que veas es que el\ndesarrollo de software no sólamente es crear programas que fucncionen, ya\nque para que el software sea efectivo tiene que <strong>evolucionar</strong>, y aquí\nentra el punto importante.</p>\n\n<h2 id=\"qué-es-un-sistema-de-software\">¿Qué es un sistema de software?</h2>\n\n<p>Un sistema de software incluye varias cosas, algunas obvias, otras no tanto.\nVamos a analizar de la más a la menos visible.</p>\n\n<h3 id=\"el-software-corriendo\">El software corriendo</h3>\n\n<p>Esta es la parte más visible y en la que muchos se quedarían. El software en\nejecución significa una computadora ejecutando instrucciones que cumplan con\nel propósito del software. Si pudiéramos hacer que la computadora ejecutara lo\nque necesitamos de mnanera mágica, sin tener que darle instrucciones a sus\ndiferentes partes, esta parte seguiría existiendo.</p>\n\n<p>Ejemplos del software en ejecución son:</p>\n\n<ul>\n  <li>Una <strong>página web</strong> mostrando la infomación que un cliente necesita</li>\n  <li><strong>Word</strong> recibiendo las instrucciones de tu teclado y mostrando lo que escribes\nen la pantalla</li>\n  <li><strong>grep</strong> buscando la expresión regular que quieres encontrar en un conjunto de documentos</li>\n</ul>\n\n<p>A veces, dependiendo del proceso pactado, no entregamos el software corriendo, sino entregamos\n<em>artefactos</em> que tienen que ser ejecutados para poner el software corriendo.</p>\n\n<h3 id=\"ejecutables\">Ejecutables</h3>\n<p>Los ejecutables son los <em>artefactos</em> que hacen que sea posible realizar las tareas que \npensamos para nuestro software. Estos artefactos pueden tomar muchas formas,\npor ejemplo, pueden ser archivos compilados .exe, empaquetados .dmg (de MacOS),\no incluso compilados que contienen instrucciones para una arquitectura de procesador\nespecífica.</p>\n\n<p>En el caso de lenguajes y plataformas interpretadas los ejecutables son\ndirectamente el código fuente, que además requieren que el usuario final tenga\nun entorno preparado en su computadora para poder correrlo.</p>\n\n<h3 id=\"código-fuente\">Código fuente</h3>\n<p>El código fuente, <em>para mi</em>, es la parte medular de los resultados de un proceso de desarrollo\nde software. Tiene la información necesaria para realizar las tareas que el software\ntiene que hacer y tras pasar por un proceso (compilación, empaquetamiento, despliegue, etc),\nse pueden producir los ejecutables que darán vida al software ejecutándose.</p>\n\n<p>El entregar el código fuente al usuario final dependerá del acuerdo comercial al que se \nllegue al inciar el proyecto (por ejemplo, le podemos entregar el puro ejecutable como hace\nla mayoría del software comercial o de fuente cerrada), pero también podríamos entregar \nel código fuente entero para que la persona que lo recibe pueda hacer cosas importantes:</p>\n\n<ul>\n  <li>Revisarlo: con el fin de que el software cumpla exactamente con lo que se desea y no tenga\nfunciones ocultas no deseadas</li>\n  <li>Extenderlo: crear nuevas funciones o mejorar las existentes</li>\n  <li>Repararlo: si se encuentra alguna falla, eliminarla</li>\n  <li>Mantenerlo: A veces, las dependencias del software van quedando desactulizadas y hay que hacer\nmodificaciones en este para que siga funcionando</li>\n  <li>Actualizarlo: llevarlo a nuevas versiones de su lenguaje o hacer que compile o produzca ejecutable\npara nuevas plataformas</li>\n</ul>\n\n<p>Como puedes ver, si quieres que tu software evolucione y se adapte a nuevas necesidades o incluso\nsimplemente para que se mantenga funcional a través del tiempo, lo ideal es que tengas\nel código fuente a tu disposición. Es aceptado que el código funete debe incluir un conjunto de pruebas\nautomáticas que permitan verificar su funcionamiento más eficientemente. Estas prubas pueden incluir:</p>\n\n<ul>\n  <li>Pruebas unitarias: las que prueban las unidades más básicas del código, como funciones o métodos</li>\n  <li>Pruebas de integración: corren el sistema como si fueran un usuario y permiten verifcar que funcione correctamente</li>\n</ul>\n\n<p>Pero el código fuente no basta para que el mantenimiento a través del tiempo sea óptimo.</p>\n\n<h3 id=\"documentación\">Documentación</h3>\n<p>Esta palabra tan temida por los desarrolladores de software en realidad es uno de nuestos\nproductos y a la vez insumos más importantes. La documentación es información sobre el \nsoftware puesta en un lugar persistente.</p>\n\n<p>Esta documentación debe incluir por lo menos:</p>\n\n<ol>\n  <li>Explicación de lo que el sistema hace. Es lo que le llamaríamos “los requerimientos”.</li>\n  <li>Diseño del sistema: Se habla de cómo está construido el sistema, por qué se pensó de esta forma y cómo\neso cumple con lo que se requería. Incluye la arquitectura a diferentes niveles y el registro de las decisiones\njunto con su justificación.</li>\n  <li>Documentación técnica. En esta parte se habla de la tecnología usada: los lenguajes usados, las plataformas\nsobre las que corre, las bases de datos, los sistemas operativos etc. Además una buena idea es incluir\nlas bases sobre las que se escogieron estos elementos.</li>\n  <li>Documentación para desarrolladores. Esta es la documentación que habla de lo que un desarrollador\ntiene que hacer para seguir desarrollando el proyecto o para hacer que el software se ejecute, sea \ndesplegarlo en un sistema de usuario final o producir los ejecutables. Esta documentaión incluye la \ndocumentación del código en el que se describe su funcionamiento interno y el diseño que tiene.</li>\n  <li>Manual de usuario. Opcional, pero dependiendo de la complejidad de las fucniones que el softwae haga\ny de su intefaz, puede convertise en un elemento absolutamente necesario. En este se describen\na detalle las cosas que el usuaio puede hacer y las consecuencias de estas acciones.</li>\n</ol>\n\n<p>Hasta aquí se quedarían algunos, ¿pero podemos ir más allá? Sobre todo pensemos en que, para que el software\nsea exitoso, necesita evolucionar. ¿Quién crea nuevo código?</p>\n\n<h3 id=\"un-equipo-funcional\">Un equipo funcional</h3>\n<p>En teoría, con todo lo anterior cualquier desarrollador de software podría tomar un proyecto y seguirlo evolucionando,\npero esta teoría se queda lejos de la práctica por varias razones. La primera es que necesariamente\ntodos los artefactos anteriores van a tener defectos o estar incompletos, por lo que para que un nuevo\nequipo o desarrllador tome el proyecto requerirá hacer lo que llamamos <strong>“arqueología de software”</strong>, intentando completar\ny entender las decisiones no documentadas y todas las demás partes de información faltantes.</p>\n\n<p>Aún si los artefactos producidos estuvieran completos, el que un nuevo equipo tome el proyecto requiere tiempo y\nesfuerzo para estudiarlos y empezar a producir nuevas funciones o a corregir errores. Si queremos que \nel proceso de desarrollo continue rápidamente, lo mejor es que el equipo que lo desarrolló lo siga evolucionando.</p>\n\n<p>Los mejores proyectos de software incluyen a un grupo de personas  que conocen la forma de desarrollo más \neficiente, las partes delicadas del proyecto, los fallos pendientes por componer, y las cosas que le faltan.</p>\n\n<p>Además, este grupo de personas tienen una forma de trabajar y de coordinación eficiente que puede ayudarlos\na ser más productivos.</p>\n\n<p>Con esto podemos concluir que el resultado del proceso de desarrollo de software no es solo una serie de artefactos,\nsino que también puede inlcuir a un equipo de personas que sereian los más adecuados para seguirlo desarrollando.</p>\n\n<p>Pero hablemos de un elemento no tangible.</p>\n\n<h3 id=\"nuevo-conocimiento\">Nuevo conocimiento</h3>\n\n<p>Siempre que alguien escribe software, su mente se modifica de tal manera que volver a su estado\nanterior es imposible. Este nuevo estado en el que la mente del programador se encuentra\ncontine información sobre el problema que acaba de resolever, de tal manera que si \ndesapareciera todo el código fuente y toda la documentación junto con los ejecutables, para \neste desarrollador no sería tan desastroso porque volver a producrilos le tomaría una \nfracción del tiempo que ya gastó en hacerlos.</p>\n\n<p>Esta modificación en la mente de las personas es un elemento no visible pero sin duda valioso,\nque permite crear cada vez software más complejo y con mayores capacidades.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n<p>El proceso de desarrollo de software no sólamente produce software corriendo o ejecutables.\nNuestro trabajo produce otras cosas de valor de las que deberíamos ser conscientes y buscar \noptimizar, evitando la simpleza de pensar que lo único que vale es el software corriendo, que cómo puedes ver en este\nartíulo, es una parte mínima de todo el valor que puedes producir, eso sin contar el valor que \ntu software produce al ser ejecutado por las personas que le pueden sacar provecho.</p>\n",
      "date_published": "Sat, 09 Mar 2024 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/12/14/engines-de-javascript-y-sus-usos.html",
      "url": "https://blog.thedojo.mx/2023/12/14/engines-de-javascript-y-sus-usos.html",
      "title": "Engines de JavaScript y sus usos",
      "content_html": "<p>Ya hemos explicado antes qué es un <a href=\"/2020/05/17/que-es-un-engine-de-javascript.html\">engine de JavaScript</a>. Como resumen, es el programa encargado de correr tus programas de JavaScript: recibe tus archivos o código de JS y ejecuta las acciones en el sistema operativo en el que se está ejecutando.</p>\n\n<p>Estos engines actualmente son programas complejos que no solamente interpretan el código, sino que lo analizan y compilan a código máquina para que sea más eficiente su ejecución.</p>\n\n<p>En este artículo vamos a hablar de algunos engines de JavaScript populares y en dónde puedes encontrar su código o sus ejecutables para que los puedas usar. Pero antes hablemos de la utilidad que puede tener un motor de JS fuera de un navegador.</p>\n\n<h2 id=\"usos-de-un-motor-de-js\">Usos de un motor de JS</h2>\n\n<p>A veces, queremos darle a nuestros usuarios una manera de ejecutar código de manera arbitraria o de modificar el sistema mediante instrucciones que ellos mismos metan en nuestras plataformas o programas. En vez de crear todo un lenguaje o de implementar nuestro propio compilador o intérprete, podemos embeber o incluir un motor de un lenguaje conocido y con implementaciones robustas y disponibles para su uso. <strong>Esta es exactamente el caso de uso que los engines de JS que podemos encontrar implementados cumplen</strong>.</p>\n\n<p>Un ejemplo de quién usa engine fuera de un navegador es un proyecto que ha cambiado el mundo del desarrollo web y que es muy popular: <strong>NodeJS</strong>, es un entorno de ejecución de JavaScript que se basa en el motor V8 de Google y que sirve principalmente para crear aplicaciones web. Mediante el uso de V8, puedes crear servidores web usando JavaScript, y Node se encarga de envolverlo para que puedas usar todas funcionalidades que te ofrece el sistema operativo en el que se está ejecutando.</p>\n\n<p>Otro ejemplo de uso de un motor de JS fuera de un browser es <a href=\"https://www.mongodb.com/docs/manual/release-notes/3.2-javascript/\">MongoDB</a>, que usa el motor SpiderMonkey de Mozilla para ejecutar código de JavaScript en sus bases de datos.</p>\n\n<p>Si buscas más, puedes encontrar un montón de ejemplos en los que un motor de JavaScript es usado fuera de un navegador.</p>\n\n<h2 id=\"engines-de-javascript\">Engines de JavaScript</h2>\n\n<p>Ahora sí, hablemos de los diferentes motores de JavaScript en orden de popularidad.</p>\n\n<h3 id=\"v8\">V8</h3>\n\n<p>Es el motor desarrollado por Google, usado principalmente en Chrome, NodeJS y Deno. Actualmente también está detrás de Microsoft Edge. Es el más popular y el que más desarrollo tiene. Está escrito en C++ y ha tenido varias iteraciones, mejorando los componentes internos. Además cuenta con un JIT compiler que lo hace eficiente en la mayoría de los casos. Otra ventaja de V8 es que puede ejecutar también <a href=\"https://webassembly.org/\">WebAssembly</a>.</p>\n\n<p>Si quieres desarrollar algo que tenga soporte completo del estándar ECMAScript, sea estable y tenga buen rendimiento, con V8 no te puedes equivocar. La desventaja es que tendrás que usarlo como un biblioteca de C++, o por lo menos customizarlo un poco para que se adapte a tus necesidades y hagas los puentes con tu programa, plataforma o lenguaje de programación, tal como Deno (que está escrito en Rust).</p>\n\n<p>Puedes ver su blog técnico aquí: <a href=\"https://v8.dev/blog\">https://v8.dev/blog</a>. Además, si quieres aprender cómo hacer complejos o quieres contribuir, su código fuente está disponible de manera abierta en GitHub: <a href=\"https://github.com/v8/v8\">V8 Github</a>.</p>\n\n<h3 id=\"spidermonkey\">SpiderMonkey</h3>\n\n<p>Este motor de JS está desarrollado por Mozilla y es usado en Firefox, Servo y en MongoDB. Igual que V8, está escrito en C++, pera también incluye partes en <a href=\"https://www.rust-lang.org/\">Rust</a> e incluso en JavaScript. A parte de ejecutar JS, también puede ejecutar WebAssembly.</p>\n\n<p>Si tienes un proyecto en Rust o C++, SpiderMonkey puede ser una gran opción. La principal diferencia con V8 es la velocidad de desarrollo, puedes esperar menos cambios que puedan romper tu código, pero también menos mejoras y actualizaciones, que con V8.</p>\n\n<p>Puedes ver su documentación aquí: <a href=\"https://firefox-source-docs.mozilla.org/js/index.html\">SpiderMonkey</a>.</p>\n\n<h3 id=\"chakracore\">ChakraCore</h3>\n\n<p>Este motor fue desarrollado por Microsoft y es usado en Chakra (que es un <em>runtime</em> de JS incluye otras cosas más como API’s para poder darle más funcionalidad al engine), que a su vez era usado en Edge y Windows (Edge ahora usa Chromium).</p>\n\n<p>ChakraCore está escrito en C++ y C, y presenta una API en C para usarlo en proyectos compatibles con esto. Puede ser compilado para cualquier sistema operativo de 64 bits, pero solamente para Windows para procesadores ARM y de 32 bits. Ya que Microsoft lo dejó de usar, se piensa ahora completamente como un proyecto a cargo de la comunidad.</p>\n\n<p>En las pruebas que yo hice, fue el más fácil de compilar y usar, pero si te fijas en su repositorio, no tiene un desarrollo tan activo.</p>\n\n<p>Puedes ver su documentación aquí: <a href=\"https://github.com/chakra-core/ChakraCore\">ChakraCore</a>. Nota como no está bajo el nombre de chakra-core y no en el repositorio de Microsoft.</p>\n\n<h3 id=\"javascriptcore\">JavaScriptCore</h3>\n\n<p>Este es el motor desarrollado por Apple, usado en Safari principalmente. Al igual que los otros, está escrito en C y C++, pero tiene bindings para Objective-C, Swift y C. Así, se puede usar para darle la capacidad a aplicaciones de iOS y macOS de ejecutar código de JS, pero si tienes algo más en C en que puedas envolverlo, sin ningún problemas puedes usarlo en cualquier proyecto.</p>\n\n<p>Puedes ver su documentación aquí: <a href=\"https://developer.apple.com/documentation/javascriptcore\">JavaScriptCore</a>.</p>\n\n<h3 id=\"rhino\">Rhino</h3>\n\n<p>También es desarrollado por Mozilla, pero esta vez escrito en Java. Rhino viene incluido en algunas distribuciones de Java. Así que si tienes un proyecto en Java, Rhino es una gran opción, pero debes estar atento a las características que soporta, porque parece que su desarrollo no está tan activo.</p>\n\n<p>Puedes ver su documentación aquí: <a href=\"https://github.com/mozilla/rhino\">Rhino</a>.</p>\n\n<h2 id=\"engines-ligeros\">Engines ligeros</h2>\n\n<p>Existen una gran variedad de engines de JS más ligeros, no con todas las características de los que acabamos de ver, con la idea de que los puedas embeber en proyectos que dispongan de pocos recursos, tal como sistemas embebidos o proyectos de IoT. Otro buen caso de uso para estos es cuando no requieras las funcionalidades completas de JS sino simplemente soporte básico en tu programa.</p>\n\n<p>Aquí una lista de los más populares:</p>\n\n<ul>\n  <li><a href=\"https://bellard.org/quickjs/\">QuickJS</a>: Desarrollado por Fabrice Bellard, quien también creó <a href=\"https://www.ffmpeg.org/\">FFmpeg</a>. QuickJS sólo pesa 210Kb en su forma más sencilla.</li>\n  <li><a href=\"https://duktape.org/\">Duktape</a>: También es muy pequeño, promete funcionar en sistemas con 160Kb de memoria y 64Kb de RAM. Está escrito en C y soporta la ES2015 o ES6.</li>\n  <li><a href=\"https://github.com/espruino/Espruino\">Espruino</a>. Corre en sistemas con 128Kb de memoria y 8Kb de RAM. Está escrito también en C y está pensado para darle soporte a sus propias tarjetas de microncontroladores de bajo consumo, programadas en JS. Pero aún así, lo puedes usar en cualquier proyecto que sea compatible con su API de C o correrlo directamente.</li>\n</ul>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>Espero que esta lista de motores de JavaScript te sea útil para conocer más del ecosistema del que muchos sólo somos usuarios y para entender que JS te puede servir para darles superpoderes a tus sistemas y plataformas. Ya hay muchos proyectos que te permiten hacerlo reduciendo el trabajo al mínimo.</p>\n",
      "date_published": "Thu, 14 Dec 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/12/13/mojo-un-lenguaje-prometedor.html",
      "url": "https://blog.thedojo.mx/2023/12/13/mojo-un-lenguaje-prometedor.html",
      "title": "Mojo 🔥: un lenguaje prometedor",
      "content_html": "<p><a href=\"https://www.nondot.org/sabre/\" target=\"_blank\">Chris Lattner</a>, uno de los creadores de <a href=\"https://llvm.org\">LLVM</a> y <a href=\"https://www.swift.org/\">Swift</a>, ha estado desarrollando un nuevo lenguaje basado en la sintaxis de <strong>Python</strong> pero pensado para atacar su punto más débil: <strong>la velocidad de ejecución</strong>.</p>\n\n<p>Este lenguaje se llama <a href=\"https://modular.com/mojo\">Mojo</a>, y está siendo publicitado como un lenguaje para hacer aplicaciones de <strong>inteligencia artificial</strong>. Como ya dijimos, su enfoque principal está en ser un lenguaje que produzca programar eficientes, por lo que puede ser usado para cualquier aplicación que requiera alto rendimiento o hacer una gran cantidad de cálculos, justo como las aplicaciones de <em>machine learning</em>.</p>\n\n<p>En este artículo veremos el motivo detrás de su nacimiento, sus características y analizaremos si te conviene aprenderlo o deberías buscar alguna otra alternativa. Primero, entendamos la fundación de Mojo.</p>\n\n<h2 id=\"mlir---representación-intermedia-multi-capa\">MLIR - Representación intermedia multi-capa</h2>\n\n<p>LLVM es un proyecto que se define como infraestructura para la construcción de compiladores. Imagínate que es como un framework para construir compiladores. Muchos de los lenguajes actuales están creados usando este proyecto. Por ejemplo <a href=\"https://rust.org\">Rust</a>, Swift y <a href=\"https://julialang.org\">Julia</a> están construidos sobre LLVM.</p>\n\n<p>Una de las partes que hace muy útil a LLVM es su <strong>representación intermedia</strong>. Esta representación intermedia permite que los diferentes lenguajes de programación que funcionan sobre él se aprovechen de las optimizaciones que LLVM hace sobre el código intermedio. El flujo del código es el siguiente:</p>\n\n<ol>\n  <li>El código fuente es compilado a código intermedio (<strong>IR</strong>).</li>\n  <li>El <strong>IR</strong> es optimizado.</li>\n  <li>El <strong>IR</strong> es compilado a código de máquina.</li>\n</ol>\n\n<p>De hecho, se dice que Swift es sólo azúcar sintáctico sobre la representación intermedia de LLVM, es decir, que se parece mucho a esta representación intermedia y aprovecha sus características.</p>\n\n<p>MLIR (Multi-layer Intermediate Representation o Representación intermedia multi-capa) es una representación intermedia de más alto nivel que la representación intermedia tradicional. No en el sentido de que sea más fácil de entender para los humanos, sino que en vez de mapearse directamente con una infraestructura de compilación, representa un modelo más abstracto que puede ser mapeado a diferentes infraestructuras de compilación, de manera especializada para cada una de ellas. Así permite que un mismo código fuente pueda ser compilado para diferentes ejecutores, como GPU’s, TPU’s, CPU’s, etc, sin tener que crear una nueva representación intermedia o crear nuevo código fuente.</p>\n\n<h2 id=\"entra-mojo-\">Entra Mojo 🔥</h2>\n\n<p>Toda esta explicación anterior es para entender que Mojo es para MLIR lo que Swift es para LLVM. Aprovecha gran parte de las características de MLIR para crear un lenguaje de programación que pueda usar ejecutores especializados en cómputo de alto rendimiento como GPU’s y TPU’s, pero presentando una sintaxis más amigable para los humanos, a diferencia de CUDA, o C++, por ejemplo.</p>\n\n<p>Mojo te ayuda aprovechar el paralelismo masivo de los GPU’s sin tener que preocuparte por aprender un nuevo lenguaje o siquiera tener que pensar en dónde finalmente se ejecutará tu programa.</p>\n\n<p>Ya que Python es la lingua franca del mundo de la inteligencia artificial, Mojo inicialmente fue pensado como una extensión de Python (lo que llamaríamos un superconjunto de Python), en el sentido de que todo el código válido en Python es código válido en Mojo, muy parecido a la relación que existe entre la sintaxis de TypeScript y JavaScript.</p>\n\n<h2 id=\"características-de-mojo\">Características de Mojo</h2>\n\n<p>Las pruebas iniciales de Mojo revelan que puede ser hasta <strong>68,000</strong> veces más rápido que Python en ciertas tareas (sí, leíste bien <strong>sesenta y ocho mil</strong>), mientras que C++ llega a ser <strong><em>sólo</em> 5,000</strong> veces más rápido. Claro, esto no habla muy bien de Python, pero debes pensar en que su objetivo no es ser un lenguaje de alto rendimiento, sino un lenguaje de alto nivel y fácil de usar.</p>\n\n<p>Mojo quiere aprovechar la facilidad de uso de Python junto con su ecosistema de bibliotecas y desarrollos para hacer un ecosistema de desarrollo de inteligencia artificial más rápido y fácil de usar. Una de las primeras diferencias con Python es que es un lenguaje <strong>compilado</strong>.</p>\n\n<p>Hablemos de algunas de las cosas que Mojo le aumenta a Python:</p>\n\n<ol>\n  <li>\n    <p><strong>Sistema de tipos progresivos</strong>. Te permite usar el sistema de tipos tanto como lo necesites (por eso es progresivo). Pero debes tener en cuenta que los tipos te sirven tanto para verificar que el programa es correcto como <strong>para optimizar el código que se genera</strong>.</p>\n  </li>\n  <li>\n    <p><strong>Abstracciones sin costo</strong>. Muy parecido a Rust, Mojo te da acceso a usar abstracciones de alto nivel que no incrementan el costo de ejecución.</p>\n  </li>\n  <li>\n    <p><strong>Seguridad de memoria</strong>. Tiene un sistema de seguridad de memoria parecido al de Rust, mediante la pertenencia y el préstamo de referencias (ownership + borrow checker).</p>\n  </li>\n  <li>\n    <p><strong>Metaprogramación</strong>. Te permite crear código parametrizado que se transforma en tiempo de compilación.</p>\n  </li>\n</ol>\n\n<p>Como puedes ver, Mojo es un lenguaje muy interesante que aprovecha las características que hemos aprendido en lenguajes modernos que han sido útiles para crear mejores sistemas. El uso de MLIR es la base de su rendimiento, que permite que los programas que generas se puedan optimizar para ejecutores de diferentes tipos, incluidos algunos masivamente paralelos.</p>\n\n<h2 id=\"deberías-aprenderlo\">¿Deberías aprenderlo?</h2>\n\n<p>Mojo es un lenguaje que servirá tanto para hacer aplicaciones de IA como herramientas de bajo nivel para sistemas operativos, por lo que yo lo pensaría como un <strong>lenguaje de programación de sistemas de última generación</strong> que permitirá hacer cosas muy interesantes en el futuro.</p>\n\n<p>Ahora mismo (Diciembre de 2023), es un lenguaje de código cerrado, es decir, su desarrollo está llevado por una empresa privada y el código fuente no está disponible para que otros lo vean o contribuyan. Según Lattner, esto permite inicialmente que se se avance de manera más efectiva, en lo que personalmente estoy de acuerdo. Se espera que Mojo sea de código abierto cuando alcance el nivel de madurez necesario.</p>\n\n<p>Además, está en una etapa muy temprana de su desarrollo en la que ni siquiera cumple con todas las características de Python, por lo que todo lo que aprendas ahora sólo será un vistazo que te puede ayudar a definir si lo quieres usar cuando salga su versión lista para producción.</p>\n\n<p>Personalmente, creo que es un buena inversión del tiempo si estás metido en crear aplicaciones de alto rendimiento, programación de sistema o quieres crear sistemas que usen inteligencia artificial como una de sus características principales. Por el contrario, para desarrollo web creo que tomará un poco más de tiempo en serte útil.</p>\n\n<p>Otro caso para el que puede serte útil es para aprender las características de los lenguajes modernos, como los tipos progresivos o la seguridad de memoria mediante el préstamos de referencias.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>Mojo es un lenguaje interesante, muy prometedor y que está en la raya de la innovación en creación de lenguajes y características modernas. Si eres curioso y te gustan en general los lenguajes de programación, creo que es una gran opción para empezar a aprender y tal vez en el futuro recoger los beneficios si cumple con sus promesas.</p>\n",
      "date_published": "Wed, 13 Dec 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/12/09/que-es-real-time-en-sistemas-computacionales.html",
      "url": "https://blog.thedojo.mx/2023/12/09/que-es-real-time-en-sistemas-computacionales.html",
      "title": "¿Qué es Real Time en sistemas de software?",
      "content_html": "<p>A veces, los programadores usamos muy libremente los conceptos. Uno de ellos es el de Real Time. En este artículo vamos a hablar de lo que significa realmente el término, lo vamos a definir claramente y sobre todo aprenderemos a diferenciar los distintos niveles o garantías que debe ofrecer un sistema en tiempo real.</p>\n\n<h2 id=\"qué-es-real-time\">¿Qué es Real Time?</h2>\n\n<p>Un sistema que provee garantías de Tiempo Real o Real Time es aquel que <strong>garantiza</strong> que una tarea se va a ejecutar en un tiempo determinado. Esto es muy importante en sistemas críticos, como los que se usan en la industria automotriz, aeroespacial, médica, en los que ejecutar NO ejecutar una tarea en un tiempo determinado puede tener consecuencias catastróficas.</p>\n\n<p>Pero también hay sistemas en los que es <em>deseable</em> que una tarea se ejecute antes de cierto tiempo, por ejemplo, cuando estamos transmitiendo información en forma de audio o video de algo que es importante que se comunique rápidamente. Así, podemos hacer llamadas o videollamadas que son útiles.</p>\n\n<p>Los dos casos anteriores, nos dan la pauta para por lo menos distinguir dos tipos de sistemas Real Time:</p>\n\n<ol>\n  <li>\n    <p><strong>Hard Realtime</strong>. Son sistemas que deben garantizar con un 100% de certeza que la tarea que quieres que hagan se va a realizar <em>máximo</em> en el tiempo qu especifica el mismo sistema. En estos sistemas no hay margen de error, si el sistema no puede cumplir con el tiempo especificado se considera que falló, por lo que no es seguro operarlo. Este tipo de sistemas se usan en ocasiones en las que es muy muy importante que la tarea en cuestión se ejecute lo más rápido posible, normalmente porque el no hacerlo o tener un retraso podría tener consecuencias mortales o catastróficas.</p>\n  </li>\n  <li>\n    <p><strong>Soft Realtime</strong>. Los sistemas de este tipo, garantizan que <em>mínimo</em> cierto porcentaje de las veces que un sistema se ejecute, la tarea se va a ejecutar en el tiempo especificado, normalmente lo más rápido posible. A diferencia de los sistemas de tiempo real fuerte, puede que cierto número de acciones tarden un poco más de lo esperado, pero esto no llevaría a pensar que el sistema falló. Este tipo de sistemas se usa para cosas no tan críticas pero en las que es deseable que la tarea está lista lo más rápido posible, por ejemplo, en juegos, aplicaciones de videoconferencia, sistemas de coordinación de trabajo (Figma, Google Docs, etc).</p>\n  </li>\n</ol>\n\n<h2 id=\"cómo-puedes-lograr-un-sistema-real-time\">Cómo puedes lograr un sistema Real Time</h2>\n\n<p>Lo primero en que debemos pensar es qué tipo de realtime necesitamos. Como te puedes imaginar, lograr un sistema Hard Realtime es mucho más complicado que lograr un sistema Soft Realtime. Esto es porque en el primero, no hay margen de error, mientras que en el segundo, podemos relajarnos un poco.</p>\n\n<p>Algunas sugerencias para lograr sistemas realtime son:</p>\n\n<ol>\n  <li>\n    <p><strong>Usa un ecosistema que esté pensado para esto</strong>. Hay lenguajes de programación y plataformas que mediante diferentes técnicas te ayudan a lograr funcionalidades real time, pero normalmente se queden al nivel de aplicaciones de soft realtime. Algunos ejemplos son lenguajes que aprovechan la concurrencia y controlan efectivamente el tiempo de ejecución de tu programa o te permiten hacerlo de manera sencilla, como: Go, Elixir y NodeJS.</p>\n  </li>\n  <li>\n    <p><strong>Usa un lenguaje de programación que te de control granular sobre el tiempo de ejecución</strong>. Con esto principalmente me refiero a una cosa: que no tengan recolector de basura. Recuerda que este proceso puede parar el programa por un tiempo no conocido y de manera no controlada, por lo que si quieres lograr aplicaciones hard realtime, será una tarea extremadamente difícil. Lamento decírtelo, pero si quieres asegurar que tu programa se comporte como deseas, vas a tener que controlar casi cada detalle, en lenguajes como C, C++ o Rust.</p>\n  </li>\n  <li>\n    <p><strong>Asegura la fiabilidad de tu infraestructura</strong>. Para que un sistema realtime sea confiable, vas a necesitar que la infraestructura sea resistente a fallas. Esto lo logras eliminando puntos únicos de fallo, es decir, aquellos puntos de tu programa o infraestructura que si fallan hacen que todo el sistema se caiga. Para lograr esto tienes que pensar en arquitecturas distribuidas, redundancia de datos, escalamiento automático, etc.</p>\n  </li>\n</ol>\n\n<p>Espero que estos consejos te sirvan y si se me está pasando alguno, por favor, déjame un comentario.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>Conocer los diferentes niveles de servicio que un sistema puede garantizar y comprender las características que presentan, te puede ayudar a tomar en serio la responsabilidad de diseñar un sistema realtime y la dificultad que implica.</p>\n\n<p>Piensa profundamente si realmente se requiere un sistema con estas características (sobre todo si es hard realtime) y si es así, toma en serio la responsabilidad de diseñarlo y construirlo, espero que los consejos que te di en este artículo te sirvan para lograrlo.</p>\n",
      "date_published": "Sat, 09 Dec 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/08/28/las-tres-garantias-de-seguridad-de-un-hash.html",
      "url": "https://blog.thedojo.mx/2023/08/28/las-tres-garantias-de-seguridad-de-un-hash.html",
      "title": "Las tres garantías de seguridad de un hash",
      "content_html": "<p>En este artículo profundizaremos sobre las garantías de seguridad mínimas que una función hash debe cumplir para ser criptográficamente segura. En un artículo anterior: <a href=\"/2021/12/02/algoritmos-criptograficos-que-es-un-hash.html\">¿Qué es un hash?</a> ya hablamos más detalladamente de la definición y de los algoritmos que puedes usar aún hoy de manera segura.</p>\n\n<p>Empecemos por una pequeña definición de lo que es una función hash en la criptografía.</p>\n\n<h2 id=\"qué-es-un-hash\">¿Qué es un hash?</h2>\n\n<p>Un hash es una función que te devuelve un valor de tamaño fijo independientemente del tamaño de la entrada, esto implica una compresión de datos. Las funciones hash que son usadas en criptografía, tienen la característica de entregar valores completamente <em>impredecibles</em>, tanto para un humano como para una computadora. Es decir que no hay manera de saber qué valor va a entregar una función hash para un valor dado si no le has pasado ese valor antes.</p>\n\n<p>Lo anterior no quiere decir que las funciones hash devuelvan algo diferente cada vez que las ejecutas, sino que para un valor dado, siempre devuelven el mismo resultado, y aquí es donde radica su utilidad.</p>\n\n<p>Un hash perfecto se comportaría como un generador de valores aleatorios, pero debido a lo que hemos dicho anteriormente, deben ser <strong>deterministas</strong> al mismo tiempo que <strong>impredecibles</strong>.</p>\n\n<p>Para medir la seguridad de una función hash, se usan tres pruebas, que se conocen como las garantía de seguridad de un hash.</p>\n\n<p>Estas garantías son:</p>\n\n<ol>\n  <li>Resistencia a la primera preimagen</li>\n  <li>Resistencia a la segunda preimagen</li>\n  <li>Resistencia a la colisión</li>\n</ol>\n\n<p>Cada una de estas garantías se refiere a un tipo de ataque que se puede hacer a una función hash. Vamos a explicarlas pero antes aclaremos algunos términos.</p>\n\n<h2 id=\"imagen-y-preimagen\">Imagen y preimagen</h2>\n\n<p>En matemáticas, una función es una relación entre dos conjuntos de valores, uno de entrada y uno de salida. En la mayoría la de las funciones matemáticas comunes, cada valor de entrada tiene un único valor de salida.</p>\n\n<p>Tomemos como ejemplo: \\(f(x) = x + 1\\), esta función toma un valor \\(x\\) y le suma \\(1\\), por lo que cada valor de \\(x\\) tiene un único valor de salida, porque sabemos que un número cualquiera tiene solamente un sucesor.</p>\n\n<p>Pero no todas las funciones se comportan así, por ejemplo: \\(f(x) = x^2\\). En esta función el valor 4 puede ser generado por dos valores de entrada diferentes: \\(2\\) y \\(-2\\).</p>\n\n<p>Cuando vemos una función así no es común que nos definan el conjunto de entrada, así que asumimos que el conjunto de entrada o <strong>dominio</strong> es el conjunto de los números reales, y el conjunto de salida o <strong>codominio</strong> es el conjunto de los números reales.</p>\n\n<p>Pensemos en el dominio y codominio como conjuntos amplios en los que los valores de entrada y salida <em>podrían estar</em>. La <strong>imagen</strong> de una función es el conjunto de valores que <em>están</em> en el codominio, es decir, los valores que la función <em>puede</em> devuelve. La <strong>preimagen</strong> es el conjunto de valores que <em>pueden</em> ser entrada de la función.</p>\n\n<p>En términos prácticos para nosotros los programadores, la imagen es casi equivalente al codominio, y la preimagen es el dominio.</p>\n\n<p>Esta imagen sacada de Wikipedia lo ilustra un poco mejor:</p>\n\n<p><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_600/v1693144037/Codomain2_kzda4n.svg\" alt=\"Imagen vs Codomino\" class=\"align-center\" /></p>\n\n<p>La imagen es el área amarilla, mientras que Y es el codominio, y X es el dominio. Lo último que nos hace falta saber es que aunque imagen y preimagen son los conjuntos de entradas y salidas del algoritmo, también nos podemos referir así a un valor individual de este conjunto.</p>\n\n<p>Apliquemos los aprendido al ejemplo de la función \\(f(x) = x^2\\). El dominio es el conjunto de los números reales, y el codominio también es el conjunto de los números reales. La imagen es el conjunto de los <strong>números reales positivos que tengan una raíz cuadrada</strong>, y la preimagen es el conjunto de los números reales. Un ejemplo concreto: para el valor <code class=\"language-plaintext highlighter-rouge\">4</code> considerado como resultado de la función o <strong>imagen</strong>, tendría <em>dos</em> preimágenes: \\(2\\) y \\(-2\\).</p>\n\n<p>Ahora sí, hablemos de la primera garantía de seguridad de un hash.</p>\n\n<h2 id=\"resistencia-a-la-primera-preimagen\">Resistencia a la primera preimagen</h2>\n\n<p>Aquí debes poner atención a los valores <em>que se dan</em> para hacer la prueba de seguridad. Presta atención a cuando se dice “dado un valor”, estos son la valores que suponemos que ya se conocen.</p>\n\n<p>En la primera garantía es: <strong>Dada</strong> una <em>imagen</em> es computacionalmente inviable encontrar una <em>preimagen</em> que la genere.</p>\n\n<p>En palabras de programadores: Dado un hash, es computacionalmente inviable encontrar un valor que al ser pasado a la función hash, genere ese hash.</p>\n\n<p>¿Por qué decimos <strong>un</strong> valor que genere ese hash y no <strong>el</strong> valor que genere ese hash? Porque para un valor de salida, puede haber más de un valor de entrada que lo genere. Especialmente para los hashes, su conjunto de valores posibles es infinito: todas las combinaciones de bits posibles de cualquier tamaño.</p>\n\n<p>¿Cuál es el tamaño del conjunto de posibles salida? Eso depende del hash usado y su número de bits. Por ejemplo, el SHA-256 genera hashes de 256 bits, por lo que su conjunto de posibles valores es \\(2^{256}\\), que es un número muy grande, pero no infinito, por lo que es posible que dos valores generen el mismo hash. Cada uno de esos valores sería <em>una preimagen</em> de un hash dado.</p>\n\n<p>Entonces ya tenemos todo el escenario: nos han dado un hash y tenemos que encontrar uno de los infinitos valores que pueden producir ese hash, una preimagen.</p>\n\n<p>Pues bien, para un hash criptográficamente seguro esta operación debe de ser imposible de realizar de manera más eficiente que usando fuerza bruta, es decir, probando todos los valores posibles hasta encontrar uno que genere el hash dado.</p>\n\n<p>Para que un hash sea considerado seguro, hallar una preimagen por fuerza bruta debería tomar \\(2^{n}\\) operaciones, donde \\(n\\) es el número de bits del hash. Por ejemplo, para el SHA-256, que tiene 256 bits, toma \\(2^{256}\\) operaciones, que es un número muy grande, computacionalmente inviable.</p>\n\n<p>Por ejemplo, imagina que puedes hacer 1 millón de operaciones por segundo, aproximadamente \\(2^{19}\\). Encontrar una primera preimagen para el SHA-256 te tomaría \\(2^{256} / 2^{19}\\), es decir \\(2^{247}\\) segundos, mientras que lo que se calcula que ha durado el universo son \\(2^{38}\\) segundos.</p>\n\n<p>Pongamos un ejemplo en Python. Supongamos que la función <code class=\"language-plaintext highlighter-rouge\">hash</code> es un hash seguro, y que la función <code class=\"language-plaintext highlighter-rouge\">mensaje_aleatorio</code> devuelve un mensaje diferente cada vez. Pon atención en lo que recibe la función <code class=\"language-plaintext highlighter-rouge\">primera_preimagen</code>:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">primera_preimagen</span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"p\">):</span>\n    <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"nf\">mensaje_aleatorio</span><span class=\"p\">()</span>\n    <span class=\"k\">while</span> <span class=\"nf\">hash</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"n\">h</span><span class=\"p\">:</span>\n        <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"nf\">mensaje_aleatorio</span><span class=\"p\">()</span>\n    <span class=\"k\">return</span> <span class=\"n\">m</span>\n</code></pre></div></div>\n\n<p>Este debería ser el mejor ataque que se pueda hacer sobre un hash seguro.</p>\n\n<h2 id=\"resistencia-a-la-segunda-preimagen\">Resistencia a la segunda preimagen</h2>\n\n<p>Esta garantía de seguridad es muy parecida a la primera, pero lo que se recibe aquí es una <em>preimagen</em> y se debe encontrar otra preimagen que genere el mismo hash.</p>\n\n<p>La garantía de seguridad debería ser la misma: encontrar una segunda preimagen debería ser computacionalmente inviable, es decir, que tomaría \\(2^{n}\\) operaciones, donde \\(n\\) es el número de bits del hash.</p>\n\n<p>Pongamos un ejemplo en Python. Observa que usamos la función <code class=\"language-plaintext highlighter-rouge\">primera_preimagen</code> que definimos antes:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">segunda_preimagen</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">):</span>\n    <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"nf\">hash</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">)</span>\n    <span class=\"n\">m2</span> <span class=\"o\">=</span> <span class=\"nf\">primera_preimagen</span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">m2</span>\n</code></pre></div></div>\n\n<p>Este ataque no implica más que hashear el mensaje y encontrar una primera preimagen de ese hash. Si el hash es resistente a la primera preimagen, entonces también lo será a la segunda.</p>\n\n<p>Parece que esta garantía no tiene mucho sentido, pero vayamos a la tercera y la más conocida.</p>\n\n<h2 id=\"resistencia-a-colisiones\">Resistencia a colisiones</h2>\n\n<p>Una colisión es cuando dos valores diferentes generan el mismo hash. Ya mencionamos que, al tener un conjunto infinito de valores de entrada y tener un conjunto muy grande (<em>pero limitado</em>) de valores de salida, es inevitable que suceda esto, de hecho, en este caso, un conjunto infinito de valores de entrada generan el mismo hash.</p>\n\n<p>Pero hagamos un caso concreto. Imagina que tu hash recibirá cadenas de bits de 512 bits, y generará un hash de 256 bits. Esto significa que el conjunto de posibles valores de entrada es \\(2^{512}\\) y el de posibles valores de salida es \\(2^{256}\\). A cada valor de salida le corresponden \\(2^{512}/2^{256} = 2^{512-256}\\) valores de entrada, es decir, que para cada valor de salida hay \\(2^{256}\\) valores de entrada que generan el mismo hash.</p>\n\n<p>Bueno, pues la tercera garantía de seguridad indica que <strong>debe ser computacionalmente inviable encontrar una colisión</strong>. En este caso no se nos da nada, ni una imagen (hash), ni una preimagen (valor de entrada). Se puede escoger cualquier valor de entrada para encontrar una colisión.</p>\n\n<p>Aquí entra la segunda garantía de seguridad, si la función hash es resistente a la segunda preimagen, es resistente a colisiones. En Python, el mejor algoritmo para encontrar una colisión debería ser el siguiente para un hash seguro:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">encontrar_colision</span><span class=\"p\">():</span>\n    <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"nf\">mensaje_aleatorio</span><span class=\"p\">()</span>\n    <span class=\"k\">return</span> <span class=\"nf\">encontrar_segunda_preimagen</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>La garantía de seguridad que debe de cumplir un hash seguro es que encontrar una colisión debería tomar \\(2^{n/2}\\) operaciones, donde \\(n\\) es el número de bits del hash. Por ejemplo, para el SHA-256, que tiene 256 bits, tomaría \\(2^{128}\\) operaciones, que sigue siendo un número muy grande, computacionalmente inviable.</p>\n\n<p>¿Por qué \\(2^{n/2}\\)? Porque es más fácil encontrar <em>un par</em> de valores que generen el mismo hash sin tener restricciones, que encontrar <em>un valor</em> que genere un hash dado.</p>\n\n<p>Si haces \\(N\\) hashes, puedes tener ~\\(N^2\\) oportunidades para encontrar una colisión por que puedes comparar cada hash con todos los demás. Esto es lo que se conoce como la paradoja del cumpleaños.</p>\n\n<h2 id=\"cómo-se-vuelve-inseguro-un-hash\">Cómo se vuelve inseguro un hash</h2>\n\n<p>Un hash seguro se comporta de manera completamente impredecible con respecto a su valor de entrada. Los hashes inseguros empiezan a dar muestras de regularidad en sus salidas o tienen salidas demasiado pequeñas.</p>\n\n<p>De esta manera, es posible encontrar métodos estadísticos para analizar las salidas y así encontrar patrones que permitan encontrar colisiones o preimágenes más fácilmente.</p>\n\n<p>Pero en realidad, tiene mucho que ver con su construcción y las formas en las que puedes truquear los valores que le das para reducir el número de pasos que se necesitan para encontrar una preimagen o una colisión.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>En este artículo vimos las tres garantías de seguridad que debe cumplir una función hash para ser criptográficamente segura. Te sirven para entender claramente de lo que se habla cuando se han encontrado colisiones en un hash, y poder evaluar la gravedad de la situación.</p>\n",
      "date_published": "Mon, 28 Aug 2023 00:00:00 -0600"
      }
    
  ]
}
       <div style="border: 1px solid gray; border-radius: 4px; margin: 20px; padding: 5px;">
          Visita nuestro canal de YouTube para encontrar temas similares en video:<a href="https://youtube.com/thedojomx"> The Dojo MX en YouTube </a>
        </div>

        
      </section>

      <footer class="page__meta">
        
        


        


      </footer>

      

      
    </div>

    
  </article>

  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Términos de búsqueda...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Términos de búsqueda..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        
<script>
    var sharect = new Sharect();
    sharect.config({
      twitter: true,
      twitterUsername: '@thedojomx',
      backgroundColor: '#4b0082',
      iconColor: '#fff'
    }).init();
</script>
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Seguir:</strong></li>
    

    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2024 The Dojo MX Blog. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <script>
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-127437335-2']);
  
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>









  </body>
</html>
