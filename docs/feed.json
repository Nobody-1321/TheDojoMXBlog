<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="es" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>The Dojo MX Blog</title>
<meta name="description" content="">


  <meta name="author" content="Héctor Patricio">
  


<meta property="og:type" content="website">
<meta property="og:locale" content="es">
<meta property="og:site_name" content="The Dojo MX Blog">
<meta property="og:title" content="The Dojo MX Blog">
<meta property="og:url" content="https://blog.thedojo.mx/feed.json">













<link rel="canonical" href="https://blog.thedojo.mx/feed.json">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": null,
      "url": "https://blog.thedojo.mx/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="The Dojo MX Blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    
<!-- favicon -->
<link rel="apple-touch-icon" sizes="180x180" href="/assets/images/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicons/favicon-16x16.png">
<link rel="manifest" href="/assets/images/favicons/site.webmanifest">
<link rel="mask-icon" href="/assets/images/favicons/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="/assets/images/favicons/favicon.ico">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/assets/images/favicons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">
<!-- end favicon -->
<!-- for mathjax support -->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZNSYMJDY5S"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-ZNSYMJDY5S');
</script>

<!-- Hotjar Tracking Code for blog.thedojo.mx -->
<script>
    (function(h,o,t,j,a,r){
        h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
        h._hjSettings={hjid:1217463,hjsv:6};
        a=o.getElementsByTagName('head')[0];
        r=o.createElement('script');r.async=1;
        r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
        a.appendChild(r);
    })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');
</script>

<script src="/assets/js/sharect.min.js"></script>

<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "url": "https://blog.thedojo.mx/feed.json",
      "name": null,
      "headline": null,
      "keywords": "",
      "description": "",
      "articleBody": "{\n  \"version\": \"https://jsonfeed.org/version/1\",\n  \"title\": {{ site.title | jsonify }},\n  \"description\": {% if site.description %}{{ site.description | jsonify }}{% endif %},\n  \"home_page_url\": \"{{ site.url }}\",\n  \"feed_url\": \"{{ site.url }}/feed.json\",\n  \"favicon\": \"{{ site.url}}/favicon.png\",\n  {% if site.author %}\n  \"author\": {\n    \"name\": {{ site.author | jsonify }}\n  },\n  {% endif %}\n  \"items\": [\n    \n    {% for post in site.posts limit:10 %}\n    {\n      \"id\": \"{{ post.url | prepend: site.baseurl | prepend: site.url }}\",\n      \"url\": \"{{ post.url | prepend: site.baseurl | prepend: site.url }}\",\n      \"title\": {{ post.title | jsonify }},\n      \"content_html\": {{ post.content | jsonify  }},\n      \"date_published\": \"{{ post.date | date_to_rfc822 }}\"\n      }{% unless forloop.last %},{% endunless %}\n    {% endfor %}\n  ]\n}",
      "datePublished": null,
      "dateModified": null,
      "author": {
        "@type": "Person",
        "name": null,
        "givenName": null,
        "email": null
      },
      "publisher": {
        "@type": "Organization",
        "name": "The Dojo MX Blog",
        "url": "https://blog.thedojo.mx",
        "logo": {
          "@type": "ImageObject",
          "width": 32,
          "height": 32,
          "url": "https://blog.thedojo.mx/icon/favicon.ico"
        }
      },
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://blog.thedojo.mx/feed.json"
      },
      "image": {
        "@type": "ImageObject",
        "width": 1200,
        "height": 400,
        "url": ""
      }
    }
</script>



  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Saltar a navegación principal</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Saltar a contenido</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Saltar a pie</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="https://res.cloudinary.com/hectorip/image/upload/v1554098427/TheDojo/the-dojo-transparent.png" alt="The Dojo MX Blog"></a>
        
        <a class="site-title" href="/">
          The Dojo MX Blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/latest">Todos los posts</a>
            </li><li class="masthead__menu-item">
              <a href="/about">Acerca de</a>
            </li><li class="masthead__menu-item">
              <a href="https://thedojo.mx">Cursos</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Alternar búsqueda</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Alternar menú</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  


  <article class="page h-entry" itemscope itemtype="https://schema.org/CreativeWork">
    
    
    
    

    <div class="page__inner-wrap">
      
        <header>
          
          

        </header>
      

      <section class="page__content e-content" itemprop="text">
        
        <div style="border: 1px solid gray; border-radius: 4px; margin: 20px; padding: 5px;">
          Visita nuestro canal de YouTube para encontrar temas similares en video:<a href="https://youtube.com/thedojomx"> The Dojo MX en YouTube </a>

        </div>
        {
  "version": "https://jsonfeed.org/version/1",
  "title": "The Dojo MX Blog",
  "description": ,
  "home_page_url": "https://blog.thedojo.mx",
  "feed_url": "https://blog.thedojo.mx/feed.json",
  "favicon": "https://blog.thedojo.mx/favicon.png",
  
  "author": {
    "name": {"name":"Héctor Patricio","avatar":"/assets/images/me.jpg","bio":"Desarrollador de software, tech lead @ HAL y The Dojo MX","uri":"https://github.com/hectorip","home":"https://til.hectorip.com/"}
  },
  
  "items": [
    
    
    {
      "id": "https://blog.thedojo.mx/2023/12/13/mojo-un-lenguaje-prometedor.html",
      "url": "https://blog.thedojo.mx/2023/12/13/mojo-un-lenguaje-prometedor.html",
      "title": "Mojo 🔥: un lenguaje prometedor",
      "content_html": "<p><a href=\"https://www.nondot.org/sabre/\" target=\"_blank\">Chris Lattner</a>, uno de los creadores de <a href=\"https://llvm.org\">LLVM</a> y <a href=\"https://www.swift.org/\">Swift</a>, ha estado desarrollando un nuevo lenguaje basado en la sintaxis de <strong>Python</strong> pero pensado para atacar su punto más débil: <strong>la velocidad de ejecución</strong>.</p>\n\n<p>Este lenguaje se llama <a href=\"https://modular.com/mojo\">Mojo</a>, y está siendo publicitado como un lenguaje para hacer aplicaciones de <strong>inteligencia artificial</strong>. Como ya dijimos, su enfoque principal está en ser un lenguaje que produzca programar eficientes, por lo que puede ser usado para cualquier aplicación que requiera alto rendimiento o hacer una gran cantidad de cálculos, justo como las aplicaciones de <em>machine learning</em>.</p>\n\n<p>En este artículo veremos el motivo detrás de su nacimiento, sus características y analizaremos si te conviene aprenderlo o deberías buscar alguna otra alternativa. Primero, entendamos la fundación de Mojo.</p>\n\n<h2 id=\"mlir---representación-intermedia-multi-capa\">MLIR - Representación intermedia multi-capa</h2>\n\n<p>LLVM es un proyecto que se define como infraestructura para la construcción de compiladores. Imagínate que es como un framework para construir compiladores. Muchos de los lenguajes actuales están creados usando este proyecto. Por ejemplo <a href=\"https://rust.org\">Rust</a>, Swift y <a href=\"https://julialang.org\">Julia</a> están construidos sobre LLVM.</p>\n\n<p>Una de las partes que hace muy útil a LLVM es su <strong>representación intermedia</strong>. Esta representación intermedia permite que los diferentes lenguajes de programación que funcionan sobre él se aprovechen de las optimizaciones que LLVM hace sobre el código intermedio. El flujo del código es el siguiente:</p>\n\n<ol>\n  <li>El código fuente es compilado a código intermedio (<strong>IR</strong>).</li>\n  <li>El <strong>IR</strong> es optimizado.</li>\n  <li>El <strong>IR</strong> es compilado a código de máquina.</li>\n</ol>\n\n<p>De hecho, se dice que Swift es sólo azúcar sintáctico sobre la representación intermedia de LLVM, es decir, que se parece mucho a esta representación intermedia y aprovecha sus características.</p>\n\n<p>MLIR (Multi-layer Intermediate Representation o Representación intermedia multi-capa) es una representación intermedia de más alto nivel que la representación intermedia tradicional. No en el sentido de que sea más fácil de entender para los humanos, sino que en vez de mapearse directamente con una infraestructura de compilación, representa un modelo más abstracto que puede ser mapeado a diferentes infraestructuras de compilación, de manera especializada para cada una de ellas. Así permite que un mismo código fuente pueda ser compilado para diferentes ejecutores, como GPU’s, TPU’s, CPU’s, etc, sin tener que crear una nueva representación intermedia o crear nuevo código fuente.</p>\n\n<h2 id=\"entra-mojo-\">Entra Mojo 🔥</h2>\n\n<p>Toda esta explicación anterior es para entender que Mojo es para MLIR lo que Swift es para LLVM. Aprovecha gran parte de las características de MLIR para crear un lenguaje de programación que pueda usar ejecutores especializados en cómputo de alto rendimiento como GPU’s y TPU’s, pero presentando una sintaxis más amigable para los humanos, a diferencia de CUDA, o C++, por ejemplo.</p>\n\n<p>Mojo te ayuda aprovechar el paralelismo masivo de los GPU’s sin tener que preocuparte por aprender un nuevo lenguaje o siquiera tener que pensar en dónde finalmente se ejecutará tu programa.</p>\n\n<p>Ya que Python es la lingua franca del mundo de la inteligencia artificial, Mojo inicialmente fue pensado como una extensión de Python (lo que llamaríamos un superconjunto de Python), en el sentido de que todo el código válido en Python es código válido en Mojo, muy parecido a la relación que existe entre la sintaxis de TypeScript y JavaScript.</p>\n\n<h2 id=\"características-de-mojo\">Características de Mojo</h2>\n\n<p>Las pruebas iniciales de Mojo revelan que puede ser hasta <strong>68,000</strong> veces más rápido que Python en ciertas tareas (sí, leíste bien <strong>sesenta y ocho mil</strong>), mientras que C++ llega a ser <strong><em>sólo</em> 5,000</strong> veces más rápido. Claro, esto no habla muy bien de Python, pero debes pensar en que su objetivo no es ser un lenguaje de alto rendimiento, sino un lenguaje de alto nivel y fácil de usar.</p>\n\n<p>Mojo quiere aprovechar la facilidad de uso de Python junto con su ecosistema de bibliotecas y desarrollos para hacer un ecosistema de desarrollo de inteligencia artificial más rápido y fácil de usar. Una de las primeras diferencias con Python es que es un lenguaje <strong>compilado</strong>.</p>\n\n<p>Hablemos de algunas de las cosas que Mojo le aumenta a Python:</p>\n\n<ol>\n  <li>\n    <p><strong>Sistema de tipos progresivos</strong>. Te permite usar el sistema de tipos tanto como lo necesites (por eso es progresivo). Pero debes tener en cuenta que los tipos te sirven tanto para verificar que el programa es correcto como <strong>para optimizar el código que se genera</strong>.</p>\n  </li>\n  <li>\n    <p><strong>Abstracciones sin costo</strong>. Muy parecido a Rust, Mojo te da acceso a usar abstracciones de alto nivel que no incrementan el costo de ejecución.</p>\n  </li>\n  <li>\n    <p><strong>Seguridad de memoria</strong>. Tiene un sistema de seguridad de memoria parecido al de Rust, mediante la pertenencia y el préstamo de referencias (ownership + borrow checker).</p>\n  </li>\n  <li>\n    <p><strong>Metaprogramación</strong>. Te permite crear código parametrizado que se transforma en tiempo de compilación.</p>\n  </li>\n</ol>\n\n<p>Como puedes ver, Mojo es un lenguaje muy interesante que aprovecha las características que hemos aprendido en lenguajes modernos que han sido útiles para crear mejores sistemas. El uso de MLIR es la base de su rendimiento, que permite que los programas que generas se puedan optimizar para ejecutores de diferentes tipos, incluidos algunos masivamente paralelos.</p>\n\n<h2 id=\"deberías-aprenderlo\">¿Deberías aprenderlo?</h2>\n\n<p>Mojo es un lenguaje que servirá tanto para hacer aplicaciones de IA como herramientas de bajo nivel para sistemas operativos, por lo que yo lo pensaría como un <strong>lenguaje de programación de sistemas de última generación</strong> que permitirá hacer cosas muy interesantes en el futuro.</p>\n\n<p>Ahora mismo (Diciembre de 2023), es un lenguaje de código cerrado, es decir, su desarrollo está llevado por una empresa privada y el código fuente no está disponible para que otros lo vean o contribuyan. Según Lattner, esto permite inicialmente que se se avance de manera más efectiva, en lo que personalmente estoy de acuerdo. Se espera que Mojo sea de código abierto cuando alcance el nivel de madurez necesario.</p>\n\n<p>Además, está en una etapa muy temprana de su desarrollo en la que ni siquiera cumple con todas las características de Python, por lo que todo lo que aprendas ahora sólo será un vistazo que te puede ayudar a definir si lo quieres usar cuando salga su versión lista para producción.</p>\n\n<p>Personalmente, creo que es un buena inversión del tiempo si estás metido en crear aplicaciones de alto rendimiento, programación de sistema o quieres crear sistemas que usen inteligencia artificial como una de sus características principales. Por el contrario, para desarrollo web creo que tomará un poco más de tiempo en serte útil.</p>\n\n<p>Otro caso para el que puede serte útil es para aprender las características de los lenguajes modernos, como los tipos progresivos o la seguridad de memoria mediante el préstamos de referencias.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>Mojo es un lenguaje interesante, muy prometedor y que está en la raya de la innovación en creación de lenguajes y características modernas. Si eres curioso y te gustan en general los lenguajes de programación, creo que es una gran opción para empezar a aprender y tal vez en el futuro recoger los beneficios si cumple con sus promesas.</p>\n",
      "date_published": "Wed, 13 Dec 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/12/09/que-es-real-time-en-sistemas-computacionales.html",
      "url": "https://blog.thedojo.mx/2023/12/09/que-es-real-time-en-sistemas-computacionales.html",
      "title": "¿Qué es Real Time en sistemas de software?",
      "content_html": "<p>A veces, los programadores usamos muy libremente los conceptos. Uno de ellos es el de Real Time. En este artículo vamos a hablar de lo que significa realmente el término, lo vamos a definir claramente y sobre todo aprenderemos a diferenciar los distintos niveles o garantías que debe ofrecer un sistema en tiempo real.</p>\n\n<h2 id=\"qué-es-real-time\">¿Qué es Real Time?</h2>\n\n<p>Un sistema que provee garantías de Tiempo Real o Real Time es aquel que <strong>garantiza</strong> que una tarea se va a ejecutar en un tiempo determinado. Esto es muy importante en sistemas críticos, como los que se usan en la industria automotriz, aeroespacial, médica, en los que ejecutar NO ejecutar una tarea en un tiempo determinado puede tener consecuencias catastróficas.</p>\n\n<p>Pero también hay sistemas en los que es <em>deseable</em> que una tarea se ejecute antes de cierto tiempo, por ejemplo, cuando estamos transmitiendo información en forma de audio o video de algo que es importante que se comunique rápidamente. Así, podemos hacer llamadas o videollamadas que son útiles.</p>\n\n<p>Los dos casos anteriores, nos dan la pauta para por lo menos distinguir dos tipos de sistemas Real Time:</p>\n\n<ol>\n  <li>\n    <p><strong>Hard Realtime</strong>. Son sistemas que deben garantizar con un 100% de certeza que la tarea que quieres que hagan se va a realizar <em>máximo</em> en el tiempo qu especifica el mismo sistema. En estos sistemas no hay margen de error, si el sistema no puede cumplir con el tiempo especificado se considera que falló, por lo que no es seguro operarlo. Este tipo de sistemas se usan en ocasiones en las que es muy muy importante que la tarea en cuestión se ejecute lo más rápido posible, normalmente porque el no hacerlo o tener un retraso podría tener consecuencias mortales o catastróficas.</p>\n  </li>\n  <li>\n    <p><strong>Soft Realtime</strong>. Los sistemas de este tipo, garantizan que <em>mínimo</em> cierto porcentaje de las veces que un sistema se ejecute, la tarea se va a ejecutar en el tiempo especificado, normalmente lo más rápido posible. A diferencia de los sistemas de tiempo real fuerte, puede que cierto número de acciones tarden un poco más de lo esperado, pero esto no llevaría a pensar que el sistema falló. Este tipo de sistemas se usa para cosas no tan críticas pero en las que es deseable que la tarea está lista lo más rápido posible, por ejemplo, en juegos, aplicaciones de videoconferencia, sistemas de coordinación de trabajo (Figma, Google Docs, etc).</p>\n  </li>\n</ol>\n\n<h2 id=\"cómo-puedes-lograr-un-sistema-real-time\">Cómo puedes lograr un sistema Real Time</h2>\n\n<p>Lo primero en que debemos pensar es qué tipo de realtime necesitamos. Como te puedes imaginar, lograr un sistema Hard Realtime es mucho más complicado que lograr un sistema Soft Realtime. Esto es porque en el primero, no hay margen de error, mientras que en el segundo, podemos relajarnos un poco.</p>\n\n<p>Algunas sugerencias para lograr sistemas realtime son:</p>\n\n<ol>\n  <li>\n    <p><strong>Usa un ecosistema que esté pensado para esto</strong>. Hay lenguajes de programación y plataformas que mediante diferentes técnicas te ayudan a lograr funcionalidades real time, pero normalmente se queden al nivel de aplicaciones de soft realtime. Algunos ejemplos son lenguajes que aprovechan la concurrencia y controlan efectivamente el tiempo de ejecución de tu programa o te permiten hacerlo de manera sencilla, como: Go, Elixir y NodeJS.</p>\n  </li>\n  <li>\n    <p><strong>Usa un lenguaje de programación que te de control granular sobre el tiempo de ejecución</strong>. Con esto principalmente me refiero a una cosa: que no tengan recolector de basura. Recuerda que este proceso puede parar el programa por un tiempo no conocido y de manera no controlada, por lo que si quieres lograr aplicaciones hard realtime, será una tarea extremadamente difícil. Lamento decírtelo, pero si quieres asegurar que tu programa se comporte como deseas, vas a tener que controlar casi cada detalle, en lenguajes como C, C++ o Rust.</p>\n  </li>\n  <li>\n    <p><strong>Asegura la fiabilidad de tu infraestructura</strong>. Para que un sistema realtime sea confiable, vas a necesitar que la infraestructura sea resistente a fallas. Esto lo logras eliminando puntos únicos de fallo, es decir, aquellos puntos de tu programa o infraestructura que si fallan hacen que todo el sistema se caiga. Para lograr esto tienes que pensar en arquitecturas distribuidas, redundancia de datos, escalamiento automático, etc.</p>\n  </li>\n</ol>\n\n<p>Espero que estos consejos te sirvan y si se me está pasando alguno, por favor, déjame un comentario.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>Conocer los diferentes niveles de servicio que un sistema puede garantizar y comprender las características que presentan, te puede ayudar a tomar en serio la responsabilidad de diseñar un sistema realtime y la dificultad que implica.</p>\n\n<p>Piensa profundamente si realmente se requiere un sistema con estas características (sobre todo si es hard realtime) y si es así, toma en serio la responsabilidad de diseñarlo y construirlo, espero que los consejos que te di en este artículo te sirvan para lograrlo.</p>\n",
      "date_published": "Sat, 09 Dec 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/08/28/las-tres-garantias-de-seguridad-de-un-hash.html",
      "url": "https://blog.thedojo.mx/2023/08/28/las-tres-garantias-de-seguridad-de-un-hash.html",
      "title": "Las tres garantías de seguridad de un hash",
      "content_html": "<p>En este artículo profundizaremos sobre las garantías de seguridad mínimas que una función hash debe cumplir para ser criptográficamente segura. En un artículo anterior: <a href=\"/2021/12/02/algoritmos-criptograficos-que-es-un-hash.html\">¿Qué es un hash?</a> ya hablamos más detalladamente de la definición y de los algoritmos que puedes usar aún hoy de manera segura.</p>\n\n<p>Empecemos por una pequeña definición de lo que es una función hash en la criptografía.</p>\n\n<h2 id=\"qué-es-un-hash\">¿Qué es un hash?</h2>\n\n<p>Un hash es una función que te devuelve un valor de tamaño fijo independientemente del tamaño de la entrada, esto implica una compresión de datos. Las funciones hash que son usadas en criptografía, tienen la característica de entregar valores completamente <em>impredecibles</em>, tanto para un humano como para una computadora. Es decir que no hay manera de saber qué valor va a entregar una función hash para un valor dado si no le has pasado ese valor antes.</p>\n\n<p>Lo anterior no quiere decir que las funciones hash devuelvan algo diferente cada vez que las ejecutas, sino que para un valor dado, siempre devuelven el mismo resultado, y aquí es donde radica su utilidad.</p>\n\n<p>Un hash perfecto se comportaría como un generador de valores aleatorios, pero debido a lo que hemos dicho anteriormente, deben ser <strong>deterministas</strong> al mismo tiempo que <strong>impredecibles</strong>.</p>\n\n<p>Para medir la seguridad de una función hash, se usan tres pruebas, que se conocen como las garantía de seguridad de un hash.</p>\n\n<p>Estas garantías son:</p>\n\n<ol>\n  <li>Resistencia a la primera preimagen</li>\n  <li>Resistencia a la segunda preimagen</li>\n  <li>Resistencia a la colisión</li>\n</ol>\n\n<p>Cada una de estas garantías se refiere a un tipo de ataque que se puede hacer a una función hash. Vamos a explicarlas pero antes aclaremos algunos términos.</p>\n\n<h2 id=\"imagen-y-preimagen\">Imagen y preimagen</h2>\n\n<p>En matemáticas, una función es una relación entre dos conjuntos de valores, uno de entrada y uno de salida. En la mayoría la de las funciones matemáticas comunes, cada valor de entrada tiene un único valor de salida.</p>\n\n<p>Tomemos como ejemplo: \\(f(x) = x + 1\\), esta función toma un valor \\(x\\) y le suma \\(1\\), por lo que cada valor de \\(x\\) tiene un único valor de salida, porque sabemos que un número cualquiera tiene solamente un sucesor.</p>\n\n<p>Pero no todas las funciones se comportan así, por ejemplo: \\(f(x) = x^2\\). En esta función el valor 4 puede ser generado por dos valores de entrada diferentes: \\(2\\) y \\(-2\\).</p>\n\n<p>Cuando vemos una función así no es común que nos definan el conjunto de entrada, así que asumimos que el conjunto de entrada o <strong>dominio</strong> es el conjunto de los números reales, y el conjunto de salida o <strong>codominio</strong> es el conjunto de los números reales.</p>\n\n<p>Pensemos en el dominio y codominio como conjuntos amplios en los que los valores de entrada y salida <em>podrían estar</em>. La <strong>imagen</strong> de una función es el conjunto de valores que <em>están</em> en el codominio, es decir, los valores que la función <em>puede</em> devuelve. La <strong>preimagen</strong> es el conjunto de valores que <em>pueden</em> ser entrada de la función.</p>\n\n<p>En términos prácticos para nosotros los programadores, la imagen es casi equivalente al codominio, y la preimagen es el dominio.</p>\n\n<p>Esta imagen sacada de Wikipedia lo ilustra un poco mejor:</p>\n\n<p><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_600/v1693144037/Codomain2_kzda4n.svg\" alt=\"Imagen vs Codomino\" class=\"align-center\" /></p>\n\n<p>La imagen es el área amarilla, mientras que Y es el codominio, y X es el dominio. Lo último que nos hace falta saber es que aunque imagen y preimagen son los conjuntos de entradas y salidas del algoritmo, también nos podemos referir así a un valor individual de este conjunto.</p>\n\n<p>Apliquemos los aprendido al ejemplo de la función \\(f(x) = x^2\\). El dominio es el conjunto de los números reales, y el codominio también es el conjunto de los números reales. La imagen es el conjunto de los <strong>números reales positivos que tengan una raíz cuadrada</strong>, y la preimagen es el conjunto de los números reales. Un ejemplo concreto: para el valor <code class=\"language-plaintext highlighter-rouge\">4</code> considerado como resultado de la función o <strong>imagen</strong>, tendría <em>dos</em> preimágenes: \\(2\\) y \\(-2\\).</p>\n\n<p>Ahora sí, hablemos de la primera garantía de seguridad de un hash.</p>\n\n<h2 id=\"resistencia-a-la-primera-preimagen\">Resistencia a la primera preimagen</h2>\n\n<p>Aquí debes poner atención a los valores <em>que se dan</em> para hacer la prueba de seguridad. Presta atención a cuando se dice “dado un valor”, estos son la valores que suponemos que ya se conocen.</p>\n\n<p>En la primera garantía es: <strong>Dada</strong> una <em>imagen</em> es computacionalmente inviable encontrar una <em>preimagen</em> que la genere.</p>\n\n<p>En palabras de programadores: Dado un hash, es computacionalmente inviable encontrar un valor que al ser pasado a la función hash, genere ese hash.</p>\n\n<p>¿Por qué decimos <strong>un</strong> valor que genere ese hash y no <strong>el</strong> valor que genere ese hash? Porque para un valor de salida, puede haber más de un valor de entrada que lo genere. Especialmente para los hashes, su conjunto de valores posibles es infinito: todas las combinaciones de bits posibles de cualquier tamaño.</p>\n\n<p>¿Cuál es el tamaño del conjunto de posibles salida? Eso depende del hash usado y su número de bits. Por ejemplo, el SHA-256 genera hashes de 256 bits, por lo que su conjunto de posibles valores es \\(2^{256}\\), que es un número muy grande, pero no infinito, por lo que es posible que dos valores generen el mismo hash. Cada uno de esos valores sería <em>una preimagen</em> de un hash dado.</p>\n\n<p>Entonces ya tenemos todo el escenario: nos han dado un hash y tenemos que encontrar uno de los infinitos valores que pueden producir ese hash, una preimagen.</p>\n\n<p>Pues bien, para un hash criptográficamente seguro esta operación debe de ser imposible de realizar de manera más eficiente que usando fuerza bruta, es decir, probando todos los valores posibles hasta encontrar uno que genere el hash dado.</p>\n\n<p>Para que un hash sea considerado seguro, hallar una preimagen por fuerza bruta debería tomar \\(2^{n}\\) operaciones, donde \\(n\\) es el número de bits del hash. Por ejemplo, para el SHA-256, que tiene 256 bits, toma \\(2^{256}\\) operaciones, que es un número muy grande, computacionalmente inviable.</p>\n\n<p>Por ejemplo, imagina que puedes hacer 1 millón de operaciones por segundo, aproximadamente \\(2^{19}\\). Encontrar una primera preimagen para el SHA-256 te tomaría \\(2^{256} / 2^{19}\\), es decir \\(2^{247}\\) segundos, mientras que lo que se calcula que ha durado el universo son \\(2^{38}\\) segundos.</p>\n\n<p>Pongamos un ejemplo en Python. Supongamos que la función <code class=\"language-plaintext highlighter-rouge\">hash</code> es un hash seguro, y que la función <code class=\"language-plaintext highlighter-rouge\">mensaje_aleatorio</code> devuelve un mensaje diferente cada vez. Pon atención en lo que recibe la función <code class=\"language-plaintext highlighter-rouge\">primera_preimagen</code>:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">primera_preimagen</span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"p\">):</span>\n    <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"nf\">mensaje_aleatorio</span><span class=\"p\">()</span>\n    <span class=\"k\">while</span> <span class=\"nf\">hash</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"n\">h</span><span class=\"p\">:</span>\n        <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"nf\">mensaje_aleatorio</span><span class=\"p\">()</span>\n    <span class=\"k\">return</span> <span class=\"n\">m</span>\n</code></pre></div></div>\n\n<p>Este debería ser el mejor ataque que se pueda hacer sobre un hash seguro.</p>\n\n<h2 id=\"resistencia-a-la-segunda-preimagen\">Resistencia a la segunda preimagen</h2>\n\n<p>Esta garantía de seguridad es muy parecida a la primera, pero lo que se recibe aquí es una <em>preimagen</em> y se debe encontrar otra preimagen que genere el mismo hash.</p>\n\n<p>La garantía de seguridad debería ser la misma: encontrar una segunda preimagen debería ser computacionalmente inviable, es decir, que tomaría \\(2^{n}\\) operaciones, donde \\(n\\) es el número de bits del hash.</p>\n\n<p>Pongamos un ejemplo en Python. Observa que usamos la función <code class=\"language-plaintext highlighter-rouge\">primera_preimagen</code> que definimos antes:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">segunda_preimagen</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">):</span>\n    <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"nf\">hash</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">)</span>\n    <span class=\"n\">m2</span> <span class=\"o\">=</span> <span class=\"nf\">primera_preimagen</span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">m2</span>\n</code></pre></div></div>\n\n<p>Este ataque no implica más que hashear el mensaje y encontrar una primera preimagen de ese hash. Si el hash es resistente a la primera preimagen, entonces también lo será a la segunda.</p>\n\n<p>Parece que esta garantía no tiene mucho sentido, pero vayamos a la tercera y la más conocida.</p>\n\n<h2 id=\"resistencia-a-colisiones\">Resistencia a colisiones</h2>\n\n<p>Una colisión es cuando dos valores diferentes generan el mismo hash. Ya mencionamos que, al tener un conjunto infinito de valores de entrada y tener un conjunto muy grande (<em>pero limitado</em>) de valores de salida, es inevitable que suceda esto, de hecho, en este caso, un conjunto infinito de valores de entrada generan el mismo hash.</p>\n\n<p>Pero hagamos un caso concreto. Imagina que tu hash recibirá cadenas de bits de 512 bits, y generará un hash de 256 bits. Esto significa que el conjunto de posibles valores de entrada es \\(2^{512}\\) y el de posibles valores de salida es \\(2^{256}\\). A cada valor de salida le corresponden \\(2^{512}/2^{256} = 2^{512-256}\\) valores de entrada, es decir, que para cada valor de salida hay \\(2^{256}\\) valores de entrada que generan el mismo hash.</p>\n\n<p>Bueno, pues la tercera garantía de seguridad indica que <strong>debe ser computacionalmente inviable encontrar una colisión</strong>. En este caso no se nos da nada, ni una imagen (hash), ni una preimagen (valor de entrada). Se puede escoger cualquier valor de entrada para encontrar una colisión.</p>\n\n<p>Aquí entra la segunda garantía de seguridad, si la función hash es resistente a la segunda preimagen, es resistente a colisiones. En Python, el mejor algoritmo para encontrar una colisión debería ser el siguiente para un hash seguro:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">encontrar_colision</span><span class=\"p\">():</span>\n    <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"nf\">mensaje_aleatorio</span><span class=\"p\">()</span>\n    <span class=\"k\">return</span> <span class=\"nf\">encontrar_segunda_preimagen</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>La garantía de seguridad que debe de cumplir un hash seguro es que encontrar una colisión debería tomar \\(2^{n/2}\\) operaciones, donde \\(n\\) es el número de bits del hash. Por ejemplo, para el SHA-256, que tiene 256 bits, tomaría \\(2^{128}\\) operaciones, que sigue siendo un número muy grande, computacionalmente inviable.</p>\n\n<p>¿Por qué \\(2^{n/2}\\)? Porque es más fácil encontrar <em>un par</em> de valores que generen el mismo hash sin tener restricciones, que encontrar <em>un valor</em> que genere un hash dado.</p>\n\n<p>Si haces \\(N\\) hashes, puedes tener ~\\(N^2\\) oportunidades para encontrar una colisión por que puedes comparar cada hash con todos los demás. Esto es lo que se conoce como la paradoja del cumpleaños.</p>\n\n<h2 id=\"cómo-se-vuelve-inseguro-un-hash\">Cómo se vuelve inseguro un hash</h2>\n\n<p>Un hash seguro se comporta de manera completamente impredecible con respecto a su valor de entrada. Los hashes inseguros empiezan a dar muestras de regularidad en sus salidas o tienen salidas demasiado pequeñas.</p>\n\n<p>De esta manera, es posible encontrar métodos estadísticos para analizar las salidas y así encontrar patrones que permitan encontrar colisiones o preimágenes más fácilmente.</p>\n\n<p>Pero en realidad, tiene mucho que ver con su construcción y las formas en las que puedes truquear los valores que le das para reducir el número de pasos que se necesitan para encontrar una preimagen o una colisión.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>En este artículo vimos las tres garantías de seguridad que debe cumplir una función hash para ser criptográficamente segura. Te sirven para entender claramente de lo que se habla cuando se han encontrado colisiones en un hash, y poder evaluar la gravedad de la situación.</p>\n",
      "date_published": "Mon, 28 Aug 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/08/19/que-es-la-filosofia-de-la-computacion.html",
      "url": "https://blog.thedojo.mx/2023/08/19/que-es-la-filosofia-de-la-computacion.html",
      "title": "¿Qué es la filosofía de la computación?",
      "content_html": "<p>La filosofía es una de las ramas más importantes del saber humano y, para mi, es la fundación de todas las demás ramas del conocimiento y de las ciencias. En este artículo hablaremos de la filosofía de la computación y cómo esta te puede ayudar como programador o desarrollador de software.</p>\n\n<p>Empecemos primero hablando de qué es la filosofía y luego combinándola con la computación.</p>\n\n<h2 id=\"qué-es-la-filosofía\">¿Qué es la filosofía?</h2>\n\n<p>La filosofía busca <strong>responder las preguntas fundamentales de la existencia humana</strong>. Casi ninguna de las preguntas importantes se ha podido responder de manera definitiva, pero lo interesante que nos puede ofrecer la filosofía es una análisis profundo de las posibles respuestas y de las implicaciones de cada una de ellas. Así, se ha generado mucho conocimiento que nos ayuda a entender mejor el mundo y a nosotros mismos.</p>\n\n<p>Además, la filosofía ha desarrollado métodos que nos pueden ayudar a examinar temas difíciles de manera efectiva.</p>\n\n<p>Pongamos un ejemplo. Una de las grandes preguntas que muchos filósofos han intentado responder es “¿Cuál es la mejor forma de vivir?”. No hay una respuesta definitiva, pero en la exploración se han encontrado y propuesto muchas prácticas que mejoran la vida humana y que sirven en diferentes situaciones.</p>\n\n<p>Además han surgido modelos de pensamiento que consisten en una serie de ideas y prácticas que pueden darle sentido a una vida bien practicadas: Estoicismo, Epicureismo, etc. Combinadas pueden servirte para mucho para analizar una situación en la vida o para encontrar una forma de actuar.</p>\n\n<p>En resumen: la filosofía te ayudará a <em>pensar mejor</em> sobre cuestiones importantes en la vida y en las diferentes áreas de importancia. <strong>¿Cómo se puede relacionar esto con la computación?</strong></p>\n\n<h2 id=\"qué-es-la-filosofía-de-la-computación\">¿Qué es la filosofía de la computación?</h2>\n\n<p>La filosofía de la computación es lo que acabamos de describir pero aplicado a las preguntas que le conciernen a la computación. Preguntas fundamentales para todos los que tenemos tratos profundos con las computadoras:</p>\n\n<ul>\n  <li>¿Qué es la computación?</li>\n  <li>¿Qué es una computadora?</li>\n  <li>¿Qué es un programa?</li>\n  <li>¿Qué es computable?</li>\n  <li>¿Qué es programar?</li>\n  <li>¿Qué es un lenguaje de programación?</li>\n  <li>¿Cómo puedo crear programas útiles?</li>\n</ul>\n\n<p>Estas preguntas parecen tener un respuesta concreta pero hay algunas situaciones en los que podemos dudar de qué tan útil o real es lo que sabemos.</p>\n\n<p>La filosofía no se queda allí, tiene por lo menos las siguientes áreas:</p>\n\n<ul>\n  <li><strong>La ontología</strong>. En la que se preguntan cosas como las que acabamos de ver, que tienen que ver con la existencia y la definición de las cosas</li>\n  <li><strong>La semántica</strong>. El significado de los términos que usamos</li>\n  <li><strong>La axiología</strong>. Analiza los valores que fundamentan la computación y los eventos relacionados con estos</li>\n  <li><strong>La epistemología</strong>. Es el análisis del conocimiento y las formas de obtenerlo: ¿cómo podemos conocer más acerca de la computación? ¿Cómo podemos saber si lo que sabemos es correcto? ¿Cómo <em>sabemos</em> que <em>sabemos</em>?</li>\n  <li><strong>La metodología</strong>. Qué métodos podemos seguir para practicar la computación y la obtención de conocimiento de esta de la mejor manera</li>\n  <li><strong>La estética</strong>. Analiza la percepción que tenemos de los artefactos computacionales y los conceptos relacionados con encontrar agradable o de valor esa percepción: orden, belleza, significado, etc.</li>\n  <li><strong>La ética</strong>. Está basada en la axiología, es decir, en la definición de lo que consideramos de valor y qué acciones o prácticas nos acercan o alejan de lo que consideramos que puede ser “bueno” como resultado de la computación</li>\n</ul>\n\n<p>Como puedes ver, es amplia, pero cada una de las áreas te puede ayudar en temas específicos en tu práctica diaria.</p>\n\n<p>A diferencia de la filosofía común, la filosofía de la computación tiene mucho menos de existencia y a penas hay unos cuántos escritos y personas que la han practicado en los últimos años, así que si te introduces estarás en un campo en que tendrás que aplicar las técnicas filosóficas a esta área específica, y es probable que te lleves muchas sorpresas.</p>\n\n<h2 id=\"por-qué-es-importante-la-filosofía-de-la-computación\">¿Por qué es importante la filosofía de la computación?</h2>\n\n<p>La filosofía de la computación o de ciencias de la computación te puede ayudar dándote los fundamentos que necesitas sobre todo para enfrentarte a las cuestiones difíciles de tu trabajo.</p>\n\n<p>Tener fundamentos para definir lo que quieres lograr, dónde están los límites de tu trabajo y qué es posible, te puede hacer mucho más disfrutable tu día a día.</p>\n\n<p>No es algo sin lo que puedas trabajar, pero mientras más sepas de esta área, sin duda más disfrutarás de tu trabajo.</p>\n\n<p>Pero esto va mucho más allá: todas las ideas importantes del <em>desarrollo de software</em>\ntienen un camino en la filosofía de la computación, así que si quieres desarrollar mejor software, sin duda es un área fundamental.</p>\n\n<h2 id=\"cómo-aprender-filosofía-de-la-computación\">¿Cómo aprender filosofía de la computación?</h2>\n\n<p>Recomiendo mucho empezar por lo básico y para esto me ha servido el canal de <a href=\"https://camilochs.github.io/web/\">Camilo Chacón Sartori</a> en <a href=\"https://www.youtube.com/@camilo_chacon_s\">YouTube</a>, en el que tiene una serie en la que te <a href=\"https://www.youtube.com/watch?v=eVxR8io5xTg&amp;list=PLbA-PGKWV-JhWcaZ0HzHFIFbnVakY9t1o\">introduce a las partes de la filosofía de la computación</a>.</p>\n\n<p>Pero también tiene un video que se llama <a href=\"https://www.youtube.com/watch?v=97InfGEK3Zw\">¿Qué es la filosofía de computación?</a>, en el que te da una introducción básica.</p>\n\n<p>Después, puedes empezar a leer sobre los autores que han escrito de esto por años. Yo recomiendo a William J. Rapaport con su escrito <a href=\"https://cse.buffalo.edu/~rapaport/Papers/philcs-complete.pdf\">A Philosophy of Computer Science</a>.</p>\n\n<p>Y finalmente, para profundizar todavía más, tenemos el libro del mismo autor, publicado en 2023: <a href=\"https://www.wiley.com/en-us/Philosophy+of+Computer+Science%3A+An+Introduction+to+the+Issues+and+the+Literature-p-9781119891901\">Philosophy of Computer Science: An Introduction to the Issues and the Literature</a>.</p>\n\n<p>Si le echas un ojo a esto y te parece intimidante, puedes entrar por algo que tiene una menor barrera y que también incluiría en el área de la filosofía de la computación: la filosofía de la información. Para esto recomiendo mucho el libro <a href=\"https://buttondown.email/hillelwayne/archive/data-and-reality-2nd-edition/\">Data and Reality</a> de William Kent. En el canal tenemos un <a href=\"https://youtu.be/i4lADcMZsZo\">resumen de este libro</a>.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>Aprender filosofía de la computación es una muy buena idea para tu carrera. Te ayudará a plantearte y a <em>intentar</em> resolver las preguntas importantes. Este intento de contestar las preguntas importantes relacionadas con la computación y el desarrollo de software te dará más armas para enfrentarte a los problemas del día a día y a disfrutarlos más.</p>\n\n<p>Finalmente, las herramientas que desarrollas en el estudio de estos problemas te puede ayudar mucho más allá de la filosofía: <strong>te ayudará a resolver problemas de manera más efectiva.</strong></p>\n",
      "date_published": "Sat, 19 Aug 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/08/12/por-que-debes-aprender-ciencias-de-la-computacion.html",
      "url": "https://blog.thedojo.mx/2023/08/12/por-que-debes-aprender-ciencias-de-la-computacion.html",
      "title": "¿Por qué debes aprender ciencias de la computación?",
      "content_html": "<p>Las ciencias de la computación a veces parecen algo mítico para los desarrolladores, algo que sólo aquellos que trabajan en <em>Big Tech</em> o en la <em>NASA</em> pueden entender. Pero si programas, es algo <em><strong>ya que usas a diario</strong></em>, por lo que te conviene comprenderlo mejor.</p>\n\n<p>Empecemos por el principio definiendo qué son y cómo te pueden ayudar.</p>\n\n<h2 id=\"qué-son-las-ciencias-de-la-computación\">¿Qué son las ciencias de la computación?</h2>\n\n<p>Las <strong>ciencias de la computación</strong> son un campo de estudio que busca entender los principios que rigen el <strong>fenómeno de la computación</strong> en general. Podemos definir la computación como el proceso de transformar información en algo útil, normalmente de manera dirigida.</p>\n\n<p>Las ciencias de la computación abarcan desde la definición y estudio conceptual de los principios que rigen la computación, hasta la implementación de algoritmos y estructuras de datos, junto con su <strong>ejecución en medios físicos</strong>. Esta última parte es la que más nos concierne como desarrolladores.</p>\n\n<p>Como podrás ver, es un campo muy amplio, pero muy interesante y que puede darte una visión más amplia de lo que haces día a día, pero que además te puede ayudar a comprender los componentes principales del entorno en el que tus programas corren y cómo funcionan.</p>\n\n<p>Algunos de los principios temas que trata son:</p>\n\n<ul>\n  <li>Lo que es posible calcular y lo que no</li>\n  <li>En qué medios se puede ejecutar un programa</li>\n  <li>Cuáles son formas eficientes y confiables de almacenar información</li>\n  <li>Cómo se puede representar la información</li>\n  <li>Cómo se puede transmitir la información sin que se corrompa</li>\n  <li>Cómo se puede transformar la información de manera eficiente</li>\n  <li>Cómo proteger la información</li>\n  <li>Cómo coordinar varias computadoras</li>\n</ul>\n\n<p>Cómo podrás ver, son problemas a los que nos enfrentamos día a día en nuestro trabajo de manera continua.</p>\n\n<h2 id=\"por-qué-son-importantes\">¿Por qué son importantes?</h2>\n\n<p>La mayoría de los problemas que resolvemos en nuestro trabajo diario ya han sido resueltos en el pasado, por personas usando conocimientos que podemos considerar como ciencias de la computación y puestos en práctica en forma de algoritmos y estructuras de datos, implementados en los lenguajes de programación que usamos. También los frameworks y librerías que usamos son implementaciones de estos principios.</p>\n\n<p>Pero, ¿qué pasa cuando quieres hacer algo que va más allá de lo que tu lenguaje o tu plataforma te ofrece por default? Aquí es donde entra el conocimiento de cómo funciona la computación de manera más profunda, los principios que rigen la computación, y las técnicas para resolver problemas.</p>\n\n<p>Si quieres hacer cosas que vayan más allá de lo común, las ciencias de la computación te pueden proporcionar las herramientas y habilidades para lograrlo de manera sostenible.</p>\n\n<p>Saber ciencias de la computación puede hacer la diferencia entre primero, que seas capaz de crear eficazmente lo que te estás imaginando y segundo que sea exitoso y pueda seguir creciendo.</p>\n\n<h2 id=\"cómo-aprender-ciencias-de-la-computación\">¿Cómo aprender ciencias de la computación?</h2>\n\n<p>La parte más importante de este artículo es cómo aprender ciencias de la computación. Si cursaste la universidad en una carrera relacionada con la computación, es probable que ya tengas las bases, o por lo menos la idea de los temas principales que puedes estudiar.</p>\n\n<p>Pero lo triste es que casi siempre se enseña de manera segregada (se tratan los temas por separado sin ver la relación entre ellos) y desactualizada (se presenta la visión de los años 70s o 80s).</p>\n\n<p>Por eso, independientemente de tu formación, te recomiendo que leas los siguientes libros:</p>\n\n<ul>\n  <li><a href=\"https://mitpress.mit.edu/books/computational-thinking\">Computational Thinking</a>. En este libro tendrás una introducción a los temas principales del pensamiento computacional, algo completamente necesario para entender las ciencias de la computación.</li>\n  <li><a href=\"https://mitpress.mit.edu/9780262527125/great-principles-of-computing/\">Great Principles of Computing</a>. Para mi este libro presenta la visión más moderna de las ciencias de la computación. En el artículo <a href=\"/2023/05/13/libros-que-todo-desarrollador-de-software-deberia-leer-cs.html\">“Libros que todo desarrollador debería leer: ciencias de la computación”</a>, encontrarás más recomendaciones.</li>\n</ul>\n\n<p>Si no sabes nada de ciencias de la computación puede empezar con algo más ligero como:</p>\n\n<ul>\n  <li><a href=\"https://www.amazon.com/Computer-Science-Distilled-Computational-Problems/dp/0997316020\">Computer Science Distilled</a></li>\n  <li><a href=\"https://pll.harvard.edu/course/cs50-introduction-computer-science\">CS50</a></li>\n</ul>\n\n<p>Si tienes alguna otra recomendación, no dudes en ponerla en los comentarios.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>Aprender ciencias de la computación es una buena idea para tu carrera, independientemente de la etapa en la que te encuentres o de la rama de la programación a la que te dediques. Te ayudará a evitar la frustración de no saber por qué algo no funciona, o peor aún, que funcione y no saber por qué.</p>\n\n<p>Consulta los recursos que recomendamos en este artículo y empieza a aprender hoy mismo. Además en este blog encontrarás muchos artículos relacionados con las ciencias de la computación, así que no dudes en explorarlos.</p>\n",
      "date_published": "Sat, 12 Aug 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/06/29/la-matriz-del-conocimiento-para-devs.html",
      "url": "https://blog.thedojo.mx/2023/06/29/la-matriz-del-conocimiento-para-devs.html",
      "title": "La matriz del conocimiento para devs",
      "content_html": "<p>La epistemología es la rama de la filosofía que estudia la naturaleza del conocimiento. Una de sus principales tareas es la de estudiar cómo se adquiere el conocimiento y cómo se representa.</p>\n\n<p>La <strong>matriz de Rumsfeld</strong> es una herramienta que nos ayuda a representar el conocimiento y a identificar qué conocimiento nos falta para tomar decisiones. En este artículo vamos a ver cómo funciona y cómo nos puede ayudar.</p>\n\n<h2 id=\"la-matriz-de-rumsfeld\">La matriz de Rumsfeld</h2>\n\n<p>Según nuestro grado de conocimiento y la consciencia que tenemos de él, podemos clasificarlo en 4 categorías:</p>\n\n<ol>\n  <li>Lo que sabemos que sabemos</li>\n  <li>Lo que sabemos que <strong>no</strong> sabemos</li>\n  <li>Lo que <strong>no</strong> sabemos que sabemos</li>\n  <li>Lo que <strong>no</strong> sabemos que <strong>no</strong> sabemos</li>\n</ol>\n\n<p>La representación tradicional es la siguiente:</p>\n\n<p><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_800/v1688048267/Ilustracio%CC%81n_sin_ti%CC%81tulo_5_lpvjyv.png\" alt=\"Matriz de Rumsfeld\" class=\"align-center\" /></p>\n\n<p>Pero no me gusta porque pone las cuatro categorías como del mismo tamaño. Mi representación personal, que me parece que guarda mejor las proporciones es esta:</p>\n\n<p><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_800/v1688048203/Ilustracio%CC%81n_sin_ti%CC%81tulo_6_lonjhl.png\" alt=\"Matriz de Rumsfeld\" class=\"align-center\" /></p>\n\n<p>Bueno, haciéndola un poco más legible (y rompiendo las proporciones) quedaría así:</p>\n\n<p><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_800/v1688048200/Ilustracio%CC%81n_sin_ti%CC%81tulo_8_rg17f0.png\" alt=\"Matriz de Rumsfeld\" class=\"align-center\" /></p>\n\n<p>Pero quiero que te quedes con la idea de una frase que escuché en una serie llamada Dark: “Lo que sabemos que sabemos es una gota, lo que no sabemos es un océano.”</p>\n\n<p><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1688017245/5557d4f59b6ee4332ffae7f2a68513b7_n0ci5o.png\" alt=\"Escena de Dark\" /></p>\n\n<h2 id=\"ejemplos\">Ejemplos</h2>\n\n<p>Pongamos algunos ejemplos de cada categoría para entenderlos mejor.</p>\n\n<h3 id=\"categoría-1-lo-que-sabemos-que-sabemos\">Categoría 1: Lo que sabemos que sabemos</h3>\n\n<p>En este área están todas las cosas que nuestra consciencia puede encontrar y a veces incluso explicar. Por ejemplo si eres programador sabes que sabes algún lenguaje de programación, como Python, Go, Scala. Hablando del futuro sabemos que es muy probable que todos estos lenguajes tengan nuevas versiones, o que se encuentren vulnerabilidades en ellos y que se tengan que actualizar.</p>\n\n<p>También podríamos incluir el conocimiento académico, cosas que hayamos estudiado recientemente y cosas similares.</p>\n\n<h2 id=\"categoría-2-lo-que-sabemos-que-no-sabemos\">Categoría 2: Lo que sabemos que no sabemos</h2>\n\n<p>Siguiendo el ejemplo de los lenguajes de programación, normalmente sabemos uno o dos, pero estamos conscientes de que no conocemos su funcionamiento interno, o que no conocemos otros lenguajes, por ejemplo Ocaml, Haskell, etc. O sabemos que no podemos montar una infraestructura de Kubernetes, pero sabemos que existe y que hay gente que lo sabe hacer, así que podríamos investigarlo. También hay cosas que son imposibles de conocer y lo sabemos, por ejemplo, cuando va a salir exactamente la próxima versión de Python.</p>\n\n<h2 id=\"categoría-3-lo-que-no-sabemos-que-sabemos\">Categoría 3: Lo que no sabemos que sabemos</h2>\n\n<p>Aquí se empiezan a  poner difíciles las cosas, ¿cómo que hay cosas que no sabemos que sabemos? Este es el conocimiento tácito, cosas que hemos adquirido indirectamente o que ya están tan interiorizadas que no nos damos cuenta que sabemos. Por ejemplo cuando eres programador no te das cuenta que <em>estás haciendo matemáticas</em> con el simple hecho de programar. Entonces sabes matemáticas (por lo menos una rama de ellas), pero no te das cuenta. Otro ejemplo es con nuestro lenguaje natural, sabemos conjugar en todas las formas de subjuntivo, pero no sabíamos ni cómo se llama eso.</p>\n\n<p>Una sub-categoría este tipo de conocimiento es el que tenemos pero no nos damos cuenta que es relevante para el problema en cuestión que estamos tratando.</p>\n\n<h2 id=\"categoría-4-lo-que-no-sabemos-que-no-sabemos\">Categoría 4: Lo que no sabemos que no sabemos</h2>\n\n<p>Esta es la más difícil de entender, en inglés le llaman los “unknown unknowns”  y son todas aquellas cosas que no sabíamos siquiera que teníamos que preguntar. En el caso de los lenguajes de programación, por ejemplo está el caso de los lenguajes que ni siquiera hemos escuchado su nombre, o de todos aquellos conceptos que no sabemos que existen. Por ejemplo, si no sabemos que existe la programación funcional, no sabemos que no sabemos programación funcional.</p>\n\n<p>Respecto al futuro, este conocimiento son aquellas cosas que no podemos prever que pasarán, por ejemplo, que un proyecto dejará de mantenerse de manera súbita, que su autor principal morirá, etc.</p>\n\n<p>Cuando eres completamente nuevo en un campo, esta parte es tan abrumadora y se come completamente a la categoría 2, las de las cosas que sabemos que no sabemos, que es muy fácil pensar que sabes todo lo que hay que saber, pero no es así. Cuando vas conociendo más el área o el tema, vas sacando cosas de esta categoría y las vas poniendo en la categoría 2, las cosas que sabes que no sabes, y ahí es cuando empiezas a <em>de verdad</em> conocer algo.</p>\n\n<p>Lo más peligroso (y también la mayores oportunidades) para los proyectos y para nosotros están en esta categoría.</p>\n\n<h2 id=\"cómo-nos-ayuda-esta-clasificación\">¿Cómo nos ayuda esta clasificación?</h2>\n\n<p>Esta matriz nos da consciencia de la cantidad de conocimiento <strong>que nos hace falta</strong> y nos hace pensar además que hay cosas que ni siquiera nos imaginamos que no sabemos.</p>\n\n<p>La matriz de Rumsfeld, está principalmente considerada como una herramienta para la toma de decisiones y el <strong>análisis de riesgos</strong>. Las principales formas de aplicarla son:</p>\n\n<ol>\n  <li><strong>Al planear de proyectos</strong>, en donde podemos analizar las cuatro categorías para encontrar los riesgos de que un proyecto sea factible y salga en el tiempo y presupuesto planeados.</li>\n  <li><strong>Al escoger tu stack tecnológico</strong>. Recuerda que cuando empiezas a conocer algo puedes sentir que lo sabes todo y tener una confianza excesiva al tener pocas preguntas sobre el tema, pero esto sólo es una señal de que la categoría 4, los desconocidos desconocidos, es demasiado grande. Eso es exactamente lo que pasa con las tecnologías demasiado nuevas o que estás empezando a conocer, lo que puede hacer que un proyecto se vuelva inviable. Por eso, guiarte por esta matriz para escoger la tecnología que vas a usar te puede proteger de tomar decisiones demasiado arriesgadas.</li>\n  <li><strong>Desarrollo de software resiliente</strong>. Al evaluar contra qué te deberías proteger, vale tener en cuenta que hay cosas que son imposibles de predecir o imposibles de saber. Esto te llevará a fortalecer las áreas del sistema críticas para recuperarse de cualquier problema, conocido o desconocido, que puedan afectar su funcionamiento general.</li>\n</ol>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>La matriz del conocimiento nos ayuda a poner los pies en la tierra respecto a los riesgos y lo que de verdad podemos considerar que sabemos. Úsala para planear tus proyectos, escoger tu tecnología y proteger tus sistemas contra cosas que pueden ser catastróficas.</p>\n",
      "date_published": "Thu, 29 Jun 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/06/27/sigue-el-ciclo-de-la-creatividad.html",
      "url": "https://blog.thedojo.mx/2023/06/27/sigue-el-ciclo-de-la-creatividad.html",
      "title": "Sigue el ciclo de la creatividad",
      "content_html": "<p>Hay algunas personas que creen que el desarrollo de software sólo trata de resolver problemas analíticamente, pero lo cierto es que para encontrar soluciones siempre se requiere de creatividad.</p>\n\n<p>Sin embargo, muchas veces pensamos que la creatividad como desarrolladores de software no es nuestro fuerte, pero no hay nada más lejos de la realidad. Si te has dedicado exitosamente a esto por un tiempo, has demostrado que eres creativo o creativa, sólo que no de la manera que se considera tradicionalmente, eso que tiene que ver con el arte, la belleza y otras cosas.</p>\n\n<p>Tu creatividad generalmente se demuestra en la aplicación y mezcla de ideas para resolver problemas en nuevas situaciones.</p>\n\n<p>En el libro <a href=\"https://kadavy.medium.com/mind-management-not-time-management-25ebd3a58dc6\"><strong>“Mind Management, Not Time Management”</strong> de David Kadavy</a>, se habla de un ciclo de creatividad y en este artículo lo quiero aplicar a nuestro trabajo de desarrollo de software.</p>\n\n<h2 id=\"el-ciclo-de-la-creatividad\">El ciclo de la creatividad</h2>\n\n<p>Creo que esto no te va enseñar nada nuevo, porque probablemente lo <em>has vivido</em> muchas veces. Pero vamos a ponerle estructura y nombres a los diferentes pasos para que podamos replicarlo de manera más consciente.</p>\n\n<p>El ciclo de la creatividad está compuesto por cuatro fases:</p>\n\n<ul>\n  <li><strong>Preparación</strong>: Tienes que obtener la mayor cantidad información, estudiar el problema y se <strong>analizar</strong> las posibles soluciones. En nuestro caso incluso puede que tengamos que hacer algunas pruebas de concepto. Es muy importante entender que en esta etapa <strong>no vas resolver el problema</strong>, si encuentras algún tipo de bloqueo debes dejarlo pasar y seguir explorando.</li>\n  <li><strong>Incubación</strong>: En esta fase tienes que de pensar en el problema, se hace otra cosa, se descansa, se duerme, se hace ejercicio. Tu mente procesará lo que acabas de leer, de manera inconsciente.</li>\n  <li><strong>Iluminación</strong>: Esta parte no la puedes forzar, a veces incluso tienes que repetir las dos fases de manera cíclica hasta que llega la respuesta. Aquí es donde todo parece que hace click y la solución aparece “de la nada” (ya sabes que no es así porque has hecho mucho trabajo previo.)</li>\n  <li><strong>Verificación</strong>: Ahora que tienes una idea, falta comprobarla y más importante aún: llevarla a cabo. En esta tienes que asegurarte que la solución que encontraste es correcta, <em>o tienes que hacer lo suficiente para empezar a probarla</em>. Puede que te equivoques y tengas que volver a empezar el ciclo, pero con nuevos conocimientos.</li>\n</ul>\n\n<p>Este ciclo me pareció muy interesante porque se me hace equivalente en pasos a los pasos que <strong>George Polya</strong> propone. En su libro <strong>“How to Solve It”</strong> habla de cuatro pasos para resolver problemas:</p>\n\n<ol>\n  <li>Entender el problema == Preparación e Incubación</li>\n  <li>Idear un plan == Incubación e Iluminación (La parte <strong><em>más difícil</em></strong>, Polya dice que si tienes un plan, ya casi resolviste el problema)</li>\n  <li>Llevar a cabo el plan == Verificación</li>\n  <li>Revisar el plan == Verificación</li>\n</ol>\n\n<h2 id=\"ejemplo\">Ejemplo</h2>\n\n<p>El ejemplo más clásico en el que usamos el ciclo de la creatividad naturalmente es cuando estamos resolviendo un bug difícil. Veamos los pasos:</p>\n\n<ol>\n  <li>\n    <p>Preparación: Intentamos entender el bug, y el comportamiento esperado, consultamos la documentación o el código que lo está produciendo. Si es lo suficientemente difícil, este bug se va con nosotros a dormir.</p>\n  </li>\n  <li>\n    <p>Incubación: Después de sentirte derrotado por el bug, te alejas, ya sea porque terminó el día de trabajo, porque te vas a hacer otras cosas o porque simplemente te quieres despejar.</p>\n  </li>\n  <li>\n    <p><strong>Iluminación</strong>: Durante alguna otra actividad, como bañándote, caminando, haciendo ejercicio o también cuando regreses al código, ves la solución, como si siempre hubiera estado ahí, de manera obvia.</p>\n  </li>\n  <li>\n    <p>Verificación: Implementas la solución y pruebas que todo esté funcionando como debería.</p>\n  </li>\n</ol>\n\n<p><strong>¿Ves cómo sí te ha pasado?</strong> Ese es el ciclo de la creatividad, que nosotros usamos resolviendo problemas. Veamos algunas formas de extenderlo y aprovecharlo mejor.</p>\n\n<h2 id=\"aplicación-el-poder-de-la-preparación\">Aplicación: el poder de la preparación</h2>\n\n<p>Ahora que ya tienes un nombre para esto que te pasa muy constantemente, puedes aprovecharlo para desencadenarlo intencionalmente.</p>\n\n<p>Antes, pensemos un poco. ¿Cuál es la parte del ciclo que nos interesa aprovechar? Para mi es el poder de <strong>incubación</strong>, que es lo que produce la iluminación, o sea, lo que hace que te lleguen las ideas para resolver tu problema de manera creativa.</p>\n\n<p>Pero, ¿cómo vas a incubar si no tienes nada que hacer crecer? Es aquí donde entra el valor de la preparación. Si quieres resolver un problema difícil, inclusive uno que sientes que ahora mismo está un poco por encima de tus capacidades, la mejor manera de hacerlo es aprovechando este ciclo. Primero te preparas lo mejo que puedas, estudiando el problema, analizando los posibles caminos que puedes seguir e incluso haciendo algunas pruebas de concepto. Seguro que esto ya lo haces.</p>\n\n<p>Después y esto es la parte más importante de este artículo (y la que te puede estar fallando), tienes que <strong>alejarte del problema</strong>. Así es, olvídate de él, cambia de problema, ve a dormir, sal a pasear, date un baño. Tienes que hacer algo que ocupe tu mente.</p>\n\n<p>David Kadavy dice en su libro que esto te permite olvidarte de las ideas que no funcionan y fortalecer las que sí, y me parece una buena propuesta. Si lo comparas con un algoritmo, buscar una solución a un problema es como hacer una búsqueda en un árbol, sólo que este árbol tiene más ramas de las que puedes seguir, así que tienes que podarlas. La incubación es la poda, que además fortalece las ramas que es más probable que te lleven a la solución.</p>\n\n<p>Esto también se puede aplicar de manera más sencilla.Por ejemplo, ¿tienes que diseñar una pieza de software y sientes que no tienes ni idea de por dónde empezar? Combinando las enseñanzas de Polya con el ciclo de la creatividad, lo primero es definir completamente el problema. Una vez que sientas que lo has entendido (muchas veces ayuda ponerlo por escrito e incluso pedir que alguien más lo revise).</p>\n\n<p>Después de esto, <em>sobre todo si no tienes una solución clara</em>, o propuestas que hacer, <strong>busca alejarte lo más posible</strong>. Es por eso que muchos profesionales veteranos y exitosos tienen actividades alternas, alejadas de la programación e incluso de la computadora. Cuando regreses a trabajar sobre el problema, es mucho más probable que tengas una solución.</p>\n\n<p>Se que esto suena mágico, pero nada te puede convencer más que la propia que ya tienes resolviendo problemas de otro estilo. Si esto no funciona, recuerda que puedes repetir el ciclo tantas veces como sea necesario.</p>\n\n<p>Claro, esto no asegura que la solución te llegará mágicamente siempre, pero con esto aumentamos las probabilidades de que tu naturaleza creativa trabaje por ti.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>Siempre que puedas, frente a problemas difíciles, aplica este ciclo: prepárate lo mejor que puedas, explorando soluciones, asegurándote de entender todas la variables del problema, escribiendo la definición del problema. Después <strong>aléjate de problema</strong>, así permitirás que se <strong>incube</strong>.</p>\n\n<p>Finalmente, regresa y trata de resolverlo de nuevo. Claro que después de esto tienes que ejecutar y verificar tu solución.</p>\n\n<p>Espero que esta información te sea útil y que la puedas aplicar en tu día a día.</p>\n",
      "date_published": "Tue, 27 Jun 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/06/22/modelos-mentales-para-desarrolladores-elementales.html",
      "url": "https://blog.thedojo.mx/2023/06/22/modelos-mentales-para-desarrolladores-elementales.html",
      "title": "Modelos mentales para desarrolladores: modelos elementales",
      "content_html": "<p>La <strong>mente</strong> es la principal herramienta del desarrollador de software. Puedes ayudar a que se desempeñe mejor si le das, a su vez, herramientas que te permitan <em>organizar, comprender, combinar y analizar más rápido la información</em>. Estas herramientas además te pueden ayudar a ver cosas claramente que antes eran imposibles de ver, o a llegar más profundo en los análisis.</p>\n\n<p>Estas herramientas son los <strong>modelos mentales</strong>, que en este artículo explicaremos, pero además daremos algunos ejemplos que te servirán directamente como desarrollador. Estos ejemplos son, a nuestro modo de ver, los modelos esenciales que debes conocer. Empecemos dando una definición clara.</p>\n\n<h2 id=\"qué-son-los-modelos-mentales\">¿Qué son los modelos mentales?</h2>\n\n<p>Un modelo mental es una estructura que te permite organizar la información que recibes o que observas, para que puedas ver aspectos particulares de esta, aplicarle proyecciones o simplemente para que puedas entenderla mejor. También se puede pensar en ellos como en <em>lentes</em> que te permiten ver el mundo de una forma particular.</p>\n\n<p>Los desarrolladores de software estamos acostumbrados a usar modelos para representar la realidad. Recuerda que un modelo es una abstracción, <strong>una representación simplificada</strong> de la realidad que se enfoca en ciertos elementos y deja fuera otros.</p>\n\n<p>Los modelos mentales son esto mismo, pero la diferencia es que tienen aplicación a través de muchas situaciones. Estos modelos mentales te permiten usar la información de manera más eficiente y, a veces, ver la realidad más claramente. <strong>Charlie Munger</strong>, uno de los principales proponentes de los modelos mentales, dice que para pensar efectivamente, debes tener una <strong>malla o red de modelos mentales</strong> que puedas usar para pensar mejor. Algo a lo que se pueden parece un poco es a los patrones de diseño, pero aplicados a la vida real.</p>\n\n<p>Nuestro objetivo es ayudarte a construir esta malla de modelos mentales que te permitan ser más efectivo en el desarrollo de software. Empecemos con los más básicos.</p>\n\n<h3 id=\"la-navaja-de-ockham\">La navaja de Ockham</h3>\n\n<p>Este es uno de los modelos mentales que más personas conocen. En líneas generales establece que cuando estés buscando explicaciones a algo que hayas observado y estés decidiendo entre varios posibles caminos, <strong>el más sencillo es el que tiene la mayor probabilidad de ser la explicación correcta</strong>.</p>\n\n<p>¿Cómo se puede aplicar a los problemas que nos enfrentamos <em>comúnmente</em> como desarrolladores? Siempre que estés decidiendo entre diferentes diseños que cumplen con los requerimientos <strong>actuales</strong>, escoge el más sencillo de los diseños, sin dejarte influir demasiado <em>por que podrías necesitar en el futuro</em>. Esto se conecta con el principio de <a href=\"https://martinfowler.com/bliki/Yagni.html\">YAGNI</a> (You aren’t gonna need it), que dice que no debes implementar cosas que no necesitas ahora, porque podrías necesitarlas en el futuro. También se conecta con el principio de buscar la simplicidad al máximo en el desarrollo de software.</p>\n\n<p>También lo puedes aplicar a los procesos que modelas en el software: cuando estés descubriendo el por qué de algo,</p>\n\n<h3 id=\"el-mapa-no-es-el-territorio\">El mapa no es el territorio</h3>\n\n<p>Los desarrolladores de software trabajamos creando <strong>modelos</strong> de la realidad que pueden ser representados dentro de una computadora, muchas veces para simular procesos o simplemente capturamos ideas que ya son abstractas para que corran dentro de la computadora.</p>\n\n<p>Un <strong>mapa</strong> es un <strong>modelo</strong> de un territorio físico. Pero podemos cometer el error de pensar que el mapa y el territorio son equivalentes, cuando lo cierto es que, al ser un modelo, el mapa es una representación imperfecta y simplificada del territorio real.</p>\n\n<p>Así son todos los modelos y debemos recordarlo, para muchos casos, la mayoría yo diría, <strong>no existe un modelo absolutamente</strong> correcto y todos dejan algo fuera. Todos son arbitrarios y si alguien de nuestro equipo tiene una visión diferente, deberíamos escucharla, tratar de entenderla y ver cómo podemos integrar ambas visiones en un solo modelo.</p>\n\n<p>Tus representaciones, tus modelos, <strong>no son la realidad</strong>, por lo que siempre pueden mejorarse. Además de que confiar en un modelo como en una guía perfecta te puede llevar a cometer errores graves. Es por eso que es bueno recordar siempre, que los modelos (los mapas) son representaciones imperfectas de la realidad (el territorio), y que algunos son más <em>convenientes</em> que otros para diferentes acciones o situaciones, además de que no <strong>existe EL MODELO correcto</strong> para cierta situación.</p>\n\n<p>Si aplicas este modelo mental a los mismos modelos mentales, verás por qué necesitas una variedad de ellos para poder pensar mejor.</p>\n\n<h2 id=\"el-ganador-se-lo-lleva-todo\">El ganador se lo lleva todo</h2>\n\n<p>Hay procesos en el mundo, de hecho, muchos, en los que los “premios” (puedes pensar en ellos como las recompensas o beneficios de una actividad) no se distribuyen uniformemente, sino que las ganancias se acumulan en un sólo lugar, para que unos pocos se lleven la mayoría de los beneficios.</p>\n\n<p>En la actualidad, muchos procesos se comportan así, pero además se exacerba con la tecnología digital, en la que los ganadores de procesos como por la creación de contenido. Para aplicar este modelo, debes aprender a ver quién se lleva la mayoría de los beneficios.</p>\n\n<p>Este modelo aplicado al software se puede ver en la puesta en marcha de las aplicaciones, pero de forma inversa. A diferencia de lo que puede pasar en otras industrias, un proyecto a medio terminar provee un valor casi nulo. Yo me atrevería a decir que un proyecto de software que no esté en producción, vale cero. Así que, siempre esfuérzate por entregar el software o ponerlo en manos de tus usuarios lo más pronto posible.</p>\n\n<h2 id=\"la-falacia-del-costo-hundido\">La falacia del costo hundido</h2>\n\n<p>Todos hemos enfrentado esta pregunta: ¿sigo invirtiendo tiempo y esfuerzo en este proyecto que no está dando resultados? <strong>¿Hasta cuando debo seguir invirtiendo en este proyecto?</strong></p>\n\n<p>A veces llegamos a la conclusión de que lo mejor sería dejar de invertir en ese proyecto <strong>YA MISMO</strong>, pero algo nos detiene: <strong>el tiempo y esfuerzo que ya hemos invertido</strong>. Esto es el <strong>costo hundido</strong>. Los seres humanos tenemos naturalmente más aversión por <em>perder</em> algo, que deseos de <em>ganar</em> más cosas.</p>\n\n<p>Pensar que lo que ya invertimos lo vamos a perder si dejamos algo que no nos ha dado resultados (y no tiene pinta de que los vaya a dar) nos detiene de tomar decisiones que son muy claras: si no <em>hubiéramos</em> invertido ese tiempo y esfuerzo, no tendríamos razones para seguir invirtiendo en este proyecto o aunque sea para mantenerlo. O sea que una inversión pasada, en vez de producirnos beneficios, nos está produciendo pérdidas, por el puro temor a perderla.</p>\n\n<p>Este modelo mental se puede aplicar a los proyectos de desarrollo de software que después de cambiar de estrategia muchas veces no han dado rendimientos. Además como desarrolladores a veces estamos orgullosos de la arquitectura o los logros técnicos de cierto sistema o cierta parte del código, pero ha llegado el momento de reemplazarla por algo que se adecúe mejor a las necesidades actuales.</p>\n\n<p>Recuerda que el esfuerzo o tiempo que ya invertiste <strong>nunca es una razón suficiente</strong> para mantener algo, sobre todo si hay razones para tomar otro camino.</p>\n\n<h3 id=\"rendimientos-decrecientes\">Rendimientos decrecientes</h3>\n\n<p>Hay muchos procesos en la vida cotidiana en los que observamos que “mientras más, mejor”. Como máquinas de generalización que somos, tendemos a extender este pensamiento a todas las cosas en la vida, pero muchas cosas, no se comportan así.</p>\n\n<p>De eso trata la ley de rendimientos decrecientes, te hace entender que <strong>no siempre más es mejor</strong>. De hecho, en la mayoría de los procesos naturales se cumple una ley:</p>\n\n<blockquote>\n  <p>Por cada unidad añadida, <strong>el rendimiento de la siguiente unidad va a disminuir</strong>.</p>\n</blockquote>\n\n<p>Así es: hay muchas cosas en la naturaleza que mientras más tienes de ellas, cada cosa que añades te va a dar menos beneficios que la cosa anterior que añadiste. Algunos ejemplos empíricos:</p>\n\n<ul>\n  <li>\n    <p>Hacer ejercicio es muy bueno, si haces por lo menos 1 hora 4 veces a la semana ejercicio de cierto tipo te vas a sentir muy bien (claro combinado con otros factores como la buena alimentación). Pero si haces el doble de ejercicio, no te vas a sentir el doble de bien, de hecho si llegas a cierto punto, como hacer 3 horas diarias te vas a sentir excesivamente cansado y puede que con el tiempo tu cuerpo muestre señales de fatiga.</p>\n  </li>\n  <li>\n    <p>Si estás en un restaurante y pides un postre, el primero te va a saber muy bien, pero si pides otro, el segundo no te va a saber tan bien como el primero, y si pides otro, puede que te enfermes y termines odiando ese postre específico.</p>\n  </li>\n  <li>\n    <p>Cuando riegas una planta, echarle agua es bueno hasta cierto punto, si le echas demasiada, la planta se va a ahogar y se va a morir.</p>\n  </li>\n  <li>\n    <p>Salir al sol está bien, es bueno para nuestra salud si lo haces a la hora correcta y cuidas la cantidad de sol a la que te expones. Pero si te expones demasiado, te vas a quemar y vas a tener problemas de salud.</p>\n  </li>\n  <li>\n    <p>Finalmente, el dinero: tener dinero es bueno hasta cierto punto, pero hay una cantidad que a mi parecer depende de el lugar en el que vivas, que tener dinero extra 1) no te va a hacer más feliz, 2) incrementar más tu riqueza te meterá en problemas que no tendrías antes. La siguiente gráfica muestra la relación entre el dinero y la felicidad:</p>\n  </li>\n</ul>\n\n<p><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_500/v1687450180/Ilustracio%CC%81n_sin_ti%CC%81tulo_4_qhinhf.png\" alt=\"Gráfica de rendimientos decrecientes\" class=\"align-center\" /></p>\n\n<p>En estos ejemplos hablamos de cosas buenas que primero te van dando cada vez menos beneficios, y luego se pueden volver perjudiciales. Para aplicarlo al desarrollo de software piensa en los siguientes ejemplos:</p>\n\n<ul>\n  <li>\n    <p><strong>Equipos</strong>: Un equipo bien balanceado es <em>necesario</em> para hacer proyectos serios, pero eso no significa que mientras más grande el equipo, mejor. Cada persona agregada al proyecto va agregando menos valor que la anterior y muy rápido se llega al punto en el que una persona más añadida daña la productividad del equipo.</p>\n  </li>\n  <li>\n    <p><strong>Horas de trabajo</strong>: A (casi) todos nos gusta nuestro trabajo y para lograr nuestros objetivos, en general, debemos de ponerle bastantes horas. Sin embargo, si trabajamos demasiado en un corto espacio de tiempo van a pasar dos cosas progresivamente: 1) Cada hora de trabajo sin que te distraigas va a rendir menos y 2) si sigues trabajando a pesar de esto, vas a cometer errores que después te puede costar mucho tiempo arreglar, o incluso cometer errores que no puedas arreglar, catastróficos (por ejemplo: un DELETE sin WHERE).</p>\n  </li>\n  <li>\n    <p><strong>Abstracción</strong>: En el desarrollo de software, la abstracción es una herramienta esencial y siempre se necesita de ella para crear buen software. Pero si abstraes demasiado, tu código se vuelve inmantenible y muy difícil de entender. Igual que con otras cosas, el punto de retornos negativos de la abstracción es muy fácil de alcanzar.</p>\n  </li>\n  <li>\n    <p><strong>Pruebas unitarias</strong>: Las pruebas unitarias son una gran herramienta tanto para asegurar la calidad del software como para ayudar en su diseño. Sin embargo, hay una tendencia a querer buscar que todo tu código esté cubierto por pruebas unitarias: <strong>tener 100% de cobertura</strong>. Este es un caso muy característico de rendimientos decrecientes: mientras más pruebas unitarias tengas, cada prueba unitaria que agregues va a darte menos beneficios que la anterior, pero se pone peor. Intentar tener 100% de pruebas te lleva a hacer código que mucho más complejo y difícil de mantener.</p>\n  </li>\n</ul>\n\n<p>Para mi, este es uno de los modelos mentales más útiles, debido a que estamos en un mundo en el que ser eficiente en recursos te puede dar una gran ventaja competitiva.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>Los modelos mentales son herramientas para organizar la información que son muy útiles para personas que trabajan principalmente pensando y analizando el mundo real. Los desarrolladores de software pertenecemos a ese grupo, así que aprender a modelar la realidad de forma más efectiva puede darnos una gran ventaja para resolver problemas y así avanzar más rápido en nuestra carrera.</p>\n\n<p>Seguiremos creando más artículos hablando de esto, para  darte herramientas que te permitan ser un mejor desarrollador de software y mejor profesional.</p>\n",
      "date_published": "Thu, 22 Jun 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/06/17/son-aplicables-y-practicos-los-principios-solid.html",
      "url": "https://blog.thedojo.mx/2023/06/17/son-aplicables-y-practicos-los-principios-solid.html",
      "title": "¿Son aplicables y prácticos los principios SOLID?",
      "content_html": "<p>Los <strong>principios SOLID</strong>, se enseñan como verdades incuestionables sobre el buen desarrollo de software. Aunque, justo por la educación, antes era completamente partidario de estos, con el tiempo me fui dando cuenta de varias de las fallas que presentan.</p>\n\n<p>En este artículo te voy a hablar de las fallas generales como conjunto, pero también es un índice para una serie de artículos que escribí sobre cada uno de ellos, analizándolo a profundidad.</p>\n\n<h2 id=\"ambigüedad\">Ambigüedad</h2>\n\n<p>Cuando buscas la explicación sobre cómo aplicar alguno de estos principios, normalmente encuentras muchas explicaciones diferentes. Algunas de estas explicaciones se contraponen, siguen siendo ambiguas, o de plano no se entienden.</p>\n\n<p>Con el principio que más pasa es con el “Single Responsibility” (SRP), en el cuál diferentes personas no nos ponemos de acuerdo respecto a lo que una “Responsabilidad” significa. Pero también pasa con la aplicación de los demás principios a diferentes entornos de programación.</p>\n\n<h2 id=\"complican-exageradamente-el-código\">Complican exageradamente el código</h2>\n\n<p>La aplicación sin razonamiento profundo de estos principios puede complicar el código de manera exagerada, sobre todo en lenguajes inflexibles o con sistemas de tipos complicados (sí, te estoy viendo a ti, <strong>Java</strong>), que justo es donde más se aplica.</p>\n\n<p>El ejemplo más claro de esto es el “Dependency Inversion Principle”, que te lleva a hacer cosas bastante raras en el código para lograrlo, como ya dije, sobre todo cuando el sistema de tipos te lo complica.</p>\n\n<p>Y aunque es cierto que a veces es necesario y bastante útil hacer lo que este principio propone, para mi el 80% del software no lo necesita y sólo estás haciendo una sobre-ingeniería que no se justifica.</p>\n\n<h2 id=\"se-usan-como-un-código-moral\">Se usan como un código moral</h2>\n\n<p>Los principios SOLID, entre otras cosas, normalmente se usan para avergonzar a las personas que no los conocen o no los aplican. Normalmente hablan de tu valía como desarrollador@ de software basado en el supuesto conocimiento de cosas como estas, y otros principio o reglas (completamente) arbitrarias, sobre todo basadas en el libro Clean Code.</p>\n\n<p>Esta revoltura de principios morales y conveniencia técnica es un <strong>gran error para la comunidad de software</strong>, ya que lleva a la sobre-ingeniería, a la aplicación ciega de principios y técnicas que no tienen sentido en tu caso particular e incluso al desprecio del trabajo de otros programadores.</p>\n\n<p>Para mi, este es el punto más grave, tal vez no directamente de los principios SOLID, sino de la forma en la que se enseñan.</p>\n\n<h2 id=\"análisis-más-profundo\">Análisis más profundo</h2>\n\n<p>En este blog hemos escrito 5 artículos analizando cada uno de los principios que lo componen, viendo si conviene aplicarlos y describiendo alternativas. En la mayoría de los casos incluso hablamos de principios más profundos (lo que nos hace ver que los “principios SOLID” debería ser algo como “reglas SOLID”).</p>\n\n<p>Aquí los puedes ver:</p>\n\n<ul>\n  <li>SRP: <a href=\"/2022/12/01/analisis-de-los-principios-solid-principio-de-responsabilidad-unica.html\">Análisis de los Principios SOLID: Principio de Responsabilidad Única</a></li>\n  <li>OCP: <a href=\"/2022/12/03/el-principio-abierto-cerrado-open-closed.html\">El Principio Abierto/Cerrado</a></li>\n  <li>LSP: <a href=\"/2023/03/06/el-principio-de-substitucion-de-liskov.html\">El Principio de Sustitución de Liskov</a></li>\n  <li>ISP: <a href=\"/2023/04/01/el-principio-de-segregacion-de-interfaces.html\">El Principio de Segregación de Interfaces</a></li>\n  <li>DIP: <a href=\"/2023/04/22/el-principio-de-inversion-de-dependencias.html\">El Principio de Inversión de Dependencias</a></li>\n</ul>\n\n<p>Espero que estos artículos te sirvan para analizar más profundamente lo que todos enseñan como dogmas que se deben de seguir al pie de la letra, bajo la amenaza de no ser un buen programador o programadora que se irá al infierno de los desarrolladores si no lo sigue.</p>\n",
      "date_published": "Sat, 17 Jun 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/06/15/libros-que-todo-desarrollador-de-software-deberia-leer-desarrollo-de-carrera.html",
      "url": "https://blog.thedojo.mx/2023/06/15/libros-que-todo-desarrollador-de-software-deberia-leer-desarrollo-de-carrera.html",
      "title": "Libros que todo desarrollador de software debería leer: desarrollo de carrera",
      "content_html": "<p>En este artículo vamos a hablar de los libros que te pueden ayudar a avanzar en tu carrera como desarrollador de software, que desde mi punto de vista, son esenciales.</p>\n\n<p>Algunos desarrolladores piensan que basta simplemente con aprender a programar o diseñar software bien, pero lo cierto es que también hay que tener otras habilidades y conocimientos para que tu carrera avance a buen ritmo, y llegues a puestos de liderazgo si así lo deseas.</p>\n\n<p>En este post hablaremos de tres tipos de libros:</p>\n\n<ul>\n  <li>Consejos de carrera para desarrolladores y habilidades blandas</li>\n  <li>Libros de historia de la computación</li>\n  <li>Temas que te pueden ayudar a desarrollar habilidades de soporte</li>\n</ul>\n\n<p>Como siempre, si tienes alguna recomendación, puedes dejarla en los comentarios. Empecemos.</p>\n\n<h2 id=\"desarrollo-de-carrera\">Desarrollo de carrera</h2>\n\n<p>En estos libros verás consejos específicos de desarrolladores experimentados sobre la carrera de programador, qué habilidades y actitudes te conviene desarrollar.</p>\n\n<h3 id=\"the-pragmatic-programmer--david-thomas--andrew-hunt\">The Pragmatic Programmer | David Thomas &amp; Andrew Hunt</h3>\n\n<p><a href=\"https://pragprog.com/titles/tpp20/the-pragmatic-programmer-20th-anniversary-edition/\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686286553/71f743sOPoL._AC_UF1000_1000_QL80__vibioc.jpg\" alt=\"Portada de The Pragmatic Programmer\" class=\"align-center\" /></a></p>\n\n<p>Este es uno de los mejores libros sobre la carrera como programador, que te da consejos de dos programadores <strong>muy muy experimentados</strong>. Su tema principal es el <strong>pragmatismo</strong>, que es una filosofía que te dice que no hay una sola forma de hacer las cosas, sino que debes adaptarte a las circunstancias y hacer lo que sea necesario para lograr tus objetivos. Otra forma de ver el pragmatismo es que hay que ser práctico, y no darle tantas vueltas a las cosas.</p>\n\n<p>A grandes rasgos trata estos temas:</p>\n\n<ol>\n  <li>Introducción a la filosofía pragmática</li>\n  <li>Cómo ser pragmático al desarrollar software (nota que no es al <em>programar</em>, sino al crear programas)</li>\n  <li>Herramientas que te pueden servir para desarrollar buen software</li>\n  <li>Cómo llevar un proyecto pragmáticamente</li>\n</ol>\n\n<p>Estaba en la duda de clasificarlo entre los libros de desarrollo de software o desarrollo de carrera, porque aunque habla sobre técnicas específicas y temas técnicos, su espíritu es una meta-habilidad o una actitud hacia el desarrollo y hacia la vida: el pragmatismo.</p>\n\n<p>Puedes comprarlo aquí: <a href=\"https://amzn.to/3oXvmNk\" target=\"_blank\" rel=\"noopener\">The Pragmatic Programmer</a>.</p>\n\n<h3 id=\"the-practice-of-programming--brian-w-kernighan--rob-pike\">The Practice of Programming | Brian W. Kernighan &amp; Rob Pike</h3>\n\n<p><a href=\"https://www.goodreads.com/book/show/1032758.The_Practice_of_Programming\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686488400/71a9H3K9cgL._AC_UF1000_1000_QL80__af2e79.jpg\" alt=\"Portada de The Practice of Programming\" class=\"align-center\" /></a></p>\n\n<p>Brian W. Kernighan es un desarrollador de software, programador y científico de la computación de las grandes ligas. ¿Has escuchado sobre <code class=\"language-plaintext highlighter-rouge\">AWK</code>? Es un programa y lenguaje programación legendario, y se llama así por sus creadores: Alfred Aho, Peter Weinberger y <strong>Brian Kernighan</strong>.</p>\n\n<p><strong>Rob Pike</strong> es uno de los co-creadores del lenguaje de programación Go, y también es un desarrollador de software con mucha experiencia. Ha co-creado otros lenguajes de programación, como Oberon.</p>\n\n<p>En <strong>“The Practice of Programming”</strong> explican todas las prácticas que un desarrollador de software debe tener o aprender para desarrollar software exitosamente. Este libro se guía por los siguientes principios:</p>\n\n<ol>\n  <li>Simplicidad</li>\n  <li>Claridad</li>\n  <li>Generalidad</li>\n  <li>Automatización</li>\n</ol>\n\n<p>Estos principios son aplicados a cosas como el estilo, la documentación, las pruebas, etc. Al igual que el libro anterior, estaba dudando en clasificarlo como libro de desarrollo de software, pero creo que el enfoque general, aunque muy técnico, va más enfocado en el desarrollo de una mentalidad conveniente.</p>\n\n<p>Puedes comprarlo aquí: <a href=\"https://amzn.to/42zssMz\" target=\"_blank\" rel=\"noopener\">The Practice of Programming</a>.</p>\n\n<h3 id=\"code-ahead--yegor-bugayenko\">Code Ahead | Yegor Bugayenko</h3>\n\n<p><a href=\"https://www.yegor256.com/code-ahead.html\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686348326/yegor_code_kislix.png\" alt=\"Portada de Code Ahead\" class=\"align-center\" /></a></p>\n\n<p><strong>Yegor Bugayenko</strong> es un autor poco conocido de este lado del mundo, pero en Rusia es más famoso. Ha escrito varios libros sobre programación como <strong>“Elegant Objects”</strong> (1 y 2). Pero también escribió este libro sobre la carrera de programador, que es muy bueno.</p>\n\n<p>Yo lo describiría como una <em>visión cínica de la carrera de programación</em>, con algunas recomendaciones sobre actitudes, formas de trabajo y <strong>tácticas para progresar en tu carrera</strong>. No creo que se deba tomar como una guía, sino más bien como un contrapeso a las opiniones de carrera más tradicionales, para ampliar tu visión. Además sí creo que dice algunas verdades incómodas que no a todos les gustará escuchar.</p>\n\n<p>El punto débil de libro es su formato (que para mi falló completamente), en el que trató de hacer un historia de ficción (supongo que al estilo de The Phoenix Project), pero que en realidad sólo consiste en una serie de explicaciones del protagonista.</p>\n\n<p>A pesar de lo mencionado anteriormente, creo que es un libro que vale mucho la pena leer y que te puede ayudar a ver las cosas desde otra perspectiva.</p>\n\n<p>Puedes comprarlo en Amazon: <a href=\"https://amzn.to/43Dm0FK\" target=\"_blank\" rel=\"noopener\">Code Ahead</a></p>\n\n<h3 id=\"the-phoenix-project--gene-kim-kevin-behr--george-spafford\">The Phoenix Project | Gene Kim, Kevin Behr &amp; George Spafford</h3>\n\n<p><a href=\"https://itrevolution.com/product/the-phoenix-project/\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686458596/TPP_3rd_cover_border-664x998.jpg_ohgr0o.webp\" alt=\"Portada de The Phoenix Project\" class=\"align-center\" /></a></p>\n\n<p>Este libro, a diferencia del anterior es una novela que sí salió bien, en la que describe la progresión de alguien del área de IT que obligadamente se convierte en líder del área. Describe como es que las áreas de IT se convierten de cuellos de botella en partes que agregan valor a la empresa.</p>\n\n<p>El libro da los fundamentos de DevOps, y cuáles son los principios que todos los equipos de desarrollo de software deberían seguir para producir software más efectivamente.</p>\n\n<p>Aunque está enfocado en la operación y la entrega del software, a final de cuentas, es donde todos queremos que nuestro software llegue, así que todos los desarrolladores de software se pueden beneficiar de los principios que presenta.</p>\n\n<p>Se ha convertido en un clásico, y con justa razón. Lo puedes comprar aquí: <a href=\"https://amzn.to/3WWWMQ1\" target=\"_blank\" rel=\"noopener\">The Phoenix Project</a>.</p>\n\n<h2 id=\"libros-de-historia-de-la-informática\">Libros de historia de la informática</h2>\n\n<p>En esta sección recomendaremos algunos libros que creemos que te pueden ayudar a conocer más la historia de tu campo y que por lo tanto te ayudarán a <em>aprender de lo que ya se ha hecho</em>. Esto te ayudará a no cometer los mismos errores y más mejor, <strong>“pararte en hombros de gigantes”</strong> para poder ver más lejos.</p>\n\n<p>Afortunadamente, de estos tenemos tanto libros en inglés como en español.</p>\n\n<h3 id=\"historia-de-los-lenguajes-de-programación-años-1940-1959--manuel-rubio\">Historia de los lenguajes de programación: Años 1940-1959 | Manuel Rubio</h3>\n\n<p><a href=\"https://altenwald.com/book/histlangprog\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686489306/Screen_Shot_2023-06-11_at_7.14.50_g1d4lh.png\" alt=\"Portada de Historia de los lenguajes de programación\" class=\"align-center\" /></a></p>\n\n<p>Aquí, <a href=\"https://altenwald.com/\">Manuel Rubio</a> explica el nacimiento de las lenguajes de programación y cómo esto va de la mano con la historia de la computación. Me gusta mucho de este libro que te da una visión más amplia que la centra en US que normalmente nos dan en la escuela y en la mayoría de los libros de computación.</p>\n\n<p>Manuel hizo una investigación muy amplia, cuestiona algunas cosas implícitamente (<em>¿de verdad fue Ada Lovelace la primera programadora?</em>) y te da una visión más amplia de lo que significa la computación.</p>\n\n<p>Me gusta mucho que resalta algunas cosas que nos siguen sucediendo hoy:</p>\n\n<ul>\n  <li>Nos cuesta naturalmente despegarnos del trabajo</li>\n  <li>El campo siempre se ha resistido a las innovaciones</li>\n  <li>Siempre creemos que lo que viene después de lo que ya sabemos tiene menos valor</li>\n</ul>\n\n<p>En el blog hicimos ya un <a href=\"/2022/06/11/resumen-historia-de-los-lenguajes-de-programacion.html\" target=\"_blank\" rel=\"noopener\">resumen de este libro</a> y también hicimos un <a href=\"https://youtu.be/JDDEOi1jwDA\">resumen en video</a> pero sinceramente te recomiendo leerlo completo.</p>\n\n<p>Lo puedes comprar aquí: <a href=\"https://altenwald.com/book/histlangprog\" target=\"_blank\" rel=\"noopener\">Historia de los lenguajes de programación</a>. Si <em>necesitas</em> un descuento para comprarlo, no dudes en contactarme o contactar a Manuel, que es muy accesible y una gran persona.</p>\n\n<h3 id=\"mentes-geniales--camilo-chacón-sartori\">Mentes Geniales | Camilo Chacón Sartori</h3>\n\n<p><a href=\"https://www.amazon.com.mx/Mentes-geniales-ingenier%C3%ADa-software-ingenieros/dp/6077074797\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686488396/978607538877_xfcfmk.jpg\" alt=\"Portada de Mentes Geniales\" class=\"align-center\" /></a></p>\n\n<p><a href=\"https://camilochs.github.io/web/\">Camilo Chacón Sartori</a> es un gran desarrollador de software, pronto Doctor en Ciencias de la computación y escritor. Ha escrito varios libros de programación o temas relacionados y en realidad es un escritor (y lector, ¿se puede ser buen escritor sin leer mucho?) muy prolífico.</p>\n\n<p>En este libro, habla de 12 personas que han contribuido de diferentes formas al desarrollo de la computación y se les ha reconocido con el <strong>Premio Turing</strong>. Aunque no es un libro histórico en todo el sentido de la palabra, además de que no sigue una cronología, sí habla de importantes eventos históricos de la computación y desarrollo.</p>\n\n<p>Lo recomiendo porque no sólamente te habla de los logros de las personas que menciona, analiza su entorno, te cuenta sobre su personalidad y extrae lecciones. Además, te deja las fuentes y referencias por si quieres leer más de ellos.</p>\n\n<p>Algunos de los personajes que a mi me impactaron:</p>\n\n<ul>\n  <li><strong>Manuel Blum</strong> - El creador de CAPTCHA</li>\n  <li><strong>Michael Stonebraker</strong> - El creador de PostgreSQL</li>\n  <li><strong>Barbara Liskov</strong> - Una gran proponente de los tipos abstractos de datos</li>\n  <li><strong>Leslie Lamport</strong> - Un gran matemático que ha contribuido a la computación con cosas como el algoritmo de Paxos y TLA+</li>\n  <li><strong>Richard Manning Karp</strong> - Un matemático que ha contribuido a la computación con cosas como el algoritmo de Karp-Rabin y el análisis de complejidad de algoritmos</li>\n</ul>\n\n<p>Sin duda te llevarás muchas buenas lecciones y aprendizajes sobre el desarrollo de la computación de este libro. Lo puedes comprar aquí: <a href=\"https://amzn.to/43J2jfG\" target=\"_blank\" rel=\"noopener\">Mentes Geniales</a>.</p>\n\n<h3 id=\"dealers-of-lightning-xerox-parc-and-the-dawn-of-the-computer-ag--michael-a-hiltzik\">Dealers of Lightning: Xerox PARC and the Dawn of the Computer Ag | Michael A. Hiltzik</h3>\n\n<p><a href=\"https://www.goodreads.com/book/show/1101290.Dealers_of_Lightning\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686549204/61pJVqUUoJL._AC_UF1000_1000_QL80__gevadr.jpg\" alt=\"Portada de Dealers of Lightning\" class=\"align-center\" /></a></p>\n\n<p>En los años 70 y 80’s, la compañía <strong>Xerox</strong> (sí, la de las impresoras), consiguió un equipo de personas muy hábiles con la tecnología. Eran conocidos como el <strong>PARC</strong> (Palo Alto Research Center) y fueron los creadores de muchas de las tecnologías que hoy usamos, como:</p>\n\n<ul>\n  <li>La primera computadora personal</li>\n  <li>La interfaz gráfica</li>\n  <li>La impresora láser</li>\n</ul>\n\n<p>Todas estas tecnologías cambiaron el mundo, ayudando a crear la tecnología que hoy en día nos da trabajo y ha moldeado todas las industrias y la vida en general.</p>\n\n<p>Este libro está basado en entrevistas con las personas que vieron de cerca estas creaciones y que muestran cómo es que Xerox nunca vio el potencial de las creaciones de este equipo de ingenieros. Si quieres aprender sobre la historia de la tecnología que tenemos hoy, ver cómo se forman equipos de altísimo rendimiento y aumentar tus posibilidades de crear algo que sea digno de mención, este libro es un gran recurso.</p>\n\n<p>Puedes comprarlo aquí: <a href=\"https://amzn.to/3Cs5QTm\" target=\"_blank\" rel=\"noopener\">Dealers of Lightning</a>.</p>\n\n<h3 id=\"la-catedral-de-turing--george-dyson\">La Catedral de Turing | George Dyson</h3>\n\n<p><a href=\"https://books.google.com.mx/books/about/La_catedral_de_Turing.html?id=QvjeBQAAQBAJ&amp;redir_esc=y\" target=\"_blank\" rel=\"noopener\"><img src=\"\" alt=\"Portada de La Catedral de Turing\" class=\"align-center\" /></a></p>\n\n<p>En este libro se narra el comienzo de la computación después de la segunda guerra mundial y de todos los actores que tuvieron un impacto en el desarrollo de la computación moderna.</p>\n\n<p>Es una crónica muy completa, junto con la explicación de muchos conceptos de la computación. El autor, hijo del físico <a href=\"https://www.profisica.cl/index.php/component/content/article/115-biografias/216-freeman-dyson?Itemid=542\">Freeman Dyson</a>, tuvo acceso a muchos de los actores de la historia y a sus documentos, lo que le permitió hacer una libro que revela muchos detalles.</p>\n\n<p>Sin duda es algo que muchos dedicados a esta área del conocimiento queremos leer. Lo puedes comprar aquí: <a href=\"https://amzn.to/3NoQKV6\" target=\"_blank\" rel=\"noopener\">La Catedral de Turing</a>.</p>\n\n<h2 id=\"otros-temas-relacionados\">Otros temas relacionados</h2>\n\n<p>Finalmente, como última parte de este artículo y de la serie de libros recomendados. Quiero poner algunas recomendaciones sobre temas y habilidades alternas a la programación que te ayudarán tanto como programador como a desarrollar tu carrera.</p>\n\n<p>Algunos de estos temas o libros pensarás que no tienen nada que ver, pero te puedo asegurar que son habilidades y temas de soporte necesarios que te van a ayudar a resaltar.</p>\n\n<h3 id=\"how-to-solve-it--george-polya\">How to solve it | George Polya</h3>\n\n<p><a href=\"https://math.hawaii.edu/home/pdf/putnam/PolyaHowToSolveIt.pdf\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686666135/71GFUNCh7hL._AC_UF1000_1000_QL80__q5xtrk.jpg\" alt=\"Portada de How to solve it\" class=\"align-center\" /></a></p>\n\n<p>George Polya fue un matemático del Siglo XX que contribuyó en el área de heurística y resolución de problemas. Fue un gran profesor al mismo tiempo que un gran investigador. Este libro es una combinación de ambas facetas de él: le preocupaba que las matemáticas se enseñaran bien al mismo tiempo que él era muy bueno haciendo matemáticas.</p>\n\n<p>En este escrito, Polya establece los pasos a seguir para resolver problemas matemáticos, pero que por extensión también nos sirve a los desarrolladores para aprender a establecer un método para resolver los problemas que encontramos día a día en nuestro trabajo.</p>\n\n<p>Los cuatro pasos que propone son:</p>\n\n<ul>\n  <li>Plantear y entender correctamente el problema</li>\n  <li>Idear un plan para resolverlo (aquí da algunas técnicas comunes)</li>\n  <li>Ejecutar el plan</li>\n  <li>Revisar el resultado, el proceso y los aprendizajes</li>\n</ul>\n\n<p>Cuando lo leí, noté inmediatamente que era un libro que se debería dar en todas las escuelas relacionadas con la ingeniería o la computación, ya que nos da claridad, o por lo menos una idea de cómo empezar a resolver algo.</p>\n\n<p>Lo puedes comprar aquí: <a href=\"https://amzn.to/43YlSQC\" target=\"_blank\" rel=\"noopener\">How to solve it</a>, pero también lo puedes leer gratis: <a href=\"https://cienciaymatematicas.files.wordpress.com/2012/09/como-resolver.pdf\">Cómo plantear y resolver problemas</a>.</p>\n\n<h3 id=\"enfócate--cal-newport\">Enfócate | Cal Newport</h3>\n\n<p><a href=\"https://www.amazon.com.mx/Enf%C3%B3cate-estrategias-eficacia-trabajo-creativo/dp/607527998X\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686669189/71p-QmjVoWL._AC_UF1000_1000_QL80__ymtjyl.jpg\" alt=\"Portada de Enfócate\" class=\"align-center\" /></a></p>\n\n<p>La atención es uno de los bienes más preciados que tenemos los seres humanos, ya que a nuestra mente consciente sólo entra aquello a lo que la dirigimos o <em>enfocamos</em>. Pero cuando más beneficios da es cuando la enfocamos en una sola cosa por un periodo prolongado. Es como si nuestra mente fuera acelerando y tomando impulso para resolver un problema.</p>\n\n<p>Esa es la tesis principal de “Enfócate”, un profesor de ciencias de la computación, muy interesado en temas como el logro académico, la productividad intelectual y el rendimiento a pesar de los obstáculos modernos.</p>\n\n<p>En este libro, presenta un caso muy sólido para convencerte de apartar tiempo ininterrumpido para lograr tus tareas más difíciles. Además, relata cómo él lo logra y te da algunos consejos para que tú lo puedas hacer.</p>\n\n<p>Creo que este libro es especialmente relevante para los desarrolladores de software por el entorno en el que trabajamos y porque muchos de los problemas que enfrentamos rebasan nuestra capacidad o conocimiento actual, por lo que necesitamos toda la ayuda posible para poder resolverlos.</p>\n\n<p>Puedes comprarlo aquí: <a href=\"https://amzn.to/45YWNqJ\" target=\"_blank\" rel=\"noopener\">Enfócate</a>.</p>\n\n<h3 id=\"accelerate--nicole-forsgren\">Accelerate | Nicole Forsgren</h3>\n\n<p><a href=\"https://www.oreilly.com/library/view/accelerate/9781457191435/9\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686808509/41OoXs3W3nL._AC_UF1000_1000_QL80__knm3bn.jpg\" alt=\"Portada de Accelerate\" class=\"align-center\" /></a></p>\n\n<p><strong>¿Qué es lo que distingue a un equipo de alto rendimiento en la entrega de software de uno de bajo rendimiento?</strong> La medida más básica es el tiempo que toma un cambio en ser liberado o en llegar a producción. En este libro se habla de 1) cómo medir esto y 2) los factores que llevan a un equipo a mejorar esas métricas.</p>\n\n<p>En realidad el libro es el resultado de un estudio de muchos equipos de desarrollo de software, en el que descubrieron varias cosas acerca de los equipos de alto rendimiento, entre ellas:</p>\n\n<ul>\n  <li>Las prácticas técnicas que tienen</li>\n  <li>El tipo de liderazgo que los guía</li>\n  <li>Qué tipo de arquitecturas siguen</li>\n  <li>Qué prácticas de administración de recursos humanos siguen</li>\n  <li>Cómo hacen todo el trabajo sostenible</li>\n</ul>\n\n<p>Además el libro habla de la forma en la que se realizó el estudio. Sin duda, es un libro muy valioso para los desarrolladores de software que quieren mejorar su rendimiento y el de sus equipos. Puedes comprarlo aquí: <a href=\"https://amzn.to/3JaPTEP\" target=\"_blank\" rel=\"noopener\">Accelerate</a>.</p>\n\n<h3 id=\"data-and-reality--william-kent\">Data and Reality | William Kent</h3>\n\n<p><a href=\"https://www.bkent.net/Doc/darxrp.htm\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686837219/41351CTT93L._AC_UF1000_1000_QL80__qgzcwb.jpg\" alt=\"Portada de Data and Reality\" class=\"align-center\" /></a></p>\n\n<p>Creo que como programadores, gran cantidad del tiempo lo dedicamos a procesar datos, o a crear representaciones datos de procesos externos a la computación. Esto es el <strong>modelado de datos</strong>, y es de lo que este libro habla, pero de manera bastante especial.</p>\n\n<p><strong>William Kent</strong> hace un análisis profundo de las cosas a las que estamos acostumbrados: modelos, datos, registros, relaciones, atributos, entidades. Primero, <em>intenta</em> definirlas y después aplicarlas al modelado de datos, explorando las implicaciones de definición. Es un libro que te va a hacer pensar bastante, relacionado con la epistemología, la ontología y en nuestra percepción de la realidad.</p>\n\n<p>Aunque el libro te deja con más dudas que respuestas, deja algo totalmente claro: no existe una forma <em>correcta</em> de modelar el mundo, sólo <strong>representaciones más convenientes</strong> para un caso u otro, ya que todas son arbitrarias.</p>\n\n<p>Yo leí la <a href=\"https://amzn.to/42FOOMs\">tercera edición</a>, que es la que única que está en producción actualmente. Esta tiene comentarios de otro modelador de datos muy experimentado, pero que según <a href=\"https://buttondown.email/hillelwayne/archive/data-and-reality-2nd-edition/\">Hillel Wayne</a> cambió completamente el libro.Hillel recomienda leer la segunda edición, que aunque ya no está en impresión, lo puedes encontrar en <a href=\"https://buttondown.email/hillelwayne/archive/data-and-reality-2nd-edition/\" target=\"_blank\" rel=\"noopener\">PDF</a>. Yo tengo pendiente leer la segunda edición, pero tengo altas expectativas ya que incluso la tercera me dejó grandes enseñanzas.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>Para avanzar en tu carrera no basta con aprender sólo habilidades técnicas, también hacen falta algunas meta-habilidades, habilidades paralelas y conocimiento de la historia de tu profesión.</p>\n\n<p>Tener estos conocimientos te puede hacer destacar de los demás profesionales, y son especialmente útiles si quieres lograr un puesto de liderazgo. Así que sigue preparándote, recuerda que un libro bien editado es de las mejores inversiones que puedes hacer.</p>\n",
      "date_published": "Thu, 15 Jun 2023 00:00:00 -0600"
      }
    
  ]
}
       <div style="border: 1px solid gray; border-radius: 4px; margin: 20px; padding: 5px;">
          Visita nuestro canal de YouTube para encontrar temas similares en video:<a href="https://youtube.com/thedojomx"> The Dojo MX en YouTube </a>
        </div>

        
      </section>

      <footer class="page__meta">
        
        


        


      </footer>

      

      
    </div>

    
  </article>

  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Términos de búsqueda...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Términos de búsqueda..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        
<script>
    var sharect = new Sharect();
    sharect.config({
      twitter: true,
      twitterUsername: '@thedojomx',
      backgroundColor: '#4b0082',
      iconColor: '#fff'
    }).init();
</script>
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Seguir:</strong></li>
    

    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2023 The Dojo MX Blog. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <script>
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-127437335-2']);
  
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>









  </body>
</html>
