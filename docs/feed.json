<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="es" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>The Dojo MX Blog</title>
<meta name="description" content="">


  <meta name="author" content="Héctor Patricio">
  


<meta property="og:type" content="website">
<meta property="og:locale" content="es">
<meta property="og:site_name" content="The Dojo MX Blog">
<meta property="og:title" content="The Dojo MX Blog">
<meta property="og:url" content="https://blog.thedojo.mx/feed.json">













<link rel="canonical" href="https://blog.thedojo.mx/feed.json">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": null,
      "url": "https://blog.thedojo.mx/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="The Dojo MX Blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    
<!-- favicon -->
<link rel="apple-touch-icon" sizes="180x180" href="/assets/images/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicons/favicon-16x16.png">
<link rel="manifest" href="/assets/images/favicons/site.webmanifest">
<link rel="mask-icon" href="/assets/images/favicons/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="/assets/images/favicons/favicon.ico">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/assets/images/favicons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">
<!-- end favicon -->
<!-- for mathjax support -->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZNSYMJDY5S"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-ZNSYMJDY5S');
</script>

<!-- Hotjar Tracking Code for blog.thedojo.mx -->
<script>
    (function(h,o,t,j,a,r){
        h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
        h._hjSettings={hjid:1217463,hjsv:6};
        a=o.getElementsByTagName('head')[0];
        r=o.createElement('script');r.async=1;
        r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
        a.appendChild(r);
    })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');
</script>

<script src="/assets/js/sharect.min.js"></script>

<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "url": "https://blog.thedojo.mx/feed.json",
      "name": null,
      "headline": null,
      "keywords": "",
      "description": "",
      "articleBody": "{\n  \"version\": \"https://jsonfeed.org/version/1\",\n  \"title\": {{ site.title | jsonify }},\n  \"description\": {% if site.description %}{{ site.description | jsonify }}{% endif %},\n  \"home_page_url\": \"{{ site.url }}\",\n  \"feed_url\": \"{{ site.url }}/feed.json\",\n  \"favicon\": \"{{ site.url}}/favicon.png\",\n  {% if site.author %}\n  \"author\": {\n    \"name\": {{ site.author | jsonify }}\n  },\n  {% endif %}\n  \"items\": [\n    \n    {% for post in site.posts limit:10 %}\n    {\n      \"id\": \"{{ post.url | prepend: site.baseurl | prepend: site.url }}\",\n      \"url\": \"{{ post.url | prepend: site.baseurl | prepend: site.url }}\",\n      \"title\": {{ post.title | jsonify }},\n      \"content_html\": {{ post.content | jsonify  }},\n      \"date_published\": \"{{ post.date | date_to_rfc822 }}\"\n      }{% unless forloop.last %},{% endunless %}\n    {% endfor %}\n  ]\n}",
      "datePublished": null,
      "dateModified": null,
      "author": {
        "@type": "Person",
        "name": null,
        "givenName": null,
        "email": null
      },
      "publisher": {
        "@type": "Organization",
        "name": "The Dojo MX Blog",
        "url": "https://blog.thedojo.mx",
        "logo": {
          "@type": "ImageObject",
          "width": 32,
          "height": 32,
          "url": "https://blog.thedojo.mx/icon/favicon.ico"
        }
      },
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://blog.thedojo.mx/feed.json"
      },
      "image": {
        "@type": "ImageObject",
        "width": 1200,
        "height": 400,
        "url": ""
      }
    }
</script>



  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="https://res.cloudinary.com/hectorip/image/upload/v1554098427/TheDojo/the-dojo-transparent.png" alt="The Dojo MX Blog"></a>
        
        <a class="site-title" href="/">
          The Dojo MX Blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/latest">Todos los posts</a>
            </li><li class="masthead__menu-item">
              <a href="/about">Acerca de</a>
            </li><li class="masthead__menu-item">
              <a href="https://thedojo.mx">Cursos</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  


  <article class="page h-entry" itemscope itemtype="https://schema.org/CreativeWork">
    
    
    
    

    <div class="page__inner-wrap">
      
        <header>
          
          

        </header>
      

      <section class="page__content e-content" itemprop="text">
        
        <div style="border: 1px solid gray; border-radius: 4px; margin: 20px; padding: 5px;">
          Visita nuestro canal de YouTube para encontrar temas similares en video:<a href="https://youtube.com/thedojomx"> The Dojo MX en YouTube </a>

        </div>
        {
  "version": "https://jsonfeed.org/version/1",
  "title": "The Dojo MX Blog",
  "description": ,
  "home_page_url": "https://blog.thedojo.mx",
  "feed_url": "https://blog.thedojo.mx/feed.json",
  "favicon": "https://blog.thedojo.mx/favicon.png",
  
  "author": {
    "name": {"name":"Héctor Patricio","avatar":"/assets/images/me.jpg","bio":"Desarrollador de software, tech lead @ HAL y The Dojo MX","uri":"https://github.com/hectorip","home":"https://til.hectorip.com/"}
  },
  
  "items": [
    
    
    {
      "id": "https://blog.thedojo.mx/2023/03/13/que-es-la-abstraccion.html",
      "url": "https://blog.thedojo.mx/2023/03/13/que-es-la-abstraccion.html",
      "title": "¿Qué es la abstracción?",
      "content_html": "<p>Muchos programadores saben intuitivamente que gran parte del trabajo que hacemos como desarrolladores de software consiste en “abstraer”, sin llegar a entender completamente qué significa esto.</p>\n\n<p>En este artículo vamos a empezar explicando qué es la abstracción en general y luego cómo puedes mejorar tu habilidad de abstraer para programar más rápido y para crear mejores programas. La capacidad de <strong>crear mejores abstracciones te permitirá crear programas que no creías que pudieran existir o que tú pudieras crear</strong>.</p>\n\n<p>Empecemos por las mismísimas bases.</p>\n\n<h2 id=\"etimología-de-dónde-viene-la-palabra-abstracción\">Etimología: ¿de dónde viene la palabra abstracción?</h2>\n\n<p><strong>“Abstracción”</strong> viene del latín <em>abstrahere</em>, que tiene dos partes principales: <strong>abs</strong> que significa “fuera de”, “sin”, “a distancia” y <strong>trahere</strong> que significa “tirar”. La palabra <em>abstrahere</em> significa literalmente “tirar fuera”.</p>\n\n<p>La palabra <em>abstrahere</em> se usa en el sentido de “separar” o “extraer” en el contexto de la filosofía, la matemática y la física. En el contexto de las matemáticas, la abstracción es el proceso de separar un concepto de sus propiedades físicas.</p>\n\n<p>A veces entendemos el proceso de abstraer como la capacidad de generalización. Por ejemplo, si queremos abstraer el concepto de “mesa”, lo que hacemos es quitar todas las características concretas de todas las mesas que hemos visto en la vida y entonces vemos lo que tienen todas en común: nos permiten hacer algo sobre ellas, sea parados o sentados. De esta manera tenemos el concepto abstracto de una mesa en nuestra mente. Después podemos aplicar ese concepto a diferentes cosas que veamos.</p>\n\n<p>Los seres humanos somos máquinas de abstraer. Si a un niño pequeño le presentas unos cuantos gatos o perros, es capaz de aprender el concepto “gato” y extenderlo a otros gatos que vea aunque no se parezcan mucho a los que ya vio. Lo que no es capaz de hacer normalmente, es definir en palabras lo que es un “gato” de manera precisa.</p>\n\n<p>Como <strong>resumen</strong>: abstraer es “tirar fuera”, sacar las características que definen algo de su contexto concreto y ser capaz de entender ese concepto de manera general.</p>\n\n<p>Algunos definen las abstracciones como lo contrario: quitarle todo lo que no es necesario a un concepto para 1) resaltar y hacer visible lo que importa y 2) Ocultar detalles que no <em>deben</em> ser tomados en cuenta.</p>\n\n<p>A estas abstracciones a veces las llamamos <strong>modelos</strong>_. <strong>¿Te suena?</strong></p>\n\n<h2 id=\"cómo-la-usamos-en-la-programación\">Cómo la usamos en la programación</h2>\n\n<p>Ya hemos dicho que aunque los seres humanos nos la pasamos abstrayendo todo lo que vemos en la vida real, no siempre podemos:</p>\n\n<ol>\n  <li>Delimitar precisamente la abstracción</li>\n  <li>Expresar o explicar esa abstracción a otras personas</li>\n</ol>\n\n<p>Y esto <strong><em>precisamente</em></strong> es lo que necesitamos al programar: delimitar nuestras abstracciones y expresarlas en algún lenguaje de programación, como una tabla en una base de datos o de alguna otra forma que las computadoras puedan capturar y procesar, <strong>a esto es a lo que nos referimos cuando hablamos de abstraer en la programación</strong>.</p>\n\n<p>Lo que hace más difíciles las abstracciones en la programación es que normalmente los conceptos no son tan sencillos e incluso son de áreas con las que no estamos familiarizados o no tenemos experiencia.</p>\n\n<p>La capacidad de abstraer es muy importante en casi todo trabajo intelectual, sobre todo aquellos relacionados con la lógica, por eso es supremamente importante en la programación. Aquí es donde la programación se parece al trabajo de un matemático: <strong>debes traducir un problema informal de la vida real, normalmente en lenguaje natural a un lenguaje formal que una computadora pueda entender</strong>. Para hacer esto, debes dejar los aspectos más importantes del problema para representarlos de manera efectiva en tu programa final.</p>\n\n<p>Pero recuerda que las abstracciones en programación también deben <em>ocultar</em> detalles que no <em>queremos</em> que se vean en otras partes del programa, por lo que se incluye una tarea más: refinar estas abstracciones hasta que contengan la información completamente necesaria.</p>\n\n<p>La abstracciones las podemos ver en muchas formas en la programación:</p>\n\n<ul>\n  <li>Modelos de datos</li>\n  <li>Tipos de datos</li>\n  <li>Clases y objetos</li>\n  <li>Funciones</li>\n  <li>Clases</li>\n</ul>\n\n<p>Todas estas cosas que mencionamos tienen una característica en común: presentan una <strong>interfaz</strong>. Así estas abstracciones lo pueden ser en dos sentidos:</p>\n\n<ol>\n  <li>La representación de un concepto de la vida real en el programa</li>\n  <li>El lugar donde se <em>ocultan</em> detalles o información detrás de una interfaz a otra parte del programa</li>\n</ol>\n\n<h3 id=\"ejemplos-de-abstracciones\">Ejemplos de abstracciones</h3>\n\n<p>Hablemos de algunos ejemplos y cómo caen en las definiciones que hemos hablado.</p>\n\n<h3 id=\"carrito-de-compras\">Carrito de compras</h3>\n\n<p>Cuando queremos representar algo en un carrito de compra en un programa, lo que hacemos es abstraer el concepto de “carrito de compra” y representarlo en el programa.</p>\n\n<p>En la vida real, un carrito o una bolsa de compra es donde almacenamos las cosas que estamos a punto de comprar mientras estamos en la tienda.</p>\n\n<p>La abstracción del carrito de compra, entonces, es un conjunto de productos, cada uno con su precio y cantidad. En el programa, el carrito de compra es una lista de productos que se guarda mientras el usuario no termine de comprar.</p>\n\n<p>En esta abstracción se mantuvieron las propiedades importantes:\npara no ir a pagar artículo por artículo, se tiene un contenedor que nos ayuda a mantener lo que vamos a comprar y pagarlo todo de una vez.</p>\n\n<p>La abstracción consiste en que “tiramos fuera” esas propiedades y eliminamos los detalles, por ejemplo si es un carrito, una canasta, una bolsa, un acompañante que carga tus productos, etc.</p>\n\n<p>Aquí entra otra de las características de las abstracciones. Aunque normalmente somos capaces de entender para lo que sirve el carrito de compra, si le preguntas a un cliente común sobre la abstracción, va a ser difícil que la ponga en palabras, por lo que simplemente usamos ese objeto para representar la abstracción para el usuario. No le decimos “contenedor de tus productos mientras terminas la compra” sino simplemente “carrito de compras”.</p>\n\n<p>En la segunda forma en la que este carrito de compras puede ser una abstracción es que en tu programa, tal vez hay un clase que representa este contenedor. Para el resto del programa, este carrito tiene una interfaz que podría consistir en:</p>\n\n<ul>\n  <li>Agregar producto</li>\n  <li>Obtener total</li>\n  <li>Vaciar carrito</li>\n  <li>Agregar Cupón</li>\n  <li>Obtener total</li>\n</ul>\n\n<p>La manera en que esta clase hace todas esas operaciones debería estar oculta de todo el resto del programa. Incluso la manera en que almacena la información sólo le concierne a esta <em>abstracción</em>. Esto permite <strong>ocultar información</strong> y hace que las piezas del programa sean menos dependientes entre ellas.</p>\n\n<h3 id=\"abstracción-de-un-usuario\">Abstracción de un usuario</h3>\n\n<p>Esta es una de las abstracciones más comunes en los sistemas de software. ¿Qué características esenciales necesitamos de alguna entidad para que use nuestro sistema? Nota que mencionamos “entidad” y no “humano”, porque puede que el usuario de nuestro sistema sea otro sistema, por ejemplo.</p>\n\n<p>En sistemas como AWS, GCP y Azure, por ejemplo, existen cuentas para computadoras o para que sean usadas por otro servicio (se llaman <em>cuentas de servicio</em>).</p>\n\n<p>Pensando en esto, ¿qué representa a un usuario? Yo me atrevería a decir que los únicos datos absolutamente esenciales para esta abstracción son los que permiten verificar <strong>la identidad</strong>, aquellos que le permiten a la entidad comprobar que en efecto es ella, o en el caso de sistemas, que puede actuar en nombre de ella.</p>\n\n<p>Pensando más ampliamente, la abstracción del usuario tendrá más atributos dependiendo de lo que aplicación haga. Imagínate una aplicación en la que los usuarios sean pacientes clínicos. ¿Qué datos nos interesan de una persona para esta aplicación?</p>\n\n<h2 id=\"niveles-de-abstracción\">Niveles de abstracción</h2>\n\n<p>Cuando hablamos de abstracciones en programación, a veces se escucha el término “nivel de abstracción”.\n¿A qué se refiere un “nivel”? La siguiente imagen nos puede ayudar a entenderlo:</p>\n\n<p><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_800/v1678759133/Ilustracio%CC%81n_sin_ti%CC%81tulo_f7ag0e.png\" alt=\"Niveles de abstracción\" /></p>\n\n<p>Mientras más cerca esté de la implementación técnica (llegando hasta el hardware), podemos decir que la abstracción está más “abajo”. Mientras más cerca esté de los pensamientos o la forma en la que los humanos vemos las cosas cotidianamente, la abstracción está más “arriba”.</p>\n\n<p>A esto se refiere la abstracción de bajo nivel y la abstracción de alto nivel. Cuando hacemos un programa, utilizamos una “cadena” de abstracciones, es decir, abstracciones que se sirven de otras abstracciones para funcionar. Usemos de nuevo el carrito de compras como ejemplo.</p>\n\n<p>El carrito es la abstracción de más alto nivel, porque es la que más se acerca al pensamiento cotidiano. Esta se sirve de la abstracción del “contenedor”. Si lo implementamos como una lista, esta es la siguiente abstracción. La lista, dependiendo del lenguaje en el que estemos, puede servirse de la abstracción de un arreglo dinámico. El arreglo, a su vez, se sirve de la abstracción de los bloques y direcciones de memoria. La memoria usa la abstracción de los bits. Y finalmente los bits son un voltaje presente en un circuito, pero esto, a lo que llamamos “voltaje” sigue siendo una abstracción.</p>\n\n<p>Un <strong>nivel de abstracción</strong> está compuesto por todas las abstracciones de nuestro programa que están más o menos igual de separadas de el pensamiento humano. Por ejemplo, el carrito de compras, el checkout (terminar y pagar la compra), una biblioteca, un producto, etc. son abstracciones que están al mismo nivel porque son cosas que el usuario puede entender y con las que trata directamente. Una lista, un cola, un árbol (estructura de datos), una pila, son cosas que están al mismo nivel porque las entendemos como maneras de organizar datos.</p>\n\n<h2 id=\"dificultades-para-abstraer\">Dificultades para abstraer</h2>\n\n<p>Abstraer no es tan sencillo como ha parecido hasta ahorita. Más bien, abstraer es algo que hacemos todo el tiempo, pero crear abstracciones adecuadas y expresarlas correctamente no es tan sencillo. De hecho, si te has dedicado a programar por un tiempo, puede que ya te hayas dado cuenta de eso. La primera dificultad es <strong>la naturaleza de la información</strong>.</p>\n\n<p>No nos vamos a poner a filosofar sobre qué es lo que permite definir algo, para eso te recomiendo el libro <a href=\"https://www.goodreads.com/en/book/show/1753248\">Data and Reality de William Kent</a>, que te romperá la cabeza con respecto a las abstracciones y las diferentes cosas que debes analizar para representar la realidad en una computadora, más concretamente, en una base de datos.</p>\n\n<p>Lo único que quiero sacar de este libro por el momento es: el mundo real, a diferencia del mundo ideal que nos imaginamos, <strong>no tiene límites definidos</strong>, no existen los conceptos tan delimitados y tan claros como los queremos hacer ven en los diccionarios.</p>\n\n<p>Esto nos lleva a que las representaciones (las abstracciones que hacemos en el código) <strong>siempre sean subjetivas y arbitrarias</strong>. No existe <strong>LA ABSTRACCIÓN</strong> que represente la realidad sin fallas, todas ellas tienen un punto de vista y se tienen que adecuar para la función que las necesites. Una misma cosa puede ser representada de millones de maneras diferentes y todas estas maneras pueden ser válidas.</p>\n\n<p>Otra dificultad es lo que hablamos arriba sobre los <em>niveles de abstracción</em>. Algo para lo que se usan las abstracciones en la programación es para <em>ocultar</em> información entre componentes del sistema. Crear abstracciones que no revelen detalles no necesarios a veces no es tan sencillo, y se tienen que pensar detenidamente.</p>\n\n<p>Finalmente, la complejidad intrínseca de los elementos que representamos puede ser en sí mismo un gran reto para crear abstracciones convenientes. Por ejemplo, en vez de representar gatos, tenemos que representar un proceso de suministro de insumos para una cadena de producción, la logística compleja de programación de vuelos y asignación de aviones y tripulación para una aerolínea, o el estado de una conversación compleja entre dos entidades.</p>\n\n<p>Es por eso que a veces creemos que necesitamos ayuda para mejorar nuestras capacidades de abstracción.</p>\n\n<h2 id=\"cómo-mejorar-tu-capacidad-de-abstraer\">Cómo mejorar tu capacidad de abstraer</h2>\n\n<p>Esta es una de las preguntas que todo programador se hace cuando quiere mejorar su manera y velocidad al programar. Cuando hablamos de “la manera” de programar, nos referimos a <em>la calidad</em> del código que produce.</p>\n\n<p>Vamos a hablar de las técnicas que puedes seguir para mejorar tu capacidad de crear y <em>expresar</em> mejores abstracciones.</p>\n\n<h3 id=\"consigue-información-y-ejemplos\">Consigue información y ejemplos</h3>\n\n<p>Ya hemos dicho que los seres humanos somos <em>muy buenos</em> creando abstracciones por naturaleza, pero somos tan buenos que podemos crear abstracciones demasiado temprano cuando entendemos algo bien.</p>\n\n<p>Para evitar las abstracciones tempranas, <strong>consigue la mmayor cantidad de información posible</strong>. Mientras más ejemplos diferentes del mismo fenómeno o entidad tengamos, mejores abstracciones vamos a crear, ya que encontraremos ejemplos que se contradicen entre ellos, excepciones y casos límite (aquellos que están en los valores extremos o combinaciones de características raras).</p>\n\n<h3 id=\"crear-niveles-de-abstracción-cerrados\">Crear niveles de abstracción cerrados</h3>\n\n<p>Es importante entender los <em>niveles de abstracción</em> porque esto nos permitirá diseñar abstracciones que no dejen pasar detalles de niveles superiores o inferiores hacia el otro lado de la cadena de abstracción. Por ejemplo, al cliente no le debería afectar si el carrito está implementado como una lista, un arreglo directamente, una tupla o un árbol. Dejar pasar esos detalles afectaría la experiencia del usuario, al mismo tiempo que haría más difícil de mantener el código.</p>\n\n<p>Estos niveles de abstracción se mantienen de dos formas:</p>\n\n<ol>\n  <li>Creando conjuntos de abstracciones relacionados que tengan el mismo nivel. A esto le llamamos una “capa”.</li>\n  <li>Creando interfaces que oculten los detalles de capas superiores o inferiores.</li>\n</ol>\n\n<p>Es muy difícil que este diseño te quede bien a la primera, por lo que debes tener en cuenta que tus interfaces y tus abstracciones irán evolucionando con el tiempo.</p>\n\n<h3 id=\"encontrar-patrones\">Encontrar patrones</h3>\n\n<p>Quiero citar a <a href=\"https://altenwald.com/\"><strong>Manuel Rubio</strong></a> en una respuesta que me dio personalmente:</p>\n\n<blockquote>\n  <p>Estar atento a estos patrones y saber cómo aprovecharlos en nuestro beneficio puede ayudarnos a crear abstracciones del código que desarrollamos. Hay que ser metódico y organizar bien los datos, nombrar las cosas correctamente, mantener las responsabilidades desligadas unas de otras y entonces los patrones se ven claros.</p>\n</blockquote>\n\n<p>Este consejo está directamente ligado a la cantidad de información que tenemos sobre el problema. Mientras más diversa y rica sea, más probable es que encontremos los patrones que subyacen en los comportamientos y procesos que tenemos que abstraer (o modelar). Aquí lo importante es ser explícitos con esos patrones, expresarlos y documentarlos de la manera más clara posible.</p>\n\n<p>Haber visto y sobre todo documentado una gran cantidad de patrones también nos puede ayudar a diseñar abstracciones de manera más efectiva y rápida en el futuro. Esto es de lo que los <strong>patrones de diseño</strong> se tratan: soluciones comunes a problemas recurrentes. Sólo hay que ser muy cuidadosos de no encajar problemas en patrones que no corresponden completamente al problema, sólo por el hecho de querer salir rápido del problema o de querer aplicar cierto patrón.</p>\n\n<h3 id=\"diseña-dos-veces\">Diseña dos veces</h3>\n\n<p>El diseño del software puede hacerse como la escritura: primero escribes y después editas. Son dos etapas diferentes y tan independientes que dos personas diferentes las pueden hacer. El diseño en el software puede hacerse de manera parecida. Primero diseñas tus representaciones y puedes pedirle a alguien que te corrija o revise, o puedes hacerlo tú mismo después de haber dejado pasar un poco de tiempo.</p>\n\n<p>Esta revisión te llevará a pensar cosas como “¿Qué estaba pensando cuando escribí esto?” o “Creo que esta no es la abstracción correcta”, gracias a que normalmente te has parado un poco a distancia de tu propio diseño.</p>\n\n<h2 id=\"desarrolla-la-capacidad-de-absorber-información\">Desarrolla la capacidad de absorber información</h2>\n\n<p>Debido a que tienes que representar cosas de dominios en los que probablemente no conoces, tener la capacidad de estudiar de manera efectiva te permitirá analizar la información necesaria para crear buenas abstracciones.</p>\n\n<h3 id=\"expande-tu-mente\">Expande tu mente</h3>\n\n<p>Mientras más cosas sepas de diferentes campos o dominios, será más probable que encuentres cosas que te puedan servir para <em>entender</em> lo que estás tratando de representar y sobre todo para extraer sus componentes principales, así como la información que vale la pena excluir. Así que no te limites en aprender todo lo que puedas de todos los campos posibles, pero recuerda también que esto tiene rendimientos decrecientes: mientras más profundices en un campo, más te costará adquirir nueva información que valga la pena.</p>\n\n<p>Es por esto mismo que muchos programadores son buenos programando para ciertos dominios: financiero, de automatización industrial, de juegos, de programas científicos, etc. No lo podemos saber todo y muchas veces son el conocimiento de una sóla área es suficiente para entretenernos por décadas.</p>\n\n<h3 id=\"practica\">Practica</h3>\n\n<p>Este es el concepto más gastado de todos, pero aquí le vamos a dar un pequeño giro. No sirve de mucho para mejorar sólo hacer abstracciones sin reflexionar en ellas. Tienes que pensar detenidamente en tus diseños y contestar preguntas como:</p>\n\n<ul>\n  <li>¿Qué información tenía disponible y pasé por alto?</li>\n  <li>¿Cómo hubiera podido conocer u obtener esa información?</li>\n  <li>¿Qué detalles de implementación dejé escapar de mi abstracción?</li>\n  <li>¿Quién pudo haberme dado más ejemplos sobre el problema?</li>\n  <li>¿Quién puede hacer una revisión sobre el diseño y darme comentarios para mejorar?</li>\n</ul>\n\n<p>A esto se le llama práctica enfocada y hay ejercicios llamados <a href=\"http://codekata.com/\">Code Katas</a> que te pueden ayudar a mejorar en el diseño de software.</p>\n\n<p>¿Tienes algún consejo más que te haya ayudado a mejorar la forma en la que creas abstracciones? Me gustaría escucharlo en los comentarios.</p>\n\n<h2 id=\"evita-los-extremos\">Evita los extremos</h2>\n\n<p>A veces nos pasamos con las abstracciones, tanto en el nivel como en el momento en el que lo hacemos. En esta sección nos referimos exclusivamente a las abstracciones que generalizan un proceso o concepto, y las que ocultan información de otras partes del programa.</p>\n\n<p>Una señal de que estamos abstrayendo demasiado es que haya una gran diferencia entre la dificultad natural del problema base y nuestro código. Por ejemplo, imagina que tienes que encontrar una cadena de texto en un texto más grande. La cadena a encontrar es una de tres posibles “Kilo”, “Mega”, “Giga”. ¿Valdrá la pena hacer la abstracción de un buscador general de cadenas cualquiera en textos arbitrarios con el uso de autómatas finitos deterministas? Lo más probable es que no: con un un simple “contains” o la función equivalente usado en el lugar de la búsqueda es suficiente.</p>\n\n<p>Esto se puede meter directamente con nuestro orgullo: lo fácil o sencillo no nos hace parecer inteligente. Pero recuerda que la simplicidad es la mejor sofisticación. Mientras más simples sean tus diseños, mejor.</p>\n\n<p>El otro punto importante es <strong>cuándo</strong> creamos estas abstracciones. Si quieres crear el programa más complejo desde el principio, lo más probable es que vas a tardar mucho en implementarlo, además de que puede que crees abstracciones que no vas a necesitar. Mejor usa las cosas más concretas posible hasta que de verdad el problema o los requerimientos de los usuarios te hagan generalizar algo. Es cierto que a veces prever algún cambio simplificará tu trabajo en el futuro, pero la mayoría de veces nos equivocamos. Lo hacemos tanto, que existe un inicialismo para refrenarnos de crear abstracciones prematuramente: YAGNI (You aren’t gonna need it - No lo vas a necesitar).</p>\n\n<h2 id=\"el-costo-de-las-abstracciones\">El costo de las abstracciones</h2>\n\n<p>Una abstracción del tipo que esconde código de otras partes del programa, es decir, de las que están detrás de una interfaz (Clase, módulo, función, etc), normalmente cuestan más en tiempo de diseño, de compilación o de ejecución. Normalmente en los tres, a menos que sea una abstracción con la que tengas mucha familiaridad. Esta es otra razón para refrenarnos de crear todas las abstracciones que se nos ocurran en un programa, o de crear cadenas de abstracciones demasiado grandes.</p>\n\n<p>Esto lo tienes que pensar sobre todo cuando los beneficios de crear cierta abstracción no están tan claros. Con algunos entornos, hay excepciones.</p>\n\n<h3 id=\"zero-cost-abstractions-abstracciones-sin-costo\">Zero-cost abstractions (Abstracciones sin costo)</h3>\n\n<p>Las abstracciones de costo cero son una propuesta de algunos entornos y lenguajes de programación modernos. Como abstraer normalmente supone un costo en el tiempo de ejecución del programa, las abstracciones sin costo proponen que, aunque puedes usar elementos de más alto nivel en el código, no te van a costar rendimiento en tiempo de ejecución.</p>\n\n<p>¿Entonces en dónde cuestan? Normalmente le cuestan al compilador, reemplazar o expandir macros en tiempo de construcción. Rust es un ejemplo de esto, aunque estas abstracciones están a bastante bajo nivel (te evitan manejos de memoria que podrían ser complicados, por ejemplo).</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>Mejorar tu capacidad de abstraer conceptos, pero sobre todo de representarlos de manera eficiente en el lenguaje de programación de tu elección te llevará lejos en la carrera de desarrollo de software.</p>\n\n<p>Este tema es de los más importantes en las ciencias de la computación y desarrollo de software, así que es algo de lo que puedes seguir aprendiendo a lo largo de toda tu carrera. Algunos documentos que puedes consultar para aprender más son:</p>\n\n<ol>\n  <li><a href=\"https://www.docdroid.com/ST0qbY8/programacion-y-tecnologia-un-camino-equivocado-pdf\">Programación y Tecnología: Un camino equivocado hacia la construcción de\nartefactos</a></li>\n  <li><a href=\"/assets/pdfs/EJ1329311.pdf\">Abstraction in Computer Science Education:\nAn Overview</a></li>\n  <li><a href=\"/assets/pdfs/chap02.pdf\">Abstraction</a></li>\n</ol>\n\n<p>Espero que este artículo te sirva en tu camino profesional en la carrera de desarrollo de software.</p>\n",
      "date_published": "Mon, 13 Mar 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/03/06/el-principio-de-substitucion-de-liskov.html",
      "url": "https://blog.thedojo.mx/2023/03/06/el-principio-de-substitucion-de-liskov.html",
      "title": "El principio de sustitución de Liskov",
      "content_html": "<p>El tercer principio enunciado en los principios <strong>SOLID</strong> es el principio de sustitución de Liskov. ¿Qué significa este principio? Y más importante, ¿vale la pena seguirlo? Pero antes de hablar del principio, hablemos de <strong>Barbara Liskov</strong>, la persona que lo inspiró y que estableció los conceptos principales.</p>\n\n<h2 id=\"un-poco-de-historia-barbara-liskov\">Un poco de historia: Barbara Liskov</h2>\n\n<p>Barbara Liskov es una matemática muy reconocida en las ciencias de la computación por los grandes aportes que ha hecho. Es conocida por su trabajo en el diseño de lenguajes de programación y la teoría de tipos. En 1994 junto con Jeannette Wing publicó el artículo del que Robert Martin se sacó lo que el llamó “el principio de sustitución de Liskov” o “LSP” (Liskov Substitution Principle). Ya ves que los <em>inicialismos</em> le dan un aire de importancia a lo que escribes.</p>\n\n<p>En su libro, <a href=\"https://www.marcombo.com/mentes-geniales-la-vida-y-obra-de-12-grandes-informaticos-9788426733573/\">“Mentes Geniales. La vida y obra de 12 grandes informáticos”</a>, Camilo Chacón nos da una semblanza de las contribuciones de Barbara a las ciencias de la computación. Sus principales aportaciones, resumidas son:</p>\n\n<ul>\n  <li>Lenguajes de programación que aplican ideas de polimorfismo, modularidad, abstracción de datos y manejo de excepciones</li>\n  <li>Sistemas distribuidos (inventó Paxos antes que Leslie Lamport)</li>\n  <li>Abstracción de datos y tipos de datos abstractos</li>\n</ul>\n\n<p>Si quieres saber más de ella en poco tiempo, te recomiendo mucho su capítulo en ese libro, es muy interesante, además de que obtiene lecciones muy valiosas de su vida. Ahora sí hablemos de lo que más gente conoce de ella.</p>\n\n<h2 id=\"el-principio-de-sustitución-de-liskov\">El principio de sustitución de Liskov</h2>\n\n<p>El artículo en el que lo definió se llama <a href=\"/assets/pdfs/subtyping.pdf\">“A Behavioral Notion of Subtyping”</a>. Tiene notación matemática que cuesta un poco leer si no tienes nociones de lenguaje matemático formal, pero resumiremos las ideas básicas aquí.</p>\n\n<p>El espíritu del LSP está basado en las ideas de <strong>subtipado</strong> que Liskov describió en este artículo. Estas ideas tienen <em>muy poco</em> que ver en realidad con herencia en los lenguajes de programación orientados a objetos y mucho más con la <strong>abstracción</strong> y restricciones que hay que tener en cuenta para considerar que un tipo es un subtipo de otro.\nEs cierto que Liskov usó las jerarquías de clases para ilustrar sus ideas, pero el principio de su trabajo tiene que ver mucho más con el comportamiento externo de un tipo de datos que con la forma en la que se encapsula este comportamiento.</p>\n\n<p>Pero vayamos a la parte más profunda de la teoría para entender si lo que Liskov propone tiene sentido.</p>\n\n<h3 id=\"qué-es-un-tipo\">¿Qué es un tipo?</h3>\n\n<p>Un tipo es la definición de lo que un valor almacenado tiene, puede hacer o las operaciones que se pueden hacer sobre él.</p>\n\n<p>Pongamos un ejemplo. En JavaScript el tipo <code class=\"language-plaintext highlighter-rouge\">Number</code> define un valor que representa un número de cualquier tipo. Este tipo de dato define las operaciones que podemos hacer sobre los valores con este tipo, por ejemplo:</p>\n\n<ul>\n  <li>Podemos usar el operador <code class=\"language-plaintext highlighter-rouge\">+</code> para sumar dos datos de este tipo</li>\n  <li>Podemos usar el operador <code class=\"language-plaintext highlighter-rouge\">-</code> para restar dos datos de este tipo</li>\n  <li>Las operaciones (excepto las comparativas) entre el tipo de dato <code class=\"language-plaintext highlighter-rouge\">Number</code> siempre devuelven un valor de este tipo</li>\n</ul>\n\n<p>También definen la <em>interfaz</em> de este tipo de datos, es decir, la forma en la que podemos interactuar con ellos. Normalmente, en lenguajes orientados a objetos, esta interfaz está compuesta por los métodos públicos que se pueden llamar sobre este tipo de dato.</p>\n\n<p>Por ejemplo en JavaScript, el tipo <code class=\"language-plaintext highlighter-rouge\">Number</code> tiene definido el método <code class=\"language-plaintext highlighter-rouge\">toString</code> que nos devuelve este valor como una cadena de texto.</p>\n\n<p>Pero Bárbara Liskov expandió esto, proponiendo lo que llamamos <strong>Abstract Data Type</strong> o <strong>Tipo de Dato Abstracto</strong> (les llamaremos <strong>ADT</strong>). Un tipo abstracto de dato es una <strong>definición de un tipo de dato</strong>.</p>\n\n<p>Este tipo de dato no tiene una implementación concreta, sino que define la interfaz que debe tener cualquier implementación de este tipo de dato, siendo responsabilidad del programador implementar esta interfaz.</p>\n\n<p>Ejemplos de ADT’s son por ejemplo las Colas (Queues), Listas (Lists), Pilas (Stacks), etc. El ADT define que interfaz debe tener cualquier implementación de este, y cada lenguaje o programador puede implementarlo como le convenga.</p>\n\n<p>Ahora, ¿qué es un subtipo?</p>\n\n<h3 id=\"qué-es-un-subtipo\">¿Qué es un subtipo?</h3>\n\n<p>Un subtipo es una derivación de un tipo. Esta derivación puede ser una variación, una generalización o una especialización de este tipo. Normalmente se usan para hacer <strong>especializaciones</strong>.</p>\n\n<p>Y aquí es donde empezamos a entrar en el terreno del LSP. Una de las restricciones más importantes que Liskov propone es que si un tipo de dato tiene definido un método X, entonces cualquier subtipo de este tipo (que en relación con este se llama “supertipo”) también debe tener este método definido.</p>\n\n<p>Para hacerlo más generalizable podemos cambiar “método” por cualquier elemento visible en la interfaz de este tipo de dato.</p>\n\n<p>Así, nos podremos usar que estas clases sean intercambiables entre ellas, sin siquiera tener que hacer consciente a la parte del programa que la usa de qué clase se está usando, mientras sea una clase derivada de la clase base.</p>\n\n<p>Un ejemplo de la vida real puede ser con un cámara. Todos tenemos en la mente las funciones básicas de una cámara electrónica:</p>\n\n<ul>\n  <li>Podemos encenderla y apagarla</li>\n  <li>Puede tomar fotos (disparador)</li>\n  <li>Puede mostrarnos las fotos</li>\n  <li>Podemos descargar las fotos</li>\n  <li>Podemos borrar las fotos</li>\n</ul>\n\n<p>Mientras la cámara cumpla con esas características (su interfaz) no tendremos problema para usarla, independientemente de la marca o modelo de la cámara. Los subtipos del tipo de dato abstracto <code class=\"language-plaintext highlighter-rouge\">Cámara</code> podría ser entonces:</p>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">Cámara DSLR</code></li>\n  <li><code class=\"language-plaintext highlighter-rouge\">Cámara Compacta</code></li>\n  <li><code class=\"language-plaintext highlighter-rouge\">Cámara Mirrorless</code></li>\n  <li><code class=\"language-plaintext highlighter-rouge\">Cámara de teléfono móvil</code></li>\n</ul>\n\n<p>En realidad en la programación, esta interfaz es un poco más estricta: los métodos deben de llamarse igual y tener la misma firma (parámetros y tipo de retorno). Es como si la cámara tuviera los botones en el mismo lugar y se usaran de la misma forma.</p>\n\n<p>Y esto es básicamente el principio de sustitución de Liskov, la capacidad de usar clases derivadas de una clase principal sin ningún cambio en el código que rodea. ¿Crees que es útil?</p>\n\n<h2 id=\"crítica-sobre-el-lsp\">Crítica sobre el LSP</h2>\n\n<p>Tal como lo describimos aquí (mal llamado, para mi) principio de sustitución de Liskov parece una muy buena idea, ya que permitirá que crees nuevos comportamientos en partes específicas de tu código sin en tener que afectar a muchas partes de tu código.</p>\n\n<p>Lo que no estuvo tan bien, <em>históricamente</em>, es que este principio siempre ha sido explicado y relacionado con la HERENCIA de clases, en lugar de poner énfasis en la abstracción de tipos de datos. Esto ha hecho que muchos desarrolladores piensen que esta práctica sólo aplica a la programación orientada a objetos y no al paradigma funcional, por ejemplo.</p>\n\n<p>De hecho, el principio como es enunciado en <a href=\"/assets/pdfs/DesignPrinciplesAndPatterns.pdf\">Design Principles and Patterns</a> dice:</p>\n\n<blockquote>\n  <h2 id=\"subclasses-should-be-substitutable-for-their-base-classes\">Subclasses should be substitutable for their base classes.</h2>\n  <p>Las subclases deben ser sustituibles por sus clases base.</p>\n</blockquote>\n\n<p>También, como se menciona en el artículo en el que se presenta originalmente este principio dice:</p>\n\n<blockquote>\n  <h2 id=\"functions-that-use-pointers-or-references-to-base-classes-must-be-able-to-use-objects-of-derived-classes-without-knowing-it\">FUNCTIONS THAT USE POINTERS OR REFERENCES TO BASE CLASSES MUST BE ABLE TO USE OBJECTS OF DERIVED CLASSES WITHOUT KNOWING IT</h2>\n  <p>Funciones que usen punteros o referencias a clases base deben ser capaces de usar objetos de clases derivadas sin saberlo</p>\n</blockquote>\n\n<p>Como puedes ver, el consejo es que está directamente relacionado con la herencia de clases y jerarquías de objetos. Incluso llega a hablar de punteros y referencias a clases base, es decir, a la clase padre.</p>\n\n<p>De hecho, esto tiene cierta justificación, porque Barbara Liskov siempre habla de objetos. Lo que Liskov nunca hace es hablar de <em>Clases</em> y jerarquías de clases. Ella habla de tipos de datos abstractos, que son una abstracción de los objetos, por lo que esta idea se extiende a <strong>cualquier artefacto computacional que se encargue de encapsular un comportamiento</strong>.</p>\n\n<p>¿Qué es encapsular? Es <strong>ocultar la implementación</strong> y exponer sólo lo necesario para que el resto del programa pueda usarlo. Esto es lo que hace una clase, un módulo, una función, etc.</p>\n\n<p>¿Qué te recuerda esto? Lo mismo de lo que hemos hablado en los principios anteriores: <strong>abstracción</strong>. Esconder lo más que se pueda la información, <em>Information Hiding</em>, como le llamaría John Ousterhout.</p>\n\n<p>Lo que es más, seguir esta idea de que diferentes tipos de datos puedan ser intercambiables hace que selecciones mejor los elementos que van a componer tu interfaz (en este caso le llamaríamos <strong>API</strong>).</p>\n\n<p>Para mí, las ideas de Liskov son un aplicación particular de la idea de ocultar la mayor cantidad de información posible dentro de interfaces lo mejor diseñadas posible, tal como se explica en el libro <a href=\"https://web.stanford.edu/~ouster/cgi-bin/book.php\">A Philosophy of Software Design de John Ousterhout</a>.</p>\n\n<h3 id=\"conclusión\">Conclusión</h3>\n\n<p>La ideas sobre <strong>subtipos</strong> y la forma de usarlos lo mejor posible que Bárbara Liskov y Jeannette Wing propusieron son muy útiles para crear mejor código, sobre todo mejor separación y ocultado de la implementación.</p>\n\n<p>Esto lo vamos a repetir hasta el cansancio: <strong>ocultar información</strong> te ayudará a hacer que tus programas sea más fáciles de entender y de mantener.</p>\n\n<p>Como lección, podemos decir que seguir las guías de Liskov para el subtipado es una forma de aplicar este principio de diseño aún más amplio, digamos que en realidad la especificación de cómo deben comportarse los subtipos es más como una <em>regla</em> de diseño que un <em>principio</em> de diseño.</p>\n\n<p>Entender el verdadero significado de lo que Liskov propone, te ayudará a ver que no sólo se aplica a la programación orientada a objetos, tal como se enunciaba en SOLID originalmente, sino a muchas otras situaciones.</p>\n",
      "date_published": "Mon, 06 Mar 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/02/27/que-es-un-modelo-transformador-de-inteligencia-artificial.html",
      "url": "https://blog.thedojo.mx/2023/02/27/que-es-un-modelo-transformador-de-inteligencia-artificial.html",
      "title": "¿Qué es un modelo transformador de inteligencia artificial?",
      "content_html": "<p>En los últimos años los modelos de inteligencia artificial generativos han avanzado mucho. Esto es en parte gracias a una nueva arquitectura para las redes neuronales llamada <em>transformer</em> o de transformador, como les llamaremos en este artículo. Hablemos de en qué consiste esta arquitectura y por qué es tan revolucionaria o porque ha ayudado tanto a avanzar en el campo de la inteligencia artificial.</p>\n\n<h2 id=\"redes-neuronales-recurrentes-rnn\">Redes neuronales recurrentes (RNN)</h2>\n\n<p>Estas eran el estándar para hacer varias tareas, entre ellas la traducción. Las redes neuronales recurrentes se llaman así porque sus entradas se alimentan en ciclos, es decir, en vez de siempre mandar su salida a las siguientes capas, también manda la salida a capas anteriores o a la misma capa.</p>\n\n<p>Esta arquitectura permite que la red desarrolle memoria, algo que sirve bien para tratar con textos porque normalmente las palabras que van adelante están influidas por las que están antes.</p>\n\n<p>Sin embargo, el entrenamiento de este tipo de redes neuronales requiere de mucho tiempo y recursos. Además, su memoria no es tan buena como para manejar textos muy largos. Así que la traducción o tratamiento de textos largos no les salía muy bien.</p>\n\n<p>Además, la forma secuencial de tratar las palabras las hace difíciles de entrenar. Aquí es cuando los investigadores de Google diseñaron otra arquitectura.</p>\n\n<h2 id=\"redes-neuronales-de-transformador-transformers\">Redes neuronales de transformador (Transformers)</h2>\n\n<p>Es una arquitectura más sencilla que las utilizadas anteriormente. Los transformadores están construidos en gran parte por mecanismos de <strong>atención</strong>. Podemos decir que tiene tres componentes principales:</p>\n\n<ol>\n  <li>Codificación de posición</li>\n  <li>Mecanismo de atención</li>\n  <li>Mecanismo de auto-atención</li>\n</ol>\n\n<p>Hablemos de cada una de estas partes más detenidamente, explicadas para un desarrollador de software.</p>\n\n<h3 id=\"codificación-de-posición\">Codificación de posición</h3>\n\n<p>Esta es la primera innovación del modelo transformador. En vez de procesar las palabras como una secuencia para conservar su orden, lo que limita el paralelismo o la capacidad de procesar varias palabras a la vez, se crean tuplas que contienen la palabra y su posición en el texto. Esto permite que la red pueda procesar varias palabras a la vez.</p>\n\n<p>La posición del texto como se explica en <a href=\"https://arxiv.org/abs/1706.03762\">Attention is all you need</a> depende de una función basada en el seno y coseno, no un número entero de donde se encontró en el texto.</p>\n\n<p>Esta primera innovación permite que el entrenamiento sea paralelizable y por lo tanto que se puedan procesar más ejemplos, lo que mejora el aprendizaje.</p>\n\n<h3 id=\"atención\">Atención</h3>\n\n<p>La atención se introdujo algunos años antes en el proceso de traducción automática. Este proceso consiste en que el modelo “mire” a otro texto para saber cómo traducir la palabra o el texto que está procesando. En las tareas de traducción, este mecanismo se da entre el texto que necesita ser traducido y la salida de la traducción.</p>\n\n<p>El mecanismo de atención le da un peso diferente a cada palabra del texto original, con respecto a la palabra que ese está procesando. Este peso determina en donde se está “fijando” el modelo para procesar la palabra actual.</p>\n\n<p>Este mecanismo de atención es básicamente un montón de operaciones matriciales.</p>\n\n<h3 id=\"auto-atención\">Auto-atención</h3>\n\n<p>El mecanismo de atención anterior tiene que ver con la influencia que otro texto en la salida del proceso actual. El mecanismo de auto-atención se refiere al análisis <strong>del mismo texto</strong> que se está procesando, y la relación entre las palabras.</p>\n\n<p>Este mecanismo de auto-atención permite que el modelo encuentre patrones a través de muchos ejemplos de entrenamiento. Estos patrones tienen que ver con el significado de la palabra, los sinónimos, la gramática, etc.</p>\n\n<p>Esta es la parte más importante de un transformador y es lo que hace que los modelos que tienen esta arquitectura sean tan poderosos, permitiéndoles trabajar con textos largos y con una gran variedad de tareas, más allá de solamente traducción.</p>\n\n<p>Esta es una explicación muy básica de los mecanismos dentro de un modelo de transformador, si quieres aprender más a profundidad puedes leer:</p>\n\n<ul>\n  <li>El documento donde se presentó la arquitectura: <a href=\"https://arxiv.org/abs/1706.03762\">Attention is all you need</a>.</li>\n  <li><a href=\"http://jalammar.github.io/illustrated-transformer/\">The Illustrated Transformer</a>, un artículo en donde con buenos dibujos se explica cómo funcionan.</li>\n  <li><a href=\"http://jalammar.github.io/illustrated-bert/\">The Illustrated BERT, ELMo, and co. (How NLP Cracked Transfer Learning)</a>, un artículo en donde se explica cómo funciona BERT, basado en ideas similares a las de los transformadores.</li>\n</ul>\n\n<h3 id=\"ventajas-de-los-transformadores\">Ventajas de los transformadores</h3>\n\n<p>La principal ventaja es que al ser más fáciles y eficientes de entrenar, se pueden crear modelos más grandes que normalmente harán mejor su tarea. Esto es lo que ha permitido que modelos como PALM y GPT-3 existan.</p>\n\n<p>Los modelos de transformador nos siguen sorprendiendo y parece que continuarán así en los próximos años.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>Las redes neuronales con arquitectura de transformador permiten lograr cosas que no creíamos posibles y son la base de los grandes modelos de lengua natural como GPT-3. Conocer un poco más cómo funcionan nos puede dar una idea de lo que son capaces y sus límites, además de que es bastante interesante. Si quieres que hablemos de algún tema en específico puedes dejarnos un comentario.</p>\n",
      "date_published": "Mon, 27 Feb 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/02/27/code-review.html",
      "url": "https://blog.thedojo.mx/2023/02/27/code-review.html",
      "title": "Code Review: La practica Milenaria que seguimos haciendo mal.",
      "content_html": "<h2 id=\"qué-es-un-code-review\">¿Qué es un “Code Review”?</h2>\n\n<p>Es la práctica que realizan los equipos de ingeniería de software para verificar los cambios de código antes de fusionarlos con el código fuente principal.</p>\n\n<h2 id=\"dónde-se-aplica\">Dónde se aplica</h2>\n\n<p>En todas partes, cuando eres miembro de un equipo, como colaborador individual o como estudiante. Tienes la oportunidad de involucrarte, contribuir y dar tu opinión a código escrito por otra persona. Algunos ejemplos:</p>\n\n<h3 id=\"durante-una-sesión-de-pair-programming\">Durante una sesión de “pair programming”</h3>\n\n<blockquote>\n  <p>“Dos cabezas piensan mejor que una.”</p>\n</blockquote>\n\n<p>Revisando una pieza de código con alguien más, los desarrolladores podemos hacer recomendaciones, mejoras y adiciones a un sistema en tiempo real.</p>\n\n<h3 id=\"en-aplicaciones-de-control-de-versiones-tales-como\">En aplicaciones de control de versiones, tales como</h3>\n\n<ul>\n  <li>El Pull Request (PR) en GitHub.</li>\n  <li>El Merge Request (MR) en GitLab.</li>\n</ul>\n\n<p>Estas funciones permiten a los desarrolladores proponer cambios en un código propiedad de otra persona. Es una forma de revisar y discutir cambios propuestos antes de fusionarlos, lo que permite a otros desarrolladores dejar comentarios, solicitar cambios o aprobar una solicitud de forma asíncrona.</p>\n\n<h3 id=\"en-cualquier-fragmento-de-código-propuesto\">En cualquier fragmento de código propuesto</h3>\n\n<p>Hay otros canales o formas de compartir código con un equipo. A veces, los desarrolladores lo hacen a través de Slack (u otros servicios de mensajería) u otra, simplemente compartiendo enlaces.\nSi como desarrollador notas algo para mejorar o agregar, tu equipo de tecnología debe ser el lugar que permita que esas interacciones y comentarios sucedan orgánicamente.</p>\n\n<h2 id=\"beneficios-de-la-revisión-de-código\">Beneficios de la revisión de código</h2>\n\n<p>Esta práctica aumenta significativamente el trabajo en equipo. Involucrarse con el código de los demás e involucrar a otros en tus contribuciones aumenta el éxito en la creación de productos. Algunos de los beneficios son:</p>\n\n<h3 id=\"solución-77-temprana-de-errores\">Solución 77 temprana de errores</h3>\n<blockquote>\n\n  <p>“Aquel de ustedes que esté libre de romper producción, que tire la primera piedra.”</p>\n</blockquote>\n\n<p>Como humanos, los ingenieros de software no están exentos de cometer errores, y es una gran ventaja contar con un equipo que te apoye, revise y libere tareas en conjunto. Durante una revisión de código, estos errores se pueden detectar y corregir.</p>\n\n<h3 id=\"mejorar-la-calidad\">Mejorar la calidad</h3>\n<blockquote>\n\n  <p>“Es más barato hacer las cosas bien la primera vez.”</p>\n</blockquote>\n\n<p>Establecer reglas en el estilo de código que aumenten la legibilidad, el mantenimiento y la escalabilidad del código ayuda a escribir software de calidad.</p>\n\n<h3 id=\"intercambio-de-conocimientos\">Intercambio de conocimientos</h3>\n\n<p>El Code Review es una excelente herramienta para recibir y dar retroalimentación, aprender las mejores prácticas de los desarrolladores con más experiencia e intercambiar soluciones.</p>\n\n<h3 id=\"sincronización\">Sincronización</h3>\n\n<p>Con esta práctica, se puede saber en qué está trabajando cada miembro del equipo, evitar duplicación de esfuerzos y mantenerse actualizado con la lógica del negocio.</p>\n\n<h2 id=\"primeros-pasos\">Primeros pasos</h2>\n\n<p>Una buena idea para aplicar correctamente esta práctica en tu equipo es establecer reglas antes de empezar.</p>\n\n<ul>\n  <li>Establezca una plantilla de descripción con los puntos mínimos que el equipo necesitará para comprender el contexto y el propósito de una solicitud de cambios de código y apliquen esa plantilla de manera consistente en todas las solicitudes futuras.</li>\n  <li>El número mínimo de revisores para aprobar un fragmento de código; esto dependerá del tamaño del equipo.</li>\n  <li>Canales o herramientas de comunicación al equipo cuando un código este listo para ser revisado.</li>\n  <li>El tiempo entre las revisiones, es decir, que si un desarrollador marca un fragmento de código listo para revisarse y el equipo hace sugerencias o solicita cambios, y seguido de eso el desarrollador aplica los cambios solicitados, debe establecerse la cantidad de tiempo que debe pasar para solicitar una nueva revisión. Esta regla puede ser útil en equipos grandes que están involucrados en diferentes sistemas y necesitan dividir el tiempo entre el desarrollo y la revisión. En equipos pequeños, una regla de este tipo es opcional.</li>\n</ul>\n\n<h2 id=\"revisión-efectiva\">Revisión efectiva</h2>\n<blockquote>\n\n  <p>“Una buena revisión necesita de experiencia y profesionalismo y no de nivel de seniority.”</p>\n</blockquote>\n\n<p>Solo algunos desarrolladores son capaces de aplicar una buena revisión del código, esa es la razón principal por la que escribir esta publicación. El Code Review no es una práctica nueva en lo absoluto. Por el contrario, ha existido durante décadas, desde que las personas comenzaran a escribir código. Una de las primeras referencias a esta práctica como proceso formal se encuentra en el libro “The Mythical Man-Month” de Fred Brooks, publicado en 1975.</p>\n\n<p>Entonces, ¿por qué te pareció un tema importante? he estado trabajando con equipos de Ingeniería de Software durante aproximadamente 12 años y sigo leyendo comentarios que tienen un tono vago o agresivo o que carecen de explicación y contexto, lo que dificulta la aplicación efectiva de cambios en el código.</p>\n\n<h3 id=\"la-revisión-de-código-no-es-una-práctica-para\">La revisión de código <em>NO ES</em> una práctica para</h3>\n\n<ul>\n  <li>Demostrar superioridad.</li>\n  <li>Hacer que otros se sientan inseguros.</li>\n  <li>Imponer estilos de codificación.</li>\n  <li>En resumen, ser un idiota.</li>\n</ul>\n\n<p><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_350/v1677550574/221453027-36a424b8-7ff5-4b17-bc8a-9bda2e223c22_rahapd.png\" alt=\"No\" class=\"align-center\" /></p>\n\n<p>Aquí algunos ejemplos.</p>\n\n<p><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,q_100,w_800/v1677550576/221453038-b93d320a-5389-40e8-bf58-cd24b42910c4_ta57tb.png\" alt=\"code example\" class=\"align-center\" /></p>\n\n<p>Mala revisión:\n“Este código es malo. ¿Por qué estás haciendo una búsqueda lineal?”</p>\n\n<p>Buena revisión:\n“Este bloque de código podría optimizarse mediante el uso de una búsqueda binaria en lugar de una lineal. Esto mejoraría el rendimiento al buscar en grandes conjuntos de datos”.</p>\n\n<p>Como puedes ver en la mala revisión, hay más críticas que propuestas de alternativas o solución, o carece de la explicación del por qué se debe mejorar el código. Por el otro lado, la buena revisión ofrece una optimización, explicando por qué el enfoque diferente puede mejorar la función.</p>\n\n<p>Más malos ejemplos:</p>\n\n<ul>\n  <li>\n    <p>“Este código apesta”. - Esto no es útil y no proporciona comentarios ni sugerencias para mejorar.</p>\n  </li>\n  <li>\n    <p>“No entiendo lo que estás tratando de hacer aquí”. - Esto es desdeñoso y no proporciona comentarios constructivos. Si hay una duda genuina de la implementación lo ideal es expresar esa duda lo mejor posible.</p>\n  </li>\n  <li>\n    <p>“Yo no lo haría de esta manera”. - Este comentario no es útil y le faltan razones o sugerencias para mejorar el código en revisión.</p>\n  </li>\n</ul>\n\n<p>Los comentarios en una revisión del código deben ser específicos, constructivos y aplicables, evitando agresiones personales, un lenguaje desdeñoso y generalizaciones.</p>\n\n<p>Evite por completo el uso de signos de exclamación e íconos para enfatizar comentarios negativos. Por último, recuerda que las malas interpretaciones son comunes en la comunicación escrita y pueden ocurrir aunque la intención sea buena.</p>\n\n<h3 id=\"la-revisión-de-código-si-es-una-práctica-para\">La revisión de código <em>SI ES</em> una práctica para</h3>\n\n<ul>\n  <li>Incentivar el trabajo en equipo.</li>\n  <li>Reconocer el buen trabajo.</li>\n  <li>Ser flexible con los estilos de código y aprender de el equipo.</li>\n  <li>En resumen, es para ser un miembro del equipo.</li>\n</ul>\n\n<p><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_350/v1677550578/221453050-3cc5f85d-a2bd-4f67-9aa6-9a0e1ddf76b2_hol1iu.png\" alt=\"approved symbol\" class=\"align-center\" /></p>\n\n<p><em>Aquí te dejo una sugerencia poderosa</em>, no solo comentes lo que consideres que se puede cambiar o mejorar, sino también comenta lo que te gustó en una implementación, por ejemplo:</p>\n\n<ul>\n  <li>“¡Buen trabajo! Este código está muy bien organizado y es fácil de entender. Aprecio especialmente cómo usaste las funciones integradas en la biblioteca estándar de Go para simplificar el código. ¡Sigue con el excelente trabajo!””</li>\n</ul>\n\n<p>Adicionalmente, recuerda tomarte el tiempo. El trabajo es exigente y, a veces, no dedicamos suficiente tiempo a las revisiones, y comentamos “¡LGTM!” (Me parece bien) para seguir adelante, pero recordemos que el otro desarrollador dedicó tiempo a trabajar en esos cambios, por lo que vale la pena revisarlos con cuidado.</p>\n\n<p>Otra sugerencia que les dejo es establecer el prefijo “NIT” (<em>nitpicker</em>) en los comentarios, lo que significa que puedes sugerir un cambio, pero no bloquea ni impide que ese el código en revisión sea aceptado; es simplemente una “perfección” que sugieres pero que puede ser ignorada.</p>\n\n<h2 id=\"mi-código-es-el-que-esta-en-revisión\">Mi código es el que esta en revisión</h2>\n\n<p>Por último, ser la persona que recibe las revisiones también requiere práctica.</p>\n\n<ol>\n  <li>\n    <p>No te lo tomes como algo personal.\nAunque recibas un mal comentario, recuerda que el objetivo del equipo siempre será entregar un software de calidad. Se está revisando una parte de tu código, no su persona o tu trabajo en sí.</p>\n  </li>\n  <li>\n    <p>Se un miembro de equipo.\nOtras personas usarán el código que escribiste hoy. Por lo tanto, es fundamental estar abierto a modificar tu trabajo por el bien del equipo y del producto final.</p>\n  </li>\n  <li>\n    <p>Responde positivamente a los comentarios.\nHabrá casos en los que, como desarrollador que escribió el código en revisión, tendrás razones para creer que es la solución que debe fusionarse, sin embargo, si alguien solicita cambios o sugiere algo, debes comunicar tus razones de forma clara y justificada.</p>\n  </li>\n  <li>\n    <p>Participa en el intercambio de revisiones.\nNo seas solo un espectador que genera código para ser revisado. Considera que independientemente de tu nivel, la experiencia que se obtiene leyendo código al máximo no se ve superada por nada.</p>\n  </li>\n</ol>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>Estamos en el año 2023, y la IA nos acompaña a diario en nuestras actividades, algunas prácticas desaparecerán pero los diferenciadores permanecerán. Una máquina puede decirnos qué está mal o dónde se puede mejorar una parte del código, sin embargo, la calidez, la empatía y el apoyo que otro ser humano puede brindarnos no se puede reemplazar (todavía), sigamos practicándolo y demos lo mejor de nosotros en todos los procesos en los que participamos.</p>\n",
      "date_published": "Mon, 27 Feb 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/02/17/la-importancia-de-entender-los-principios-de-la-computacion.html",
      "url": "https://blog.thedojo.mx/2023/02/17/la-importancia-de-entender-los-principios-de-la-computacion.html",
      "title": "La importancia de entender los principios de la computación",
      "content_html": "<p>Este artículo está inspirado por lo que leí en el resumen del libro que <a href=\"https://camilochs.github.io/web/\">Camilo Chacón Sartori</a> está escribiendo y que muy amablemente me compartió para que le diera mi opinión. El libro se llama <strong>“Principios de programación”.</strong> Espero que pronto esté disponible, pero mientras, hablemos de la importancia de comprender los principios básicos de la computación y programación, con la esperanza de que te emociones por aprender más sobre ellos.</p>\n\n<p>Empecemos hablando de qué son los principios.</p>\n\n<h2 id=\"qué-es-un-principio\">¿Qué es un principio?</h2>\n\n<p>En donde más se oye este término si no estás metido en ciencia es en ética. Por ejemplo, dice que una persona o una empresa tiene “principios”. ¿A qué se refiere?</p>\n\n<p>Yo definiría un principio como un hecho que está en <strong>los fundamentos</strong> de un sistema de creencias. Por eso, cuando hablamos de una persona con principios, nos referimos a alguien que tiene bien claro lo que <em>piensa del mundo</em> y de las situaciones que se le presentan. Como consecuencia, tiene claro cómo <em>actuará</em> en cada situación.</p>\n\n<p>En las ciencias, un principio es más o menos lo mismo, un hecho comprobado que da pie y soporte a una teoría más amplia, que nos permite comprender el mundo y generar más conocimiento, sea mediante la experimentación o la reflexión (esto incluye la inducción, deducción y predicción).</p>\n\n<p>En las leyes, un principio es una guía general que da soporte a normas y leyes.</p>\n\n<p>Como resumen: un principio fundamenta un sistema de creencias, una teoría o una ley. Así que esto te puede dar una idea de lo importante que es entender los principios de tu profesión. Hablemos de los principios más importantes relacionados con la computación y el desarrollo de software.</p>\n\n<h2 id=\"principios-importantes-de-la-computación\">Principios importantes de la computación</h2>\n\n<p>Desde mi punto de vista, los principios más importantes tienen que ver con la naturaleza misma de la computación y nuestra manera de interactuar con ella. Entender los límites y lo que podemos hacer con una computadora es primordial para poder desarrollar software de calidad.</p>\n\n<p>Estos principios incluyen:</p>\n\n<ul>\n  <li>Las mejores formas de representar información</li>\n  <li>La complejidad de las operaciones en tiempo y espacio (memoria)</li>\n  <li>Cosas imposibles de lograr con una computadora</li>\n  <li>Los diferentes modelos de computación que se han inventado (¿o descubierto?)</li>\n</ul>\n\n<p>¿Se te ocurre algún otro? Me gustaría leerlo en los comentarios.</p>\n\n<h2 id=\"principios-de-conducta\">Principios de conducta</h2>\n\n<p>Como casi todas las carreras humanas, las ciencias de la computación y el desarrollo de software tiene prácticas que conviene seguir, sobre todo si se quiere dominarlas y pasarla bien haciéndola. A estos los llamamos principios de conducta.</p>\n\n<p><strong>¿Qué prácticas nos conviene tener?</strong> La mayoría tiene que ver con la capacidad de tratar bien con las personas. Casi ningún software serio se puede hacer solo en tiempo razonable (pero por supuesto que hay <a href=\"https://stackoverflow.blog/2021/12/31/700000-lines-of-code-20-years-and-one-developer-how-dwarf-fortress-is-built/\">excepciones</a>). Por eso, considero que los principios de conducta más importantes son:</p>\n\n<ul>\n  <li>La capacidad de comunicar tus ideas efectivamente</li>\n  <li>Responsabilidad</li>\n  <li>Capacidad de resolver conflictos</li>\n  <li>Organización del tiempo de trabajo</li>\n  <li>Capacidad de dividir el trabajo y repartirlo</li>\n</ul>\n\n<p>Además de estas capacidades o principios se tienen que desarrollar otra conductas que son importantes individualmente:</p>\n\n<ul>\n  <li>La capacidad de aprender de forma efectiva</li>\n  <li>Atención a los detalles</li>\n  <li>Resiliencia y perseverancia</li>\n</ul>\n\n<p>Todas estas son cosas que casi cualquier profesional debe tener, pero son superlativamente importantes en el desarrollo de software si quieres avanzar. Aquí sólo hablamos de los nombres, pero si te interesa alguna puedes investigar más profundamente sobre ese principio.</p>\n\n<h2 id=\"principios-de-programación-libro\">Principios de Programación (libro)</h2>\n\n<p>Camilo Chacón Sartori, un gran amigo de The Dojo MX, está terminando de escribir un libro que se llama “Principios de Programación” (tal vez para cuando leas esto ya esté disponible). En él, habla mucho más extensamente de los principios que hemos mencionado en este post.</p>\n\n<p>Ahí podrás encontrar temas como las cosas que debes entender fundamentalmente de la computación hasta sus recomendaciones de lo que hace falta para tener una buena vida, claro, todo relacionado con la actividad de programar como tu profesión. No te lo pierdas si quieres seguir avanzando en tu carrera como desarrollador@ de software.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>Conocer y aplicar los principios de la ciencias de la computación y relacionados con la creación de software te ayudará a disfrutar más del trabajo, a avanzar en tu carrera y conseguir mejores resultados. Continua profundizando en ellos y aprendiendo más formas de aplicarlos, para mejorar tu trabajo y tu vida.</p>\n\n<p>Gracias a <a href=\"https://camilochacon\">Camilo Chacón Sartori</a> por escribir sobre este tipo de cosas y levantar temas tan importantes.</p>\n",
      "date_published": "Fri, 17 Feb 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/02/08/maquinas-de-turing-no-deterministas-y-problemas-np.html",
      "url": "https://blog.thedojo.mx/2023/02/08/maquinas-de-turing-no-deterministas-y-problemas-np.html",
      "title": "Máquinas de Turing no deterministas y problemas NP",
      "content_html": "<p>En el artículo anterior hablamos de las clases de complejidad y su relación con la criptografía. Hablamos brevemente de los problemas NP y de dijimos que pueden ser resueltos por una máquina de Turing no determinista en un tiempo razonable (complejidad polinomial).</p>\n\n<p>En este artículo vamos a entender qué son las máquinas de Turing no deterministas, pero empecemos entendiendo la diferencia entre determinismo y no determinismo.</p>\n\n<h2 id=\"determinismo-y-no-determinismo\">Determinismo y no determinismo</h2>\n\n<p>En la física y las ciencias existen básicamente dos tipos de sistemas basados en el conocimiento que podemos tener de su comportamiento en un momento dado.</p>\n\n<p>El primer tipo es el de los sistemas deterministas, en el que saber el estado actual del sistema y el evento (o la entrada del sistema) nos permite predecir el estado futuro del sistema, sin errores y con una precisión infinita. En estos sistemas existen una serie de reglas que no se pueden romper y que nos dan la capacidad saber exactamente lo que sucederá. Estos sistemas son casi siempre simplificaciones del mundo real o sistemas creados y diseñados por el hombre. Ejemplos de estos sistemas son:</p>\n\n<ul>\n  <li>El juego de la vida</li>\n  <li>El ajedrez</li>\n  <li>El juego de Go</li>\n  <li>Casi todos los problemas que analizamos en un clase de física son tratados como deterministas, por ejemplo, el movimiento de un proyectil, una mesa de billar, etc., aunque no lo sean realmente, se tratan como tales para simplificar el análisis.</li>\n</ul>\n\n<p>El segundo tipo son los <strong>sistemas no deterministas o estocásticos</strong>. En estos sistemas no tenemos la información suficiente para poder predecir estados futuros del sistema de manera precisa, solamente podemos predecir probabilidades. Algunos ejemplos de estos sistemas son:</p>\n\n<ul>\n  <li>El clima</li>\n  <li>El comportamiento de una persona</li>\n  <li>El comportamiento de un mercado de un mercado financiero</li>\n  <li>Una selección aleatoria de elementos de un conjunto</li>\n</ul>\n\n<p>En pocas palabras, en un sistema determinista podemos predecir la salida si conocemos la entrada con toda seguridad. En un sistema no determinista o estocástico sólo podemos dar una probabilidad de que algo suceda en el mejor de los casos.</p>\n\n<h2 id=\"máquinas-de-turing-deterministas\">Máquinas de Turing deterministas</h2>\n\n<p>Si no sabes lo que es una máquina de Turing tradicional, una de las mejores explicaciones que hemos encontrado está en el libro <a href=\"/assets/pdfs/la_mente_nueva_del_emperador.pdf\" target=\"_blank\">“La Mente nueva del Emperador”</a> de <strong>Roger Penrose</strong>.</p>\n\n<p>Lo que debes saber es que estas representan un modelo universal de computación, todo lo que se puede computar (calcular, o conocer con certeza) se puede representar en una máquina de Turing. Te la puedes imaginar como una máquina que lee de una cinta infinita que contiene tanto las instrucciones como los datos de entrada. ¿Te suena? Es como funcionan las computadoras actualmente: el ejecutor es el CPU y la cinta es la memoria.</p>\n\n<p>La máquina de Turing como se definió es determinista, es decir siempre para el la misma entrada obtendremos la misma salida. En cada punto de su cálculo la máquina de Turing sabe <strong>exactamente qué hacer</strong>.</p>\n\n<p>Ahora hablemos de otro modelo de computación: las máquinas de Turing no deterministas.</p>\n\n<h2 id=\"máquinas-de-turing-no-deterministas\">Máquinas de Turing no deterministas</h2>\n\n<p>Apliquemos el concepto del “no determinismo” al modelo de computación de lo que acabamos de hablar. Recordemos que la en la máquina de Turing tradicional, para un mismo estado y una misma entrada de datos (o eventos), siempre obtendremos la misma acción.\nEn contraparte, una máquina no determinista puede tener múltiples acciones para un mismo estado y una misma entrada o evento.</p>\n\n<p>Esto implica que este tipo de computación también puede tener múltiples resultados posibles para un mismo conjunto de entrada.</p>\n\n<p>El comportamiento de una máquina de Turing no determinista es hasta cierto grado impredecible. Incluso con las mismas entradas y estados, la máquina puede devolver diferentes resultados en diferentes ejecuciones.</p>\n\n<p>Estas máquinas también fueron definidas (o más bien, mencionadas) en el mismo documento en que Turing definió las máquinas tradicionales: <a href=\"/assets/pdfs/Turing_Paper_1936.pdf\" target=\"_blank\">ON COMPUTABLE NUMBERS, WITH AN APPLICATION TO THE ENTSCHEIDUNGSPROBLEM</a>. A estas él las llamó <strong>máquinas de selección</strong> (choice machines o <em>c-machine</em>). La definición más formal la podemos encontrar en  un documento escrito por Rabin y Scott en 1959: <a href=\"/assets/pdfs/rabin_scott_1959.pdf\" target=\"_blank\">Finite Automata and Their Decision Problems</a>, en el que se habla de Autómatas Finitos No Deterministas (AFND), una especialización finita de las máquinas de Turing.</p>\n\n<p>A diferencia de los sistemas no deterministas de los que hablamos arriba, las máquinas de Turing no deterministas no es que tengan una probabilidad de pasar de un estado a otro, sino que la máquina puede “seleccionar” una transición de un estado a otro. En el documento de Turing mencionado anteriormente, se menciona que estas máquinas son “operadas” por un humano, que <strong>elige</strong> qué camino tomar, por eso las llamó máquinas de selección. En referencias más modernas no se especifica el mecanismo de selección.</p>\n\n<p>Para una misma entrada una máquina de Turing no determinista puede tener múltiples salidas posibles, algunas de ellas válidas y otras no. Para que una máquina de Turing encuentre el resultado correcto, <strong>debe probar todas las posibles salidas y seleccionar la correcta</strong>.</p>\n\n<p>Una NTM (<em>Non-deterministic Turing Machine</em>, así la llamaremos a partir de ahora) es una construcción matemática que no existe en la vida real, es decir, no hay computadora que funcione como una NTM.</p>\n\n<h2 id=\"relación-entre-las-máquinas-de-turing-deterministas-y-no-deterministas\">Relación entre las máquinas de Turing deterministas y no deterministas</h2>\n\n<p>Se ha demostrado que para cada máquina de Turing no determinista existe una máquina de Turing determinista equivalente. Lo malo es que esta máquina de Turing determinista necesita <strong>exponencialmente</strong> más nodos o <em>pasos</em>. Por ejemplo, si una NTM necesita tiene 100 posibles estados, entonces la máquina de Turing equivalente necesitará aproximadamente 2^100 estados.</p>\n\n<p>Y aquí es donde entra la relación con los problemas NP.</p>\n\n<h2 id=\"relación-con-los-problemas-np\">Relación con los problemas NP</h2>\n\n<p>Como te darás cuenta, las NTM tienen mucho que ver con la combinatoria, porque necesitan probar todas las posibles combinaciones de estados y transiciones para encontrar la solución correcta.</p>\n\n<p>Si ejecutáramos una NTM en una computadora, tendríamos que probar cada uno de esos estados. Esto es exactamente lo mismo que sucede con muchos problemas NP o NP-completo, para encontrar una solución se tienen que probar todas las posibles combinaciones en un conjunto de elementos.</p>\n\n<p>Las siglas NP significan <em>Non-deterministic Polynomial</em> (polinomial no determinista), y esto significa que en una NTM hay por lo menos un camino que resuelve el problema en un tiempo polinomial. <em>El problema es saber cuál de todos los caminos</em>.</p>\n\n<p>Y de ahí viene su nombre. Todos estos problemas tienen una solución que corre en tiempo polinomial, pero para encontrarla tenemos que <em>adivinar</em> o <em>probar todas las combinaciones</em>.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>Ahora que sabemos como funciona una máquina de Turing no determinista, que es una construcción teórica que nos sirve para hacer experimentos del pensamiento y  además que tienen una relación muy estrecha con la teoría de la complejidad y los problemas NP.</p>\n",
      "date_published": "Wed, 08 Feb 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/02/03/problemas-dificiles-de-la-computacion-y-su-relacion-con-la-criptografia.html",
      "url": "https://blog.thedojo.mx/2023/02/03/problemas-dificiles-de-la-computacion-y-su-relacion-con-la-criptografia.html",
      "title": "Problemas difíciles de la computación y su relación con la criptografía: Problemas NP",
      "content_html": "<p>La intuición a veces nos dice que cualquier cálculo numérico <em>debería</em> ser muy fácil para una computadora. Sin embargo, hay problemas numéricos y no numéricos que son imposibles de resolver para las computadoras actuales, independientemente de su poder de procesamiento.</p>\n\n<p>La <strong>criptografía</strong> actual está soportada por una serie de problemas que <em>suponemos muy difíciles</em> de resolver de la ciencias de la computación.</p>\n\n<p>En esta serie de artículos vamos a estar hablando de ellos para entenderlos a profundidad y sobre todo para entender cómo es que se relacionan con los algoritmos criptográficos, como con los algoritmos de llave pública, como Diffie-Hellman y RSA.</p>\n\n<p>Pero primero hablemos de lo que consideramos un problema difícil de la computación y la complejidad computacional.</p>\n\n<h2 id=\"complejidad-computacional\">Complejidad computacional</h2>\n\n<p>La complejidad computacional se puede entender como la <strong>cantidad de operaciones</strong> que un algoritmo ejecuta para finalizar. Esta cantidad de operaciones es una función (en el sentido <em>matemático</em>) de la entrada del problema. Puedes pensar en una función como una relación entre la entrada y el tiempo de ejecución.</p>\n\n<p>Por ejemplo, si te piden contar todas las letras “a” e una cadena, esto podría resolverse de la siguiente manera en Python:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">contar_a</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"p\">):</span>\n    <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"k\">for</span> <span class=\"n\">char</span> <span class=\"ow\">in</span> <span class=\"n\">string</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">char</span> <span class=\"o\">==</span> <span class=\"s\">\"a\"</span><span class=\"p\">:</span>\n            <span class=\"n\">count</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n    <span class=\"k\">return</span> <span class=\"n\">count</span>\n</code></pre></div></div>\n\n<p>¿Cuántas operaciones tarda este algoritmo? Como dijimos <em>depende</em> de la entrada. Esa relación de dependencia es una función. Lo que la función nos dice es <em>qué relación existe</em> entre la entrada y la cantidad de operaciones que se ejecutan.</p>\n\n<p>En este ejemplo específico, tenemos que hacer  1 ó 2 operaciones por cada letra de la entrada, y esto no cambia, independientemente de la longitud de esta cadena de entrada. Por lo tanto la función que describe la relación entre la entrada y la cantidad de operaciones es:</p>\n\n\\[f(n) = 2n\\]\n\n<p>Donde $n$ es la longitud de la cadena de entrada. Como esta relación crece proporcionalmente a la entrada, es decir, lo mismo que crece la entrada crece el tiempo de ejecución, decimos que este algoritmo es de complejidad lineal.</p>\n\n<h2 id=\"complejidad-polinomial-p\">Complejidad polinomial (P)</h2>\n\n<p>Un polinomio es una expresión matemática que consiste en sumas, restas, multiplicaciones, divisiones y potencias de números.</p>\n\n<p>Un algoritmo es de complejidad polinomial si su tiempo de ejecución es una función que consiste en multiplicaciones, sumas o elevaciones a <em>ciertas</em> potencias del tamaño de la entrada. Algunos ejemplos de complejidad polinomial son:</p>\n\n\\[f(n) = 2n\\]\n\n\\[f(n) = 3n^2\\]\n\n\\[f(n) = 4n^3\\]\n\n\\[f(n) = n^{log(n)}\\]\n\n<p>En la práctica, si un algoritmo es tiene complejidad polinomial quiere decir que su ejecución es más o menos rápida (o por lo menos posible en caso de polinomios muy grandes) para cualquier entrada.</p>\n\n<h2 id=\"la-notación-big-o\">La notación Big O</h2>\n\n<p>La notación más usada para expresar la complejidad no es la de una función común como lo hemos hecho hasta ahora. Normalmente, lo que nos interesa es expresar o conocer <strong>el peor de los casos</strong> para un algoritmo específico. Por ejemplo, si estamos observando un algoritmo de búsqueda como el siguiente:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>  <span class=\"k\">def</span> <span class=\"nf\">buscar</span><span class=\"p\">(</span><span class=\"n\">lista</span><span class=\"p\">,</span> <span class=\"n\">elemento</span><span class=\"p\">):</span>\n      <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">lista</span><span class=\"p\">)):</span>\n          <span class=\"k\">if</span> <span class=\"n\">lista</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">elemento</span><span class=\"p\">:</span>\n              <span class=\"k\">return</span> <span class=\"n\">i</span>\n      <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mi\">1</span>\n</code></pre></div></div>\n\n<p>El peor de los casos es cuando el elemento esté en el último lugar. Por lo tanto, su complejidad en el peor de los casos depende directamente de la longitud de la lista de entrada. Podemos expresar esta complejidad con una función como:</p>\n\n\\[f(n) = n\\]\n\n<p>Pero la notación Big O nos permite expresar esto de una manera más simple:</p>\n\n\\[O(n)\\]\n\n<p>En el ejemplo de arriba, de la búsqueda de las letras “a” en una cadena, la complejidad que calculamos expresada como función en el peor de los casos es:</p>\n\n\\[f(n) = 2n\\]\n\n<p>En la notación Big O se eliminan todas los valores constantes, y por la tanto esta complejidad se expresa como:</p>\n\n\\[O(n)\\]\n\n<p>Equivalente al ejemplo anterior. Lo que tienes que recordar de la notación Big O es que te da un <strong>límite superior</strong> de operaciones que se ejecutarán para un algoritmo. Este límite lo podemos pensar como una línea que el algoritmo nunca va a tocar y mucho menos a rebasar, esto se llama una asíntota en matemáticas, por lo que también se le conoce como <strong>notación asintótica</strong>.</p>\n\n<p>En este artículo no vamos a hablar de cómo calcular más complejidades, pero probablemente lo hagamos en uno futuro. A este tipo de cálculo, o análisis de algoritmos se le llama <strong>“análisis asintótico”</strong>.</p>\n\n<p>Ahora, con esta notación, estamos listos para seguir hablando de las clases de complejidad.</p>\n\n<h2 id=\"complejidad-súper-polinomial\">Complejidad súper polinomial</h2>\n\n<p>Una clase que estaría bien separar de los polinomios que acabamos de hablar, es la de los tiempos <em>súper polinomiales</em>. Estos algoritmos tienen una complejidad que crece muy rápido con respecto a su entrada. Por ejemplo:</p>\n\n\\[O(n^{n ^ 2})\\]\n\n\\[O(n!)\\]\n\n\\[O(2^n)\\]\n\n<p>Estos tres ejemplos crecen más rápido que cualquier función polinomial que común que podamos representar como \\(O(n^k)\\), siendo k <em>una constante</em> (que normalmente es un número pequeño).</p>\n\n<p>A esta clase de complejidad la empezamos ya a considerar como problemas intratables en la computación. Pero hablemos, dentro de los tiempos súper polinomiales de otra clase característica.</p>\n\n<h3 id=\"complejidad-exponencial-exp\">Complejidad Exponencial (EXP)</h3>\n\n<p>La clase de complejidad exponencial se expresa como \\(O(2^n)\\). Cuando un algoritmo tiene un complejidad de esta categoría o mayor, se considera completamente incalculable.</p>\n\n<p>Por ejemplo, si midiéramos la entrada en bits y tuviéramos una entrada de 100 bits, el número de operaciones sería \\(2^{100}\\). Suponiendo que una buena computadora pudiera hacer 1,000,000 de operaciones por segundo, esta tardaría \\(2^{81}\\) segundos en completar el cálculo. Sin embargo, calculamos que el universo “sólo” ha existido por menos de \\(2^{34}\\). Así de grande es la complejidad exponencial.</p>\n\n<p>Te preguntarás si con una computadora más rápida podemos resolver el problema. Veamos el récord de la computadora más poderosa en 2023, que puede hacer 1,000,000,000,000,000,000 de operaciones por segundo. Esto es \\(2^{59.8}\\). Esto significa que una computadora de este tamaño tardaría \\(2^{40.2}\\) segundos. “Poco” más que la edad del universo.</p>\n\n<p>Este tipo de algoritmos son los que hay que ejecutar para encontrar una llave por fuerza bruta. Si quieres por ejemplo encontrar una llave de <a href=\"/2020/12/03/tipos-de-algoritmos-criptograficos.html#aes\">AES</a>, tendrías que hacer \\(2^128\\) intentos, en el peor de los casos.</p>\n\n<h2 id=\"tiempos-polinomiales-no-deterministas-np\">Tiempos polinomiales no deterministas (NP)</h2>\n\n<p>Hasta ahora hemos hablado de tiempos polinomiales que estamos seguros que <em>siempre</em> se van a comportar como los conocemos o incluso van a mejorar.</p>\n\n<p>Para las clases que hemos hablado existe su equivalente <em>no determinista</em>.</p>\n\n<p>¿Qué tiene que ver el determinismo con la complejidad? El determinismo en las clases anteriores significa que sabemos con certeza que el resultado está abajo de la línea de complejidad que la notación Big O describe.</p>\n\n<p>En el caso de los tiempos polinomiales no deterministas significa que una máquina de Turing no determinista puede resolver el problema en un tiempo polinomial. El que la máquina sea no determinista significa que no sabemos si el resultado está abajo de la línea de complejidad que la notación Big O describe, o que a veces lo logrará y otras veces no.</p>\n\n<p>Esto en otras palabras, significa que para los problemas con complejidad NP se puede <strong>adivinar</strong> una solución en un tiempo finito no muy grande, pero no se puede encontrar esta solución o garantizar que se encontrará en un tiempo razonable para cada una de las entradas del algoritmo.</p>\n\n<p>Otra característica que tienen los problemas NP es que aunque encontrar una solución sea difícil, verificarla es fácil.</p>\n\n<p>Un ejemplo de un problema NP es el de encontrar una llave de <a href=\"/2020/12/03/tipos-de-algoritmos-criptograficos.html#aes\">AES</a> cuando conocemos el texto plano. Usando la fuerza bruta por ejemplo, podríamos encontrar la llave en un golpe de suerte y podríamos verificar que la llave es la correcta comparando el texto plano con el texto descifrado, si son iguales, entonces la llave es correcta.</p>\n\n<p>Muchos de los problemas NP tienen que ver con combinatoria, con problemas que tienen que ver con la cantidad de combinaciones posibles que hay en un conjunto de elementos, justo como las llaves criptográficas.</p>\n\n<h2 id=\"np-complete\">NP-Complete</h2>\n\n<p>Los problemas NP-Complete son la clase más difícil de resolver dentro de los problemas NP. Estos problemas se pueden transformar en otros problemas NP-complete, lo que significa que si se puede resolver un problema NP-complete, se puede resolver cualquier otro problema NP-complete en un tiempo razonable.</p>\n\n<h2 id=\"problemas-que-creemos-que-son-difíciles-y-problemas-np\">Problemas que creemos que son difíciles y problemas NP</h2>\n\n<p>La criptografía actual se basa en problemas que creemos que son por lo menos NP. ¿Por qué usamos la palabra “creemos”? Porque no podemos probar que son NP, pero hasta el momento nadie ha encontrado una forma de resolverlos en tiempo polinomial, pero creemos que lo pueden ser. Lo ideal sería usar problemas que sean NP-Complete, pero no hay muchos problemas NP-Complete que se puedan usar en la criptografía, además de que existe la posibilidad de que si resuelven un problema NP-Complete, se resuelvan todos los problemas NP-Complete, lo que rompería la criptografía actual.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>La criptografía moderna se basa en problemas muy difíciles de resolver para cualquier computadora, para los que no existe un algoritmo eficiente que pueda encontrar una solución garantizada cada vez. Algunos de estos problemas son fáciles de verificar una vez que se propone una solución y son justo estos los que son más útiles para la criptografía.</p>\n\n<p>Lo más interesante es que la criptografía simétrica crea un problema NP con sus llaves: encontrar una llave de cifrado es casi imposible en un tiempo razonable, pero verificar si es correcta si se tiene el tiempo original es muy fácil.</p>\n\n<p>En los próximos artículos hablaremos específicamente de algunos de estos problemas, sobre todo aquellos en los que la criptografía asimétrica se basa.</p>\n",
      "date_published": "Fri, 03 Feb 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/01/25/patrones-de-aprendizaje-cava-mas-hondo.html",
      "url": "https://blog.thedojo.mx/2023/01/25/patrones-de-aprendizaje-cava-mas-hondo.html",
      "title": "Patrones para aprendices: Cava más hondo",
      "content_html": "<p>¿Sientes que sabes un poquito de muchas cosas pero no te sientes con lo confianza de decir que eres experto en algo? Muchos desarrolladores de software sentimos eso, exacerbado por la gran cantidad de herramientas, lenguajes y situaciones que las necesidades del negocio nos impone.</p>\n\n<p>En este artículo vamos a hablar acerca de un un consejo encontrado en el libro <a href=\"https://www.oreilly.com/library/view/apprenticeship-patterns/9780596806842/\">Apprenticeship Patterns</a> que en español llamaríamos “Patrones para aprendices”. En este libro se mencionan una serie de consejos con acciones para los desarrolladores de software que se consideran aprendices. En realidad es una buena idea siempre tener “la mentalidad del aprendiz”, aquella que considera que tiene mucho que aprender y se mantiene humilde.</p>\n\n<p>Los consejos de este libro se enmarcan en la misma forma que lo que conocemos como <em>patrones de diseño</em>, en cada uno se dan tres partes:</p>\n\n<ul>\n  <li><strong>Contexto</strong>: describe una situación típica en la que puedes estar en la que el consejo puede ser útil</li>\n  <li><strong>Problema</strong>: describe específicamente el conflicto que surge y que se puede resolver con el consejo</li>\n  <li><strong>Solución</strong>: describe las acciones que puedes tomas para resolver el problema de manera efectiva</li>\n</ul>\n\n<p>Aunque este libro tiene sus cosas negativas, tiene grandes consejos, como el que vamos a ver en este artículo. Empecemos a hablar de él.</p>\n\n<h2 id=\"la-situación-y-el-problema\">La situación y el problema</h2>\n\n<p>Eres un desarrollador o desarrolladora de software que se desenvuelve más que decentemente en su trabajo. Te piden algo y aunque no lo conozcas, tienes la habilidad de entender lo suficiente del problema rápidamente para “sacar” el trabajo. Sin embargo, cuando te preguntan en qué te sientes más cómodo programando, o en qué podrías decir que eres un experto, te sientes inseguro de contestar.</p>\n\n<p>El problema es que no te has dado el tiempo de conocer nada profundamente y sabes un poco, muy poco de hecho, de muchas cosas, generalmente las cosas más superficiales. No entiendes los principios de funcionamiento de las cosas que usas.</p>\n\n<h2 id=\"la-solución\">La solución</h2>\n\n<p>En el principio que David Hoover nombra “Cava más hondo” (Dig Deeper), sugiere lo siguiente:</p>\n\n<p>En vez de sólo conformarte por entender lo mínimo aprende a estudiar aquellos problemas que se te presentan con más profundidad. Aprender a investigar el funcionamiento fundamental de las herramientas, lenguajes y técnicas que usas te separará de los desarrolladores que se conforman con el conocimiento mínimo necesario que el día a día nos deja.</p>\n\n<ul>\n  <li>\n    <p><strong>Leer las especificaciones y la documentación.</strong> Esto te va a dar el conocimiento directo de la fuente primaria de la información. Es muy importante leerlo directamente del primer creador porque nadie (o muy pocas personas más) te pueden explicar el trasfondo del asunto tan bien como él. Existen miles de tutoriales o videos ahí afuera, que son útiles en ciertas situaciones, pero para profundizar, hay pocas cosas mejores que las referencias o documentos de diseño originales.</p>\n  </li>\n  <li>\n    <p><strong>Aprender a usar las herramientas de tu entorno a profundidad.</strong> La mayoría de los lenguajes de programación tienen herramientas que te permiten entender cómo está corriendo cierta parte del programa. Si tu lenguaje no lo tienen, existen herramientas a nivel del sistema operativo que te permitirán entender el funcionamiento a fondo.</p>\n  </li>\n  <li>\n    <p><strong>Entiende los problemas a fondo.</strong> Cuando estés analizando código, un tutorial, o alguien que te explique algo, intenta entender las ideas que están en el fondo de las cosas que te están explicando, no sólo las cosas que están en la superficie. Intenta absorber el pensamiento que los guió a la solución que están presentando. Para hacer esto, debes reconstruir el contexto en el que surgió el problema y la solución que se presenta.</p>\n  </li>\n</ul>\n\n<h2 id=\"ventajas\">Ventajas</h2>\n\n<p>Tener estas habilidades te permitirá entender cómo debería funcionar algo, además de el funcionamiento real en acción de lo que estás usando. Si algo no te gusta como funciona, puedes cambiarlo o mejorarlo.</p>\n\n<p>Al tener conocimiento profundo en ciencias de la computación, es probable que puedas resolver cosas que nunca te imaginaste o que crees una solución que se destaque y deje a las soluciones existentes muy por detrás.</p>\n\n<p>Finalmente, este conocimiento te puede dar la capacidad de ayudar a tu equipo, enseñándole cosas que harán que tanto ellos como tu empresa avancen más rápido.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>Te preguntarás: <strong>¿de dónde sale el tiempo para aprender esto?</strong> Puedes apartar un poco de tiempo de tu trabajo, pero debido a las exigencias que el día a día impone, debes considerar esto como un ejercicio de aprendizaje que la mayoría de las veces va a correr por tu cuenta.</p>\n\n<p>Profundizar en algo es una habilidad que tienes que desarrollar si quieres destacar en tu carrera. El libro menciona una idea que me gusta: el conocimiento profundo es lo que distingue a los constructores de catedrales de los que hacen software común. Me gusta la idea de pensar en el software como una construcción y pensar que puede ser algo tan bonito y tan grande como una catedral.</p>\n\n<p>Así que ya sabes: si quieres ser un desarrollador o desarrolladora de software que es capaz de construir catedrales, cava más hondo.</p>\n",
      "date_published": "Wed, 25 Jan 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/01/22/entendiendo-el-bytecode.html",
      "url": "https://blog.thedojo.mx/2023/01/22/entendiendo-el-bytecode.html",
      "title": "¿Qué es el bytecode?",
      "content_html": "<p>Tanto para Java como para otros lenguajes que son interpretados, por ejemplo Python o JavaScript, se genera una representación intermedia como resultado de la ejecución o compilación. A este código le llamamos bytecode.</p>\n\n<p>Hablemos de qué es y para qué existe.</p>\n\n<h2 id=\"qué-es-el-bytecode\">¿Qué es el bytecode?</h2>\n\n<p>El bytecode es una representación intermedia de tu programa que tiene dos características principales:</p>\n\n<ol>\n  <li>No es tan legible como el código fuente, por ser más compacta.</li>\n  <li>Es independiente de la arquitectura de la máquina, por lo que siempre es la misma representación para tu máquina virtual.</li>\n</ol>\n\n<p>El objetivo del bytecode entonces es conservar la semántica de tu programa, pero de una forma que sea más fácil de ejecutar en una máquina virtual o el intérprete.</p>\n\n<p>Se llama <em>bytecode</em> porque normalmente es una secuencia de bytes que representan tanto las instrucciones como los datos.</p>\n\n<h2 id=\"ejemplo-de-un-bytecode\">Ejemplo de un bytecode</h2>\n\n<p>Veamos el ejemplo de Elixir y el código de bytes que produce, para entender el con un ejemplo.</p>\n\n<div class=\"language-elixir highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">defmodule</span> <span class=\"no\">Hello</span> <span class=\"k\">do</span>\n  <span class=\"k\">def</span> <span class=\"n\">greet</span> <span class=\"k\">do</span>\n    <span class=\"no\">IO</span><span class=\"o\">.</span><span class=\"n\">puts</span> <span class=\"s2\">\"Hello, world!\"</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>El proceso que Elixir sigue para ejecutarse es el siguiente:</p>\n\n<p><img src=\"https://res.cloudinary.com/hectorip/image/upload/v1674191298/58786d8c955aaa5df2ebdb5a2c2790da5216b705_bllv3i.png\" alt=\"Procesamiento de Elixir al Bytecode de BEAM\" class=\"align-center\" /></p>\n\n<p>Fuente: <a href=\"https://elixirforum.com/t/getting-each-stage-of-elixirs-compilation-all-the-way-to-the-beam-bytecode/1873/7\">Getting each stage of Elixir’s compilation all the way to the BEAM bytecode</a>.</p>\n\n<p>La <strong>Bogdan/Björn Erlang Abstract Machine</strong> (BEAM) tiene un <a href=\"http://www.cs-lab.org/historical_beam_instruction_set.html\">set de instrucciones</a>, que constituyen su bytecode. Estos aunque están semi-documentados aquí, no están documentados oficialmente y pueden cambiar en cada release.</p>\n\n<p>Cuando compilas una archivo de Elixir, se crea un archivo con el mismo nombre de tu módulo, pero con la extensión <code class=\"language-plaintext highlighter-rouge\">.beam</code>. Este archivo contiene el bytecode de tu programa. Para poder verlo en nuestro editor, necesitamos herramientas especiales. Para VSCode, podemos usar la extensión <a href=\"https://marketplace.visualstudio.com/items?itemName=Valentin.beamdasm\">BEAMdasm</a>.</p>\n\n<p>Aquí podemos ver el ejemplo de lo que genera el programa anterior:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Module:  Elixir.Hello\n\nAttributes: <span class=\"o\">[{</span>vsn, <span class=\"o\">[</span>72315C84EFAF57A23F8E5FD7551E9C5D]<span class=\"o\">}]</span>\n\nCompilation Info: <span class=\"o\">[{</span>version, 8.2.2<span class=\"o\">}</span>, <span class=\"o\">{</span>options, <span class=\"o\">[</span>no_spawn_compiler_process, from_core, no_core_prepare, no_auto_import]<span class=\"o\">}</span>, <span class=\"o\">{</span><span class=\"nb\">source</span>, /Users/hectorip/Development/elixir/hello_world/hello_world.exs<span class=\"o\">}]</span>\n\n\n//Function  Elixir.Hello:__info__/1\nlabel01:  func_info            Elixir.Hello __info__ 1\nlabel02:  select_val           X[0] label09 <span class=\"o\">[</span>attributes, label08, compile, label08, deprecated, label07, exports_md5, label06, functions, label05, macros, label07, md5, label08, module, label04, struct, label03]\nlabel03:  move                 nil X[0]\n          <span class=\"k\">return\n</span>label04:  move                 Elixir.Hello X[0]\n          <span class=\"k\">return\n</span>label05:  move                 <span class=\"o\">[{</span>greet, 0<span class=\"o\">}]</span> X[0]\n          <span class=\"k\">return\n</span>label06:  move                 7~�t�jO<span class=\"p\">;</span>_���lS\u0007 X[0]\n          <span class=\"k\">return\n</span>label07:  move                 nil X[0]\n          <span class=\"k\">return\n</span>label08:  move                 X[0] X[1]\n          move                 Elixir.Hello X[0]\n          call_ext_only        2 erlang:get_module_info/2\nlabel09:  call_only            1 label17\n\n//Function  Elixir.Hello:greet/0\nlabel10:  func_info            Elixir.Hello greet 0 //line hello_world.exs, 2\nlabel11:  move                 Hello, world! X[0]\n          call_ext_only        1 Elixir.IO:puts/1 //line hello_world.exs, 3\n\n//Function  Elixir.Hello:module_info/0\nlabel12:  func_info            Elixir.Hello module_info 0\nlabel13:  move                 Elixir.Hello X[0]\n          call_ext_only        1 erlang:get_module_info/1\n\n//Function  Elixir.Hello:module_info/1\nlabel14:  func_info            Elixir.Hello module_info 1\nlabel15:  move                 X[0] X[1]\n          move                 Elixir.Hello X[0]\n          call_ext_only        2 erlang:get_module_info/2\n\n//Function  Elixir.Hello:-inlined-__info__/1-/1\nlabel16:  func_info            Elixir.Hello <span class=\"nt\">-inlined-__info__</span>/1- 1\nlabel17:  jump                 label16\n          int_code_end\n</code></pre></div></div>\n\n<p>Como puedes ver después de las etiquetas que tienen nombres como <code class=\"language-plaintext highlighter-rouge\">label01</code>, <code class=\"language-plaintext highlighter-rouge\">label02</code>, etc., tenemos instrucciones como <code class=\"language-plaintext highlighter-rouge\">func_info</code>, <code class=\"language-plaintext highlighter-rouge\">select_val</code>, <code class=\"language-plaintext highlighter-rouge\">move</code>, <code class=\"language-plaintext highlighter-rouge\">return</code>, <code class=\"language-plaintext highlighter-rouge\">call_ext_only</code>, <code class=\"language-plaintext highlighter-rouge\">call_only</code>, <code class=\"language-plaintext highlighter-rouge\">jump</code>, <code class=\"language-plaintext highlighter-rouge\">int_code_end</code>, etc. y datos como <code class=\"language-plaintext highlighter-rouge\">Elixir.Hello</code>, <code class=\"language-plaintext highlighter-rouge\">Hello, world!</code>. Esto es lo que la maquina virtual ya puede ejecutar directamente, o se puede usar para propósitos como optimizaciones si se puede garantizar que la semántica se mantiene.</p>\n\n<h3 id=\"ejemplo-con-javascript\">Ejemplo con JavaScript</h3>\n\n<p>También podemos ver el bytecode de JavaScript. Si tienes instalado <code class=\"language-plaintext highlighter-rouge\">node</code> en tu computadora puedes correr algo como lo siguiente para ver el bytecode de JavaScript:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>node <span class=\"nt\">--print-bytecode</span> <span class=\"nt\">--eval</span> <span class=\"s2\">\"console.log('Hello, world!')\"</span>\n</code></pre></div></div>\n\n<p>Te dará un motón de código en bytes que es lo que el intérprete de JavaScript ejecuta. Para entender las partes que tiene podemos empezar por aquí: <a href=\"https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775\">Understanding V8’s Bytecode</a> y aquí <a href=\"https://dev.to/_staticvoid/node-js-under-the-hood-8-oh-the-bytecodes-1p6p\">Node.js Under the Hood #8 - Understanding Bytecodes</a></p>\n\n<p>Como puedes, en ambos casos el bytecode no es sencillo, de hecho, pero no está diseñado para que los programadores trabajemos con él.</p>\n\n<h2 id=\"resumen\">Resumen</h2>\n\n<p>El bytecode es un producto secundario e intermedio de la compilación en algunos lenguajes y entornos de ejecución. En algunos casos es directamente el objeto que la máquina virtual ejecuta y en otros se puede pensar como un caché de la ejecución que se puede usar en las ejecuciones posteriores de un programa para mejorar el rendimiento.</p>\n\n<p>A veces se puede usar el bytecode con otros propósitos, por ejemplo, para hacer optimizaciones en tiempo de ejecución, que es lo que hacen los compiladores bajo de demanda o JIt’s.</p>\n\n<p>Este pequeño artículo tiene el objetivo de que por lo menos veas físicamente lo que muchas veces se menciona como producto de la compilación o interpretación de un programa, pero que no se explica qué es en la mayoría de los casos.</p>\n",
      "date_published": "Sun, 22 Jan 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/01/18/compilacion-just-in-time-que-es.html",
      "url": "https://blog.thedojo.mx/2023/01/18/compilacion-just-in-time-que-es.html",
      "title": "Qué es la compilación Just In Time (JIT)",
      "content_html": "<p>Los lenguajes de programación y los compiladores son de las cosas más interesantes en el desarrollo   de software. Hace tiempo ha empezado a sonar más un término: <strong>JIT</strong> o compilación <strong>Just In Time</strong>, ya que varios lenguajes lo han integrado a sus entornos de ejecución, aquí la llamaremos “compilación bajo demanda” (gracias a Manuel Rubio por la sugerencia). Durante el artículo entenderás por qué creemos que esta traducción es adecuada.</p>\n\n<p>Este tipo de compilación es poco entendida, por eso en este artículo hablaremos de por qué es algo tan usado. Primero empecemos hablando de la compilación en general y después entendamos este <strong><em>tipo especial de ejecución</em></strong>. Pero empecemos desde las bases.</p>\n\n<h2 id=\"qué-es-compilar\">¿Qué es compilar?</h2>\n\n<p>Compilar es <strong>traducir de un lenguaje a otro</strong>. Lo que entendemos como lenguajes compilados generalmente son lenguajes que se  traducen de un lenguaje de programación a un lenguaje de máquina, es decir, a código binario que puede ser ejecutado por un procesador en algunos casos o a código para una máquina virtual (aquí a veces se llama <em>código de bytes</em> o <em>bytecode</em>).</p>\n\n<p>A veces usamos el término <em>“transpilación”</em> (<em>transpilation</em> en inglés), que se entiende como una forma de traducir o transformar de un lenguaje entendido por los humanos a otro del mismo nivel. Por ejemplo de TypeScript a JavaScript. Esto no es más que otra forma de compilación. Hablemos de cómo surgió la compilación.</p>\n\n<h3 id=\"historia-de-la-compilación\">Historia de la compilación</h3>\n\n<p>En el capítulo 9 del libro <a href=\"https://altenwald.com/historia-de-los-lenguajes-de-programacion\">“Historia de los lenguajes de programación”</a> de <a href=\"https://mobile.twoitter.com/mronerlang\">Manuel Rubio</a>, se nos cuenta cómo la compilación nació. Al principio los programadores escribían todo lo que su programa necesitaba desde cero. Una programadora muy experimentada y que estuvo desde los comienzos de la programación, <strong>Grace Hopper</strong>, empezó a juntar código que hacía tareas que se repetían vez tras vez y simplemente lo insertaba donde necesitaba esa tarea.</p>\n\n<p>Después, se dio cuenta que podía hacer un programa que hiciera lo mismo que ella hacía manualmente, pero que lo hiciera de manera más rápida y eficiente. Así nació el primer compilador” <a href=\"https://www.computinghistory.org.uk/det/5487/Grace-Hopper-completes-the-A-0-Compiler/\"><strong>el A-0</strong></a>.</p>\n\n<p>Se llama <strong>compilador</strong> (Hopper acuñó el término) y no “traductor” porque más allá de simplemente pasar de un lenguaje a otro, junta (compila) todas las piezas de código invocadas en el programa original y las pone en el programa resultante. El programa original para el A-0 consistía en códigos numéricos que indicaban la subrutina a usar seguidos de los datos a introducir en cada una.</p>\n\n<p>Es interesante pensar que cuando <strong>Grace</strong> tuvo la idea de crear un programa que hiciera esto, muchos se opusieron diciendo que no era posible que una computadora se programara a sí misma y que aunque lo hiciera, los programas nunca iban a ser tan buenos como los que podía hacer un programador humano.</p>\n\n<p>A partir de ahí, se fueron creando compiladores más avanzados y la comunidad al poco tiempo se dio cuenta de que el ahorro de tiempo era muy conveniente para todos, aunque con una pequeña penalización en el desempeño del programa final.</p>\n\n<h3 id=\"compilación-por-adelantado\">Compilación por adelantado</h3>\n\n<p>La compilación tradicional, conocida en inglés como <em>“ahead of time”</em> (AOT), que en español la llamaríamos <strong>“compilación adelantada”</strong>, es la que se ha usado desde el principio de la programación. En este tipo compilación, el código fuente se traduce a código final que se ejecutará por un CPU o por una máquina virtual. El código puede ser el código binario o bytecode.</p>\n\n<p>Gran parte de lo que hacen los compiladores actuales hacen a parte de traducir es optimizar el código, con el objetivo de que el programa sea lo más eficiente posible en ejecución.</p>\n\n<h2 id=\"compilación-just-in-time-jit\">Compilación “Just in Time” (JIT)</h2>\n\n<p>La compilación “Just in time”, que significa literalmente “justo a tiempo” (en español me gustaría llamarla compilación bajo demanda), más que un proceso de traducción se trata de <strong>optimización</strong>.</p>\n\n<p>Esta compilación sucede solamente en lenguajes que usan una representación intermedia antes de que el procesador los ejecute. Esta representación intermedia normalmente es un <a href=\"https://www.techopedia.com/definition/3760/bytecode\">bytecode</a>. El bytecode puede ser ejecutado por una máquina virtual o intérprete. El compilador JIT transforma este bytecode en código máquina directamente para acelerar su ejecución.</p>\n\n<h3 id=\"funcionamiento-de-un-compilador-bajo-demanda\">Funcionamiento de un compilador bajo demanda</h3>\n\n<p>Para optimizar la ejecución mientras está sucediendo el compilador JIT tiene que hacer por lo menos tres cosas:</p>\n\n<ol>\n  <li>\n    <p><strong>Observar</strong> la ejecución y el código para <em>identificar</em> partes que se beneficiarían de compilar su código a código máquina. Por ejemplo, código que se ejecuta muchas veces o que se lleva la mayor parte del tiempo de ejecución. A esta etapa se le llama <em>profiling</em>.</p>\n  </li>\n  <li>\n    <p><strong>Compilar el bytecode</strong> en código máquina y <em>optimizarlo</em>.</p>\n  </li>\n  <li>\n    <p>Como puede que esta compilación no sea tan buena como el bytecode original, el compilador debe <strong>regresar</strong> el bytecode original si la ejecución no mejora.</p>\n  </li>\n</ol>\n\n<h2 id=\"ejemplo-con-v8\">Ejemplo con V8</h2>\n\n<p>El motor de JavaScript V8 creado por Google, es un ejemplo brillante del uso de compilación bajo demanda.</p>\n\n<p>En el artículo <a href=\"/2020/05/17/que-es-un-engine-de-javascript.html\">“Qué es un Engine de JavaScript”</a> explicamos el funcionamiento con más detalle. Pero en este diagrama puedes ver las partes principales:</p>\n\n<p><img src=\"https://res.cloudinary.com/hectorip/image/upload/v1589700777/1_ZIH_wjqDfZn6NRKsDi9mvA_wc08nl.png\" alt=\"diagrama de funcionamiento de V8\" class=\"align-center\" /></p>\n\n<p>Después de la lectura del código fuente y la transformación en una estructura que ya puede ser ejecutada (el Abstract Syntax Tree), el código se ejecuta en el intérprete.</p>\n\n<p>El intérprete, llamado <strong>Ignition</strong> genera además el bytecode que más adelante será compilado por el compilador <strong>TurboFan</strong> en caso de que sea conveniente. TurboFan recibe las métricas de uso del bytecode (recogidas por Ignition), es decir, los resultados del profiling y basado en eso decide qué compilará a código máquina. Después de compilarlo y observar su funcionamiento (si mejoró la velocidad y se mantuvo la estabilidad) del código, V8 decide si lo mantiene o si regresa al bytecode original. Esta es la línea roja que vemos en el diagrama, cuando algo se “des-optimiza”.</p>\n\n<p>Y esto es básicamente el funcionamiento de un compilador bajo demanda. La observación del código en acción y la mejora en el mismo momento.</p>\n\n<h2 id=\"otros-lenguajes-que-la-usan\">Otros lenguajes que la usan</h2>\n\n<p>Las primeras instancias de compilación bajo demanda (también llamada compilación dinámica) se vieron desde los años 60, en Lisp y más adelante con Smalltalk y Self. En este documento puedes ver una historia corta de la compilación bajo demanda y los lenguajes que lo han usado: <a href=\"http://eecs.ucf.edu/~dcm/Teaching/COT4810-Spring2011/Literature/JustInTimeCompilation.pdf\">A Brief History of Just-In-Time</a></p>\n\n<p>El lenguaje que popularizó el término JIT fue Java con su máquina virtual <a href=\"https://www.oracle.com/java/technologies/whitepaper.html\">HotSpot</a> creada en Sun Microsystems y ahora poseída por Oracle. Esta máquina virtual se caracterizó por el desempeño que logra. <a href=\"https://dblp.org/pid/30/2083.html\">Lars Bak</a> participó en el desaarrollo de HotSpot, V8 y recientemente en el de la máquina virtual de <a href=\"https://dart.dev/\">Dart</a>. Como te puedes imaginar, Dart también usa compilación bajo demanda. <a href=\"https://luajit.org/luajit.html\">Lua</a> también tie su compilador JIT. Y finalmente, <a href=\"https://www.telerik.com/blogs/understanding-net-just-in-time-compilation\">C#</a>, al ser un competidor directo de Java, tiene usar JIT para ser por lo menos tan rápido como su este.</p>\n\n<p>Los lenguajes que recientemente han agregado JIT a su máquina virtual o intérprete son:</p>\n\n<ul>\n  <li>Ruby con <a href=\"https://www.infoworld.com/article/3647999/ruby-31-arrives-with-new-jit-compiler.html\">YJIT</a></li>\n  <li>PHP desde su versión 8: <a href=\"https://php.watch/versions/8.0/JIT\">PHP 8.0</a></li>\n  <li>Erlang desde su versión 24: <a href=\"https://www.erlang.org/blog/a-first-look-at-the-jit/\">Erlang 24</a></li>\n</ul>\n\n<p>Como puedes ver, tanto lenguajes compilados como interpretados usan JIT. El único requisito es que el lenguaje utilice un código intermedio.</p>\n\n<h2 id=\"desventajas\">Desventajas</h2>\n\n<p>Como te imaginarás, no todo es miel sobre hojuelas. La compilación bajo demanda tiene algunas desventajas:</p>\n\n<ul>\n  <li>\n    <p>Al ser un proceso de compilación dinámica, abre la puerta a algunas vulnerabilidades de seguridad, por ejemplo el <a href=\"https://conference.hitb.org/hitbsecconf2010ams/materials/D1T2%20-%20Alexey%20Sintsov%20-%20JIT%20Spray%20Attacks%20and%20Advanced%20Shellcode.pdf\">JIT Spraying</a></p>\n  </li>\n  <li>\n    <p>El compilador JIT compite con el intérprete por el uso de la CPU. Esto puede afectar el rendimiento del programa.</p>\n  </li>\n  <li>\n    <p>El consumo de recursos en general es mayor.</p>\n  </li>\n  <li>\n    <p>Puede que la forma en la que está hecha tu programa no se beneficie en absoluto de la compilación bajo demanda, por lo que incluso a veces es posible apagarlos.</p>\n  </li>\n</ul>\n\n<p>Si estás en un entorno en el que algo de esto sea muy importante, considera si el entorno en el que estás trabajando puede dessactivarse el JIT. V8, por ejemplo, puede funcionar sin JIT: <a href=\"https://v8.dev/blog/jitless\">JIT-less V8</a>.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>La compilación bajo demanda ha sido un gran avance en el desarrollo de software, y es un trabajo de ingeniería muy interesante.</p>\n\n<p>Permite que la ejecución de nuestros programas sea más eficiente y rápida.  Además, a mi punto de ver, es una maravilla de la ingeniería de software. Si quieres aprender más: puedes visitar el <a href=\"https://v8.dev/\">sitio oficial de V8</a>, en el que explican muchas cosas acerca del desarrollo de este sistema pionero en compilación bajo demanda.</p>\n\n<p>También puedes ver como funciona un compilador por adelantado todavía más antiguo y muy interesante: <a href=\"https://developers.redhat.com/articles/2021/06/23/how-jit-compiler-boosts-java-performance-openjdk#deoptimization_and_speculation\">Java HotSpot VM</a>.</p>\n",
      "date_published": "Wed, 18 Jan 2023 00:00:00 -0600"
      }
    
  ]
}
       <div style="border: 1px solid gray; border-radius: 4px; margin: 20px; padding: 5px;">
          Visita nuestro canal de YouTube para encontrar temas similares en video:<a href="https://youtube.com/thedojomx"> The Dojo MX en YouTube </a>
        </div>

        
      </section>

      <footer class="page__meta">
        
        


        


      </footer>

      

      
    </div>

    
  </article>

  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        
<script>
    var sharect = new Sharect();
    sharect.config({
    //   facebook: true,
      twitter: true,
      twitterUsername: '@thedojomx',
      backgroundColor: '#ff4081',
      iconColor: '#fff'
    }).init();

</script>
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Seguir:</strong></li>
    

    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2023 The Dojo MX Blog. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <script>
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-127437335-2']);
  
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>









  </body>
</html>
