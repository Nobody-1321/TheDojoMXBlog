<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="es" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>The Dojo MX Blog</title>
<meta name="description" content="">


  <meta name="author" content="Héctor Patricio">
  


<meta property="og:type" content="website">
<meta property="og:locale" content="es">
<meta property="og:site_name" content="The Dojo MX Blog">
<meta property="og:title" content="The Dojo MX Blog">
<meta property="og:url" content="https://blog.thedojo.mx/feed.json">













<link rel="canonical" href="https://blog.thedojo.mx/feed.json">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": null,
      "url": "https://blog.thedojo.mx/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="The Dojo MX Blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    
<!-- favicon -->
<link rel="apple-touch-icon" sizes="180x180" href="/assets/images/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicons/favicon-16x16.png">
<link rel="manifest" href="/assets/images/favicons/site.webmanifest">
<link rel="mask-icon" href="/assets/images/favicons/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="/assets/images/favicons/favicon.ico">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/assets/images/favicons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">
<!-- end favicon -->
<!-- for mathjax support -->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZNSYMJDY5S"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-ZNSYMJDY5S');
</script>

<!-- Hotjar Tracking Code for blog.thedojo.mx -->
<script>
    (function(h,o,t,j,a,r){
        h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
        h._hjSettings={hjid:1217463,hjsv:6};
        a=o.getElementsByTagName('head')[0];
        r=o.createElement('script');r.async=1;
        r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
        a.appendChild(r);
    })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');
</script>

<script src="/assets/js/sharect.min.js"></script>

<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "url": "https://blog.thedojo.mx/feed.json",
      "name": null,
      "headline": null,
      "keywords": "",
      "description": "",
      "articleBody": "{\n  \"version\": \"https://jsonfeed.org/version/1\",\n  \"title\": {{ site.title | jsonify }},\n  \"description\": {% if site.description %}{{ site.description | jsonify }}{% endif %},\n  \"home_page_url\": \"{{ site.url }}\",\n  \"feed_url\": \"{{ site.url }}/feed.json\",\n  \"favicon\": \"{{ site.url}}/favicon.png\",\n  {% if site.author %}\n  \"author\": {\n    \"name\": {{ site.author | jsonify }}\n  },\n  {% endif %}\n  \"items\": [\n    \n    {% for post in site.posts limit:10 %}\n    {\n      \"id\": \"{{ post.url | prepend: site.baseurl | prepend: site.url }}\",\n      \"url\": \"{{ post.url | prepend: site.baseurl | prepend: site.url }}\",\n      \"title\": {{ post.title | jsonify }},\n      \"content_html\": {{ post.content | jsonify  }},\n      \"date_published\": \"{{ post.date | date_to_rfc822 }}\"\n      }{% unless forloop.last %},{% endunless %}\n    {% endfor %}\n  ]\n}",
      "datePublished": null,
      "dateModified": null,
      "author": {
        "@type": "Person",
        "name": null,
        "givenName": null,
        "email": null
      },
      "publisher": {
        "@type": "Organization",
        "name": "The Dojo MX Blog",
        "url": "https://blog.thedojo.mx",
        "logo": {
          "@type": "ImageObject",
          "width": 32,
          "height": 32,
          "url": "https://blog.thedojo.mx/icon/favicon.ico"
        }
      },
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://blog.thedojo.mx/feed.json"
      },
      "image": {
        "@type": "ImageObject",
        "width": 1200,
        "height": 400,
        "url": ""
      }
    }
</script>



  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="https://res.cloudinary.com/hectorip/image/upload/v1554098427/TheDojo/the-dojo-transparent.png" alt="The Dojo MX Blog"></a>
        
        <a class="site-title" href="/">
          The Dojo MX Blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/latest">Todos los posts</a>
            </li><li class="masthead__menu-item">
              <a href="/about">Acerca de</a>
            </li><li class="masthead__menu-item">
              <a href="https://thedojo.mx">Cursos</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  


  <article class="page h-entry" itemscope itemtype="https://schema.org/CreativeWork">
    
    
    
    

    <div class="page__inner-wrap">
      
        <header>
          
          

        </header>
      

      <section class="page__content e-content" itemprop="text">
        
        <div style="border: 1px solid gray; border-radius: 4px; margin: 20px; padding: 5px;">
          Visita nuestro canal de YouTube para encontrar temas similares en video:<a href="https://youtube.com/thedojomx"> The Dojo MX en YouTube </a>

        </div>
        {
  "version": "https://jsonfeed.org/version/1",
  "title": "The Dojo MX Blog",
  "description": ,
  "home_page_url": "https://blog.thedojo.mx",
  "feed_url": "https://blog.thedojo.mx/feed.json",
  "favicon": "https://blog.thedojo.mx/favicon.png",
  
  "author": {
    "name": {"name":"Héctor Patricio","avatar":"/assets/images/me.jpg","bio":"Desarrollador de software, tech lead @ HAL y The Dojo MX","uri":"https://github.com/hectorip","home":"https://til.hectorip.com/"}
  },
  
  "items": [
    
    
    {
      "id": "https://blog.thedojo.mx/2023/06/17/son-aplicables-y-practicos-los-principios-solid.html",
      "url": "https://blog.thedojo.mx/2023/06/17/son-aplicables-y-practicos-los-principios-solid.html",
      "title": "¿Son aplicables y prácticos los principios SOLID?",
      "content_html": "<p>Los <strong>principios SOLID</strong>, se enseñan como verdades incuestionables sobre el buen desarrollo de software. Aunque, justo por la educación, antes era completamente partidario de estos, con el tiempo me fui dando cuenta de varias de las fallas que presentan.</p>\n\n<p>En este artículo te voy a hablar de las fallas generales como conjunto, pero también es un índice para una serie de artículos que escribí sobre cada uno de ellos, analizándolo a profundidad.</p>\n\n<h2 id=\"ambigüedad\">Ambigüedad</h2>\n\n<p>Cuando buscas la explicación sobre cómo aplicar alguno de estos principios, normalmente encuentras muchas explicaciones diferentes. Algunas de estas explicaciones se contraponen, siguen siendo ambiguas, o de plano no se entienden.</p>\n\n<p>Con el principio que más pasa es con el “Single Responsibility” (SRP), en el cuál diferentes personas no nos ponemos de acuerdo respecto a lo que una “Responsabilidad” significa. Pero también pasa con la aplicación de los demás principios a diferentes entornos de programación.</p>\n\n<h2 id=\"complican-exageradamente-el-código\">Complican exageradamente el código</h2>\n\n<p>La aplicación sin razonamiento profundo de estos principios puede complicar el código de manera exagerada, sobre todo en lenguajes inflexibles o con sistemas de tipos complicados (sí, te estoy viendo a ti, <strong>Java</strong>), que justo es donde más se aplica.</p>\n\n<p>El ejemplo más claro de esto es el “Dependency Inversion Principle”, que te lleva a hacer cosas bastante raras en el código para lograrlo, como ya dije, sobre todo cuando el sistema de tipos te lo complica.</p>\n\n<p>Y aunque es cierto que a veces es necesario y bastante útil hacer lo que este principio propone, para mi el 80% del software no lo necesita y sólo estás haciendo una sobre-ingeniería que no se justifica.</p>\n\n<h2 id=\"se-usan-como-un-código-moral\">Se usan como un código moral</h2>\n\n<p>Los principios SOLID, entre otras cosas, normalmente se usan para avergonzar a las personas que no los conocen o no los aplican. Normalmente hablan de tu valía como desarrollador@ de software basado en el supuesto conocimiento de cosas como estas, y otros principio o reglas (completamente) arbitrarias, sobre todo basadas en el libro Clean Code.</p>\n\n<p>Esta revoltura de principios morales y conveniencia técnica es un <strong>gran error para la comunidad de software</strong>, ya que lleva a la sobre-ingeniería, a la aplicación ciega de principios y técnicas que no tienen sentido en tu caso particular e incluso al desprecio del trabajo de otros programadores.</p>\n\n<p>Para mi, este es el punto más grave, tal vez no directamente de los principios SOLID, sino de la forma en la que se enseñan.</p>\n\n<h2 id=\"análisis-más-profundo\">Análisis más profundo</h2>\n\n<p>En este blog hemos escrito 5 artículos analizando cada uno de los principios que lo componen, viendo si conviene aplicarlos y describiendo alternativas. En la mayoría de los casos incluso hablamos de principios más profundos (lo que nos hace ver que los “principios SOLID” debería ser algo como “reglas SOLID”).</p>\n\n<p>Aquí los puedes ver:</p>\n\n<ul>\n  <li>SRP: <a href=\"/2022/12/01/analisis-de-los-principios-solid-principio-de-responsabilidad-unica.html\">Análisis de los Principios SOLID: Principio de Responsabilidad Única</a></li>\n  <li>OCP: <a href=\"/2022/12/03/el-principio-abierto-cerrado-open-closed.html\">El Principio Abierto/Cerrado</a></li>\n  <li>LSP: <a href=\"/2023/03/06/el-principio-de-substitucion-de-liskov.html\">El Principio de Sustitución de Liskov</a></li>\n  <li>ISP: <a href=\"/2023/04/01/el-principio-de-segregacion-de-interfaces.html\">El Principio de Segregación de Interfaces</a></li>\n  <li>DIP: <a href=\"/2023/04/22/el-principio-de-inversion-de-dependencias.html\">El Principio de Inversión de Dependencias</a></li>\n</ul>\n\n<p>Espero que estos artículos te sirvan para analizar más profundamente lo que todos enseñan como dogmas que se deben de seguir al pie de la letra, bajo la amenaza de no ser un buen programador o programadora que se irá al infierno de los desarrolladores si no lo sigue.</p>\n",
      "date_published": "Sat, 17 Jun 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/06/15/libros-que-todo-desarrollador-de-software-deberia-leer-desarrollo-de-carrera.html",
      "url": "https://blog.thedojo.mx/2023/06/15/libros-que-todo-desarrollador-de-software-deberia-leer-desarrollo-de-carrera.html",
      "title": "Libros que todo desarrollador de software debería leer: desarrollo de carrera",
      "content_html": "<p>En este artículo vamos a hablar de los libros que te pueden ayudar a avanzar en tu carrera como desarrollador de software, que desde mi punto de vista, son esenciales.</p>\n\n<p>Algunos desarrolladores piensan que basta simplemente con aprender a programar o diseñar software bien, pero lo cierto es que también hay que tener otras habilidades y conocimientos para que tu carrera avance a buen ritmo, y llegues a puestos de liderazgo si así lo deseas.</p>\n\n<p>En este post hablaremos de tres tipos de libros:</p>\n\n<ul>\n  <li>Consejos de carrera para desarrolladores y habilidades blandas</li>\n  <li>Libros de historia de la computación</li>\n  <li>Temas que te pueden ayudar a desarrollar habilidades de soporte</li>\n</ul>\n\n<p>Como siempre, si tienes alguna recomendación, puedes dejarla en los comentarios. Empecemos.</p>\n\n<h2 id=\"desarrollo-de-carrera\">Desarrollo de carrera</h2>\n\n<p>En estos libros verás consejos específicos de desarrolladores experimentados sobre la carrera de programador, qué habilidades y actitudes te conviene desarrollar.</p>\n\n<h3 id=\"the-pragmatic-programmer--david-thomas--andrew-hunt\">The Pragmatic Programmer | David Thomas &amp; Andrew Hunt</h3>\n\n<p><a href=\"https://pragprog.com/titles/tpp20/the-pragmatic-programmer-20th-anniversary-edition/\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686286553/71f743sOPoL._AC_UF1000_1000_QL80__vibioc.jpg\" alt=\"Portada de The Pragmatic Programmer\" class=\"align-center\" /></a></p>\n\n<p>Este es uno de los mejores libros sobre la carrera como programador, que te da consejos de dos programadores <strong>muy muy experimentados</strong>. Su tema principal es el <strong>pragmatismo</strong>, que es una filosofía que te dice que no hay una sola forma de hacer las cosas, sino que debes adaptarte a las circunstancias y hacer lo que sea necesario para lograr tus objetivos. Otra forma de ver el pragmatismo es que hay que ser práctico, y no darle tantas vueltas a las cosas.</p>\n\n<p>A grandes rasgos trata estos temas:</p>\n\n<ol>\n  <li>Introducción a la filosofía pragmática</li>\n  <li>Cómo ser pragmático al desarrollar software (nota que no es al <em>programar</em>, sino al crear programas)</li>\n  <li>Herramientas que te pueden servir para desarrollar buen software</li>\n  <li>Cómo llevar un proyecto pragmáticamente</li>\n</ol>\n\n<p>Estaba en la duda de clasificarlo entre los libros de desarrollo de software o desarrollo de carrera, porque aunque habla sobre técnicas específicas y temas técnicos, su espíritu es una meta-habilidad o una actitud hacia el desarrollo y hacia la vida: el pragmatismo.</p>\n\n<p>Puedes comprarlo aquí: <a href=\"https://amzn.to/3oXvmNk\" target=\"_blank\" rel=\"noopener\">The Pragmatic Programmer</a>.</p>\n\n<h3 id=\"the-practice-of-programming--brian-w-kernighan--rob-pike\">The Practice of Programming | Brian W. Kernighan &amp; Rob Pike</h3>\n\n<p><a href=\"https://www.goodreads.com/book/show/1032758.The_Practice_of_Programming\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686488400/71a9H3K9cgL._AC_UF1000_1000_QL80__af2e79.jpg\" alt=\"Portada de The Practice of Programming\" class=\"align-center\" /></a></p>\n\n<p>Brian W. Kernighan es un desarrollador de software, programador y científico de la computación de las grandes ligas. ¿Has escuchado sobre <code class=\"language-plaintext highlighter-rouge\">AWK</code>? Es un programa y lenguaje programación legendario, y se llama así por sus creadores: Alfred Aho, Peter Weinberger y <strong>Brian Kernighan</strong>.</p>\n\n<p><strong>Rob Pike</strong> es uno de los co-creadores del lenguaje de programación Go, y también es un desarrollador de software con mucha experiencia. Ha co-creado otros lenguajes de programación, como Oberon.</p>\n\n<p>En <strong>“The Practice of Programming”</strong> explican todas las prácticas que un desarrollador de software debe tener o aprender para desarrollar software exitosamente. Este libro se guía por los siguientes principios:</p>\n\n<ol>\n  <li>Simplicidad</li>\n  <li>Claridad</li>\n  <li>Generalidad</li>\n  <li>Automatización</li>\n</ol>\n\n<p>Estos principios son aplicados a cosas como el estilo, la documentación, las pruebas, etc. Al igual que el libro anterior, estaba dudando en clasificarlo como libro de desarrollo de software, pero creo que el enfoque general, aunque muy técnico, va más enfocado en el desarrollo de una mentalidad conveniente.</p>\n\n<p>Puedes comprarlo aquí: <a href=\"https://amzn.to/42zssMz\" target=\"_blank\" rel=\"noopener\">The Practice of Programming</a>.</p>\n\n<h3 id=\"code-ahead--yegor-bugayenko\">Code Ahead | Yegor Bugayenko</h3>\n\n<p><a href=\"https://www.yegor256.com/code-ahead.html\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686348326/yegor_code_kislix.png\" alt=\"Portada de Code Ahead\" class=\"align-center\" /></a></p>\n\n<p><strong>Yegor Bugayenko</strong> es un autor poco conocido de este lado del mundo, pero en Rusia es más famoso. Ha escrito varios libros sobre programación como <strong>“Elegant Objects”</strong> (1 y 2). Pero también escribió este libro sobre la carrera de programador, que es muy bueno.</p>\n\n<p>Yo lo describiría como una <em>visión cínica de la carrera de programación</em>, con algunas recomendaciones sobre actitudes, formas de trabajo y <strong>tácticas para progresar en tu carrera</strong>. No creo que se deba tomar como una guía, sino más bien como un contrapeso a las opiniones de carrera más tradicionales, para ampliar tu visión. Además sí creo que dice algunas verdades incómodas que no a todos les gustará escuchar.</p>\n\n<p>El punto débil de libro es su formato (que para mi falló completamente), en el que trató de hacer un historia de ficción (supongo que al estilo de The Phoenix Project), pero que en realidad sólo consiste en una serie de explicaciones del protagonista.</p>\n\n<p>A pesar de lo mencionado anteriormente, creo que es un libro que vale mucho la pena leer y que te puede ayudar a ver las cosas desde otra perspectiva.</p>\n\n<p>Puedes comprarlo en Amazon: <a href=\"https://amzn.to/43Dm0FK\" target=\"_blank\" rel=\"noopener\">Code Ahead</a></p>\n\n<h3 id=\"the-phoenix-project--gene-kim-kevin-behr--george-spafford\">The Phoenix Project | Gene Kim, Kevin Behr &amp; George Spafford</h3>\n\n<p><a href=\"https://itrevolution.com/product/the-phoenix-project/\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686458596/TPP_3rd_cover_border-664x998.jpg_ohgr0o.webp\" alt=\"Portada de The Phoenix Project\" class=\"align-center\" /></a></p>\n\n<p>Este libro, a diferencia del anterior es una novela que sí salió bien, en la que describe la progresión de alguien del área de IT que obligadamente se convierte en líder del área. Describe como es que las áreas de IT se convierten de cuellos de botella en partes que agregan valor a la empresa.</p>\n\n<p>El libro da los fundamentos de DevOps, y cuáles son los principios que todos los equipos de desarrollo de software deberían seguir para producir software más efectivamente.</p>\n\n<p>Aunque está enfocado en la operación y la entrega del software, a final de cuentas, es donde todos queremos que nuestro software llegue, así que todos los desarrolladores de software se pueden beneficiar de los principios que presenta.</p>\n\n<p>Se ha convertido en un clásico, y con justa razón. Lo puedes comprar aquí: <a href=\"https://amzn.to/3WWWMQ1\" target=\"_blank\" rel=\"noopener\">The Phoenix Project</a>.</p>\n\n<h2 id=\"libros-de-historia-de-la-informática\">Libros de historia de la informática</h2>\n\n<p>En esta sección recomendaremos algunos libros que creemos que te pueden ayudar a conocer más la historia de tu campo y que por lo tanto te ayudarán a <em>aprender de lo que ya se ha hecho</em>. Esto te ayudará a no cometer los mismos errores y más mejor, <strong>“pararte en hombros de gigantes”</strong> para poder ver más lejos.</p>\n\n<p>Afortunadamente, de estos tenemos tanto libros en inglés como en español.</p>\n\n<h3 id=\"historia-de-los-lenguajes-de-programación-años-1940-1959--manuel-rubio\">Historia de los lenguajes de programación: Años 1940-1959 | Manuel Rubio</h3>\n\n<p><a href=\"https://altenwald.com/book/histlangprog\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686489306/Screen_Shot_2023-06-11_at_7.14.50_g1d4lh.png\" alt=\"Portada de Historia de los lenguajes de programación\" class=\"align-center\" /></a></p>\n\n<p>Aquí, <a href=\"https://altenwald.com/\">Manuel Rubio</a> explica el nacimiento de las lenguajes de programación y cómo esto va de la mano con la historia de la computación. Me gusta mucho de este libro que te da una visión más amplia que la centra en US que normalmente nos dan en la escuela y en la mayoría de los libros de computación.</p>\n\n<p>Manuel hizo una investigación muy amplia, cuestiona algunas cosas implícitamente (<em>¿de verdad fue Ada Lovelace la primera programadora?</em>) y te da una visión más amplia de lo que significa la computación.</p>\n\n<p>Me gusta mucho que resalta algunas cosas que nos siguen sucediendo hoy:</p>\n\n<ul>\n  <li>Nos cuesta naturalmente despegarnos del trabajo</li>\n  <li>El campo siempre se ha resistido a las innovaciones</li>\n  <li>Siempre creemos que lo que viene después de lo que ya sabemos tiene menos valor</li>\n</ul>\n\n<p>En el blog hicimos ya un <a href=\"/2022/06/11/resumen-historia-de-los-lenguajes-de-programacion.html\" target=\"_blank\" rel=\"noopener\">resumen de este libro</a> y también hicimos un <a href=\"https://youtu.be/JDDEOi1jwDA\">resumen en video</a> pero sinceramente te recomiendo leerlo completo.</p>\n\n<p>Lo puedes comprar aquí: <a href=\"https://altenwald.com/book/histlangprog\" target=\"_blank\" rel=\"noopener\">Historia de los lenguajes de programación</a>. Si <em>necesitas</em> un descuento para comprarlo, no dudes en contactarme o contactar a Manuel, que es muy accesible y una gran persona.</p>\n\n<h3 id=\"mentes-geniales--camilo-chacón-sartori\">Mentes Geniales | Camilo Chacón Sartori</h3>\n\n<p><a href=\"https://www.amazon.com.mx/Mentes-geniales-ingenier%C3%ADa-software-ingenieros/dp/6077074797\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686488396/978607538877_xfcfmk.jpg\" alt=\"Portada de Mentes Geniales\" class=\"align-center\" /></a></p>\n\n<p><a href=\"https://camilochs.github.io/web/\">Camilo Chacón Sartori</a> es un gran desarrollador de software, pronto Doctor en Ciencias de la computación y escritor. Ha escrito varios libros de programación o temas relacionados y en realidad es un escritor (y lector, ¿se puede ser buen escritor sin leer mucho?) muy prolífico.</p>\n\n<p>En este libro, habla de 12 personas que han contribuido de diferentes formas al desarrollo de la computación y se les ha reconocido con el <strong>Premio Turing</strong>. Aunque no es un libro histórico en todo el sentido de la palabra, además de que no sigue una cronología, sí habla de importantes eventos históricos de la computación y desarrollo.</p>\n\n<p>Lo recomiendo porque no sólamente te habla de los logros de las personas que menciona, analiza su entorno, te cuenta sobre su personalidad y extrae lecciones. Además, te deja las fuentes y referencias por si quieres leer más de ellos.</p>\n\n<p>Algunos de los personajes que a mi me impactaron:</p>\n\n<ul>\n  <li><strong>Manuel Blum</strong> - El creador de CAPTCHA</li>\n  <li><strong>Michael Stonebraker</strong> - El creador de PostgreSQL</li>\n  <li><strong>Barbara Liskov</strong> - Una gran proponente de los tipos abstractos de datos</li>\n  <li><strong>Leslie Lamport</strong> - Un gran matemático que ha contribuido a la computación con cosas como el algoritmo de Paxos y TLA+</li>\n  <li><strong>Richard Manning Karp</strong> - Un matemático que ha contribuido a la computación con cosas como el algoritmo de Karp-Rabin y el análisis de complejidad de algoritmos</li>\n</ul>\n\n<p>Sin duda te llevarás muchas buenas lecciones y aprendizajes sobre el desarrollo de la computación de este libro. Lo puedes comprar aquí: <a href=\"https://amzn.to/43J2jfG\" target=\"_blank\" rel=\"noopener\">Mentes Geniales</a>.</p>\n\n<h3 id=\"dealers-of-lightning-xerox-parc-and-the-dawn-of-the-computer-ag--michael-a-hiltzik\">Dealers of Lightning: Xerox PARC and the Dawn of the Computer Ag | Michael A. Hiltzik</h3>\n\n<p><a href=\"https://www.goodreads.com/book/show/1101290.Dealers_of_Lightning\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686549204/61pJVqUUoJL._AC_UF1000_1000_QL80__gevadr.jpg\" alt=\"Portada de Dealers of Lightning\" class=\"align-center\" /></a></p>\n\n<p>En los años 70 y 80’s, la compañía <strong>Xerox</strong> (sí, la de las impresoras), consiguió un equipo de personas muy hábiles con la tecnología. Eran conocidos como el <strong>PARC</strong> (Palo Alto Research Center) y fueron los creadores de muchas de las tecnologías que hoy usamos, como:</p>\n\n<ul>\n  <li>La primera computadora personal</li>\n  <li>La interfaz gráfica</li>\n  <li>La impresora láser</li>\n</ul>\n\n<p>Todas estas tecnologías cambiaron el mundo, ayudando a crear la tecnología que hoy en día nos da trabajo y ha moldeado todas las industrias y la vida en general.</p>\n\n<p>Este libro está basado en entrevistas con las personas que vieron de cerca estas creaciones y que muestran cómo es que Xerox nunca vio el potencial de las creaciones de este equipo de ingenieros. Si quieres aprender sobre la historia de la tecnología que tenemos hoy, ver cómo se forman equipos de altísimo rendimiento y aumentar tus posibilidades de crear algo que sea digno de mención, este libro es un gran recurso.</p>\n\n<p>Puedes comprarlo aquí: <a href=\"https://amzn.to/3Cs5QTm\" target=\"_blank\" rel=\"noopener\">Dealers of Lightning</a>.</p>\n\n<h3 id=\"la-catedral-de-turing--george-dyson\">La Catedral de Turing | George Dyson</h3>\n\n<p><a href=\"https://books.google.com.mx/books/about/La_catedral_de_Turing.html?id=QvjeBQAAQBAJ&amp;redir_esc=y\" target=\"_blank\" rel=\"noopener\"><img src=\"\" alt=\"Portada de La Catedral de Turing\" class=\"align-center\" /></a></p>\n\n<p>En este libro se narra el comienzo de la computación después de la segunda guerra mundial y de todos los actores que tuvieron un impacto en el desarrollo de la computación moderna.</p>\n\n<p>Es una crónica muy completa, junto con la explicación de muchos conceptos de la computación. El autor, hijo del físico <a href=\"https://www.profisica.cl/index.php/component/content/article/115-biografias/216-freeman-dyson?Itemid=542\">Freeman Dyson</a>, tuvo acceso a muchos de los actores de la historia y a sus documentos, lo que le permitió hacer una libro que revela muchos detalles.</p>\n\n<p>Sin duda es algo que muchos dedicados a esta área del conocimiento queremos leer. Lo puedes comprar aquí: <a href=\"https://amzn.to/3NoQKV6\" target=\"_blank\" rel=\"noopener\">La Catedral de Turing</a>.</p>\n\n<h2 id=\"otros-temas-relacionados\">Otros temas relacionados</h2>\n\n<p>Finalmente, como última parte de este artículo y de la serie de libros recomendados. Quiero poner algunas recomendaciones sobre temas y habilidades alternas a la programación que te ayudarán tanto como programador como a desarrollar tu carrera.</p>\n\n<p>Algunos de estos temas o libros pensarás que no tienen nada que ver, pero te puedo asegurar que son habilidades y temas de soporte necesarios que te van a ayudar a resaltar.</p>\n\n<h3 id=\"how-to-solve-it--george-polya\">How to solve it | George Polya</h3>\n\n<p><a href=\"https://math.hawaii.edu/home/pdf/putnam/PolyaHowToSolveIt.pdf\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686666135/71GFUNCh7hL._AC_UF1000_1000_QL80__q5xtrk.jpg\" alt=\"Portada de How to solve it\" class=\"align-center\" /></a></p>\n\n<p>George Polya fue un matemático del Siglo XX que contribuyó en el área de heurística y resolución de problemas. Fue un gran profesor al mismo tiempo que un gran investigador. Este libro es una combinación de ambas facetas de él: le preocupaba que las matemáticas se enseñaran bien al mismo tiempo que él era muy bueno haciendo matemáticas.</p>\n\n<p>En este escrito, Polya establece los pasos a seguir para resolver problemas matemáticos, pero que por extensión también nos sirve a los desarrolladores para aprender a establecer un método para resolver los problemas que encontramos día a día en nuestro trabajo.</p>\n\n<p>Los cuatro pasos que propone son:</p>\n\n<ul>\n  <li>Plantear y entender correctamente el problema</li>\n  <li>Idear un plan para resolverlo (aquí da algunas técnicas comunes)</li>\n  <li>Ejecutar el plan</li>\n  <li>Revisar el resultado, el proceso y los aprendizajes</li>\n</ul>\n\n<p>Cuando lo leí, noté inmediatamente que era un libro que se debería dar en todas las escuelas relacionadas con la ingeniería o la computación, ya que nos da claridad, o por lo menos una idea de cómo empezar a resolver algo.</p>\n\n<p>Lo puedes comprar aquí: <a href=\"https://amzn.to/43YlSQC\" target=\"_blank\" rel=\"noopener\">How to solve it</a>, pero también lo puedes leer gratis: <a href=\"https://cienciaymatematicas.files.wordpress.com/2012/09/como-resolver.pdf\">Cómo plantear y resolver problemas</a>.</p>\n\n<h3 id=\"enfócate--cal-newport\">Enfócate | Cal Newport</h3>\n\n<p><a href=\"https://www.amazon.com.mx/Enf%C3%B3cate-estrategias-eficacia-trabajo-creativo/dp/607527998X\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686669189/71p-QmjVoWL._AC_UF1000_1000_QL80__ymtjyl.jpg\" alt=\"Portada de Enfócate\" class=\"align-center\" /></a></p>\n\n<p>La atención es uno de los bienes más preciados que tenemos los seres humanos, ya que a nuestra mente consciente sólo entra aquello a lo que la dirigimos o <em>enfocamos</em>. Pero cuando más beneficios da es cuando la enfocamos en una sola cosa por un periodo prolongado. Es como si nuestra mente fuera acelerando y tomando impulso para resolver un problema.</p>\n\n<p>Esa es la tesis principal de “Enfócate”, un profesor de ciencias de la computación, muy interesado en temas como el logro académico, la productividad intelectual y el rendimiento a pesar de los obstáculos modernos.</p>\n\n<p>En este libro, presenta un caso muy sólido para convencerte de apartar tiempo ininterrumpido para lograr tus tareas más difíciles. Además, relata cómo él lo logra y te da algunos consejos para que tú lo puedas hacer.</p>\n\n<p>Creo que este libro es especialmente relevante para los desarrolladores de software por el entorno en el que trabajamos y porque muchos de los problemas que enfrentamos rebasan nuestra capacidad o conocimiento actual, por lo que necesitamos toda la ayuda posible para poder resolverlos.</p>\n\n<p>Puedes comprarlo aquí: <a href=\"https://amzn.to/45YWNqJ\" target=\"_blank\" rel=\"noopener\">Enfócate</a>.</p>\n\n<h3 id=\"accelerate--nicole-forsgren\">Accelerate | Nicole Forsgren</h3>\n\n<p><a href=\"https://www.oreilly.com/library/view/accelerate/9781457191435/9\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686808509/41OoXs3W3nL._AC_UF1000_1000_QL80__knm3bn.jpg\" alt=\"Portada de Accelerate\" class=\"align-center\" /></a></p>\n\n<p><strong>¿Qué es lo que distingue a un equipo de alto rendimiento en la entrega de software de uno de bajo rendimiento?</strong> La medida más básica es el tiempo que toma un cambio en ser liberado o en llegar a producción. En este libro se habla de 1) cómo medir esto y 2) los factores que llevan a un equipo a mejorar esas métricas.</p>\n\n<p>En realidad el libro es el resultado de un estudio de muchos equipos de desarrollo de software, en el que descubrieron varias cosas acerca de los equipos de alto rendimiento, entre ellas:</p>\n\n<ul>\n  <li>Las prácticas técnicas que tienen</li>\n  <li>El tipo de liderazgo que los guía</li>\n  <li>Qué tipo de arquitecturas siguen</li>\n  <li>Qué prácticas de administración de recursos humanos siguen</li>\n  <li>Cómo hacen todo el trabajo sostenible</li>\n</ul>\n\n<p>Además el libro habla de la forma en la que se realizó el estudio. Sin duda, es un libro muy valioso para los desarrolladores de software que quieren mejorar su rendimiento y el de sus equipos. Puedes comprarlo aquí: <a href=\"https://amzn.to/3JaPTEP\" target=\"_blank\" rel=\"noopener\">Accelerate</a>.</p>\n\n<h3 id=\"data-and-reality--william-kent\">Data and Reality | William Kent</h3>\n\n<p><a href=\"https://www.bkent.net/Doc/darxrp.htm\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686837219/41351CTT93L._AC_UF1000_1000_QL80__qgzcwb.jpg\" alt=\"Portada de Data and Reality\" class=\"align-center\" /></a></p>\n\n<p>Creo que como programadores, gran cantidad del tiempo lo dedicamos a procesar datos, o a crear representaciones datos de procesos externos a la computación. Esto es el <strong>modelado de datos</strong>, y es de lo que este libro habla, pero de manera bastante especial.</p>\n\n<p><strong>William Kent</strong> hace un análisis profundo de las cosas a las que estamos acostumbrados: modelos, datos, registros, relaciones, atributos, entidades. Primero, <em>intenta</em> definirlas y después aplicarlas al modelado de datos, explorando las implicaciones de definición. Es un libro que te va a hacer pensar bastante, relacionado con la epistemología, la ontología y en nuestra percepción de la realidad.</p>\n\n<p>Aunque el libro te deja con más dudas que respuestas, deja algo totalmente claro: no existe una forma <em>correcta</em> de modelar el mundo, sólo <strong>representaciones más convenientes</strong> para un caso u otro, ya que todas son arbitrarias.</p>\n\n<p>Yo leí la <a href=\"https://amzn.to/42FOOMs\">tercera edición</a>, que es la que única que está en producción actualmente. Esta tiene comentarios de otro modelador de datos muy experimentado, pero que según <a href=\"https://buttondown.email/hillelwayne/archive/data-and-reality-2nd-edition/\">Hillel Wayne</a> cambió completamente el libro.Hillel recomienda leer la segunda edición, que aunque ya no está en impresión, lo puedes encontrar en <a href=\"/assets/pdfs/Data%20and%20Reality.pdf\" target=\"_blank\" rel=\"noopener\">PDF</a>. Yo tengo pendiente leer la segunda edición, pero tengo altas expectativas ya que incluso la tercera me dejó grandes enseñanzas.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>Para avanzar en tu carrera no basta con aprender sólo habilidades técnicas, también hacen falta algunas meta-habilidades, habilidades paralelas y conocimiento de la historia de tu profesión.</p>\n\n<p>Tener estos conocimientos te puede hacer destacar de los demás profesionales, y son especialmente útiles si quieres lograr un puesto de liderazgo. Así que sigue preparándote, recuerda que un libro bien editado es de las mejores inversiones que puedes hacer.</p>\n",
      "date_published": "Thu, 15 Jun 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/06/08/libros-que-todo-desarrollador-de-software-deberia-leer-arquitectura.html",
      "url": "https://blog.thedojo.mx/2023/06/08/libros-que-todo-desarrollador-de-software-deberia-leer-arquitectura.html",
      "title": "Libros que todo desarrollador de software debería leer: arquitectura",
      "content_html": "<p>Hablemos sobre los libros de arquitectura de software que te enseñarán a tomar en cuenta los aspectos importantes de este campo y te pueden hacer mejor desarrollador. Como muchos desarrolladores con experiencia mencionan, la arquitectura es un rol, no un puesto de trabajo. Como rol, lo puedes ejercer parcialmente, y todos los desarrolladores deberíamos hacer arquitectura de software a diferentes escalas. El arquitecto que sólo hace diseños no debería existir.</p>\n\n<p>En ninguno de estos libros vas a encontrar la sugerencia de que el arquitecto es un puesto de trabajo que sólo se dedica a hacer “planos”, sino que lo verás como una habilidad más que los desarrolladores de software debemos de tener. Empecemos con las recomendaciones, y como siempre, si quieres contribuir con alguna recomendación, puedes hacerlo en los comentarios.</p>\n\n<h3 id=\"designing-data-intensive-applications--martin-kleppmann\">Designing Data-Intensive Applications | Martin Kleppmann</h3>\n\n<p><a href=\"https://www.oreilly.com/library/view/designing-data-intensive-applications/9781491903063/\" target=\"_blank\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1685729621/Screen_Shot_2023-06-02_at_12.13.03_ws9bgp.png\" alt=\"Portada de Designing Data Intensive Applications\" class=\"align-center\" /></a></p>\n\n<p>Aceptémoslo: 90% de las aplicaciones útiles necesitan procesar grandes cantidades de datos para funcionar. A veces sólo a eso se dedican.</p>\n\n<p>Es por eso que un libro como este, que habla del funcionamiento interno de diferentes sistemas que procesan grandes cantidades de datos, su arquitectura y las técnicas que los hacen funcionar, es un libro esencial para los desarrolladores de software modernos.</p>\n\n<p>Algunos temas que vas a poder aprender son:</p>\n\n<ul>\n  <li>Las características de un buen sistema que procesa información</li>\n  <li>Las estructuras de datos que le dan el poder sistemas como las bases de datos</li>\n  <li>Modelos de datos y lenguajes de consulta</li>\n  <li>Replicación</li>\n</ul>\n\n<p>Todos estos temas son esenciales para ser un buen desarrollador de software.</p>\n\n<p>Puedes comprarlo aquí: <a href=\"https://www.oreilly.com/library/view/designing-data-intensive-applications/9781491903063/\" target=\"_blank\">Designing Data-Intensive Applications</a> o en <a href=\"https://www.amazon.com.mx/Designing-Data-Intensive-Applications-Reliable-Maintainable/dp/1449373321\" target=\"_blank\">Amazon</a></p>\n\n<h3 id=\"sofware-architecture-for-developers-y-the-c4-model--simon-brown\">Sofware Architecture for Developers y The C4 Model | Simon Brown</h3>\n\n<p><a href=\"https://softwarearchitecturefordevelopers.com/\" target=\"_blank\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1685744265/s_hero2x_h5emvj.png\" alt=\"Portada de Software Architecture for Developers\" class=\"align-center\" /></a></p>\n\n<p><a href=\"https://simonbrown.je/\">Simon Brown</a> es un desarrollador y arquitecto que enseña a otros desarrolladores a practicar lo mejor posible la arquitectura de software.</p>\n\n<p>Simon explica en <strong>Software Architecture for Developers</strong> lo que es la arquitectura de software, desde su comparación con la arquitectura de edificios, las cosas en las que se parece y diferencia, junto las responsabilidades y el conocimiento que es necesario para esta actividad.</p>\n\n<p>En el <strong>“The C4 Model”</strong> explica una forma específica de comunicar la información que el diseño de un sistema contiene, incluyendo cuatro diagramas a diferentes niveles de abstracción, con el objetivo de que quienes lo analicen se lleven una buena idea de cómo funciona el sistema.</p>\n\n<p>Puedes comprarlos aquí: <a href=\"https://leanpub.com/b/software-architecture\" target=\"_blank\">Software Architecture for Developers</a>, también puedes comprarlos por separado, pero te llevas un mejor valor si los compras juntos.</p>\n\n<h3 id=\"fundamentals-of-software-architecture--mark-richards--neal-ford\">Fundamentals of Software Architecture | Mark Richards &amp; Neal Ford</h3>\n\n<p><a href=\"https://www.oreilly.com/library/view/fundamentals-of-software/9781492043447/\" target=\"_blank\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686180937/91HMsnYFsKL._AC_UF1000_1000_QL80__pyue4w.jpg\" alt=\"Portada de Fundamentals of Software Architecture\" class=\"align-center\" /></a></p>\n\n<p>¿Quieres obtener el conocimiento más básico de arquitectura de software? En este libro, los autores te lo enseñarán.</p>\n\n<p>Empieza desde lo esencial y avanza hasta las mejores prácticas para analizar las características que necesitas implementar. El libro pasa (a grandes rasgos) por los siguientes temas:</p>\n\n<ol>\n  <li>¿Qué es la arquitectura de software?</li>\n  <li>Cómo adquirir la forma de pensar de un arquitecto</li>\n  <li>Estilos arquitectónicos</li>\n  <li><strong>Softskills</strong> para arquitectos</li>\n</ol>\n\n<p>Es un gran libro con muy buenas temas para empezar a practicar directamente, además escrito por expertos en el tema.</p>\n\n<p>Puedes comprarlo aquí: <a href=\"https://amzn.to/3MZqT4L\" target=\"_blank\">Fundamentals of Software Architecture</a></p>\n<h3 id=\"software-architecture-the-hard-parts--neal-ford-mark-richards-pramod-sadalage--zhamak-dehghani\">Software Architecture the Hard Parts | Neal Ford, Mark Richards, Pramod Sadalage &amp; Zhamak Dehghani</h3>\n\n<p><a href=\"https://www.oreilly.com/library/view/software-architecture-the/9781492086888/\" target=\"_blank\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686178147/811EFOBsU7L._AC_UF1000_1000_QL80__prpedd.jpg\" alt=\"Portada de Software Architecture the Hard Parts\" class=\"align-center\" /></a></p>\n\n<p>Los sistemas distribuidos son lo que más se desarrolla hoy en día, debido a las necesidades de la industria. Saber crear arquitecturas distribuidas es algo que un desarrollador avanzado debe dominar.</p>\n\n<p>En este libro se habla de tres cosas principales:</p>\n\n<ol>\n  <li>Buenas ideas para empezar a hacer y documentar arquitecturas</li>\n  <li>Separación: diseñar los componentes, los módulos, separación de datos, etc.</li>\n  <li>Juntar todo de nuevo: contratos, service meshes, transacciones distribuidas, flujos de trabajo, etc.</li>\n</ol>\n\n<p>Es un libro que maneja temas avanzados y temas sobre los que tienes que saber bastante antes de empezar a leer el libro, así que te recomiendo empezar con los libros anteriores, además de obtener nociones de sistemas distribuidos.</p>\n\n<p>Puedes comprarlo aquí: <a href=\"https://amzn.to/3MWLtTe\" target=\"_blank\">Software Architecture the Hard Parts</a></p>\n\n<h3 id=\"domain-driven-design--eric-evans\">Domain Driven Design | Eric Evans</h3>\n\n<p><a href=\"https://www.amazon.com.mx/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215\" target=\"_blank\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686285460/61aFldsgAmL._AC_UF1000_1000_QL80__telho9.jpg\" alt=\"Portada de Domain Driven Design\" class=\"align-center\" /></a></p>\n\n<p>Este libro es la Biblia del diseño dirigido por el dominio, un estilo que se enfoca en crear un modelo de software que refleje el negocio (o el <em>dominio</em>) de la mejor manera posible.</p>\n\n<p>La principal idea de esta técnica es que los desarrolladores de software se entiendan y puedan hablar como un experto más en el dominio. Esto se logra creando un lenguaje común entre los desarrolladores y los expertos en el dominio, soportado por el modelo de software que se crea.</p>\n\n<p>Creo que aunque no siempre es aplicable, es bueno conocerlo y tener listas las técnicas para la aplicación completa o parcial de este estilo de diseño.</p>\n\n<p>Puedes comprarlo aquí: <a href=\"https://amzn.to/3CgwaQx\" target=\"_blank\">Domain Driven Design</a>.</p>\n\n<p>Un libro alternativo a este, más moderno y ligero es: <a href=\"https://www.oreilly.com/library/view/learning-domain-driven-design/9781098100124/\" target=\"_blank\">Learnig Domain Driven Design</a>.</p>\n\n<h3 id=\"system-design-interview-1-y-2--alex-xu\">System Design Interview 1 y 2 | Alex Xu</h3>\n\n<p><a href=\"https://www.youtube.com/channel/UCZgt6AzoyjslHTC9dz0UoTw\" target=\"_blank\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686286291/51xUZItrHJL._AC_UF1000_1000_QL80__kzvtkb.jpg\" alt=\"Portada de System Design Interview 1\" class=\"align-center\" /></a></p>\n\n<p>Estos libros te enseña de manera concisa las bases del diseño de sistemas de software, desde los principios de diseño, hasta las diferentes partes que componen un sistema complejo que necesita soportar muchos usuarios.</p>\n\n<p><strong>Alex Xu</strong> es un buen creador de contenido de muy buena calidad y en estos libros explica lo necesario de forma lo suficientemente sencilla. Te lo recomiendo si quieres aprender sobre una gran cantidad de temas relacionados con el diseño de sistemas y la arquitectura de software.</p>\n\n<p>Puedes ver la página en la que publica más información acerca de lo que hace en: <a href=\"https://bytebytego.com\">ByteByteGo</a> {:target=”_blank”}, además de que puedes suscribirte para aprender más sobre el diseño de sistemas y prepararte para entrevistas de trabajo.</p>\n\n<p>Lo puedes comprar aquí: <a href=\"https://amzn.to/3qARtK1\" target=\"_blank\">System Design Interview 1</a> y <a href=\"https://amzn.to/3J43CgP\" target=\"_blank\">System Design Interview 2</a></p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>Hay una buena colección de libros que te pueden ayudar a ser un <strong>mejor desarrollador</strong> de software mejor preparado, fortaleciendo una parte que todos los desarrolladores tenemos que ejercer: la arquitectura de software.</p>\n\n<p>Empieza con estos libros uno a uno, o <strong>úsalos como referencia</strong> para cuando tengas que resolver un problema específico.</p>\n",
      "date_published": "Thu, 08 Jun 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/05/30/pilares-fundamentales-de-las-ciencias-de-la-computacion.html",
      "url": "https://blog.thedojo.mx/2023/05/30/pilares-fundamentales-de-las-ciencias-de-la-computacion.html",
      "title": "Pilares fundamentales de las ciencias de la computación",
      "content_html": "<blockquote>\n  <p>The computer is the tool but not the object of study. - <strong>Peter Denning</strong></p>\n</blockquote>\n\n<p>Entender la computación <strong>profundamente</strong> es importante para cualquier desarrollador de software, porque al avanzar en su carrera se encontrará con problemas relacionados con las principios más fundamentales de la computación. Piensa en los siguientes casos:</p>\n\n<ul>\n  <li>¿Es mejor mantener este sistema como un monolito o dividirlo en <em>microservicios</em>?</li>\n  <li>¿Cómo puedo hacer que este sistema sea más <strong>rápido</strong>?</li>\n  <li>¿Cómo puedo hacer mi base de código más <strong>mantenible</strong>?</li>\n  <li>¿Cómo puedo <strong>representar mejor</strong> este problema en código?</li>\n  <li>¿Cómo puedo <strong>asegurar el mayor tiempo de actividad</strong> posible en el sistema?</li>\n  <li>¿Puedo <strong>garantizar</strong> que los mensajes que envío lleguen a su destino?</li>\n  <li>¿Cómo evito que la <strong>complejidad</strong> de esta base de código crezca más de lo que la voy a poder controlar?</li>\n</ul>\n\n<p>Tener herramientas para entender estos problemas evitará que te estanques o frustres, y te habilitará para crear sistemas que cumplan con lo se necesita de ellos. Además, te hará un miembro más valioso de cualquier organización.</p>\n\n<p>Un conocimiento sólido de cómo funciona la computación te ayudará por lo menos en los siguientes puntos:</p>\n\n<p>. Entender los entender los <strong>límites</strong> de lo que se puede hacer\n . Diseñar mejor software (y hardware si se necesita)\n . Trasladar mejor los problemas del mundo real a algo que la computadora pueda entender\n . Explicar en palabras comunes tus ideas\n . Descomponer los problemas computacionales en sus componentes básicos\n . Disfrutar más de tu trabajo</p>\n\n<p>Entender la computación profundamente incluye “<em>mejorar tu lógica de programación</em>”, un objetivo que muchos quieren lograr para obtener un nuevo puesto o trabajar en la empresa de sus sueños.</p>\n\n<p>En este artículo vamos a hablar de los seis aspectos que tienes que entender acerca de la computación, digamos que son sus <strong>principios fundamentales</strong>. Además veremos cómo se relaciona esto con las cosas comunes que oímos acerca de las ciencias de la computación: complejidad, algoritmos, estructuras de datos, etc.</p>\n\n<p>Aunque nos hemos dividido en áreas de dominios como:</p>\n\n<p>. Inteligencia artificial\n. Sistemas distribuidos\n. Computación en la nube\n. Tratamiento y análisis de datos\n. Seguridad informática\n. Muchas más y siguen apareciendo</p>\n\n<p>Todas estas áreas que tienen que ver con la computación <strong>obedecen a los mismos principios de los que hablaremos</strong> en este artículo.</p>\n\n<p>Pero antes definamos qué es la <strong>computación</strong>.</p>\n\n<h2 id=\"qué-es-la-computación\">¿Qué es la Computación?</h2>\n\n<p>Aquí vamos a hablar de la computación como la <strong>disciplina de usar las computadoras y el software</strong> para lograr nuestros objetivos, sean estos científicos, de negocios, de entretenimiento, etc.</p>\n\n<p>Estos objetivos pueden ser tan arbitrarios y diversos como lo es la cantidad de personas que actualmente usan las computadoras para sus propios objetivos.</p>\n\n<p>La computación se puede ver desde tres perspectivas diferentes:</p>\n\n<blockquote>\n  <p>It has been argued that there are three particularly lucid traditions in computer science: the theoretical tradition, the empirical tradition, and the engineering tradition. - <strong>Peter Denning</strong></p>\n</blockquote>\n\n<p>Según esto podemos ver la computación desde tres perspectivas:</p>\n\n<ul>\n  <li>La tradición teórica: ver la computación como una ciencia</li>\n  <li>La tradición empírica: ver la computación en la práctica</li>\n  <li>La tradición de la ingeniería: ver la computación como una herramienta</li>\n</ul>\n\n<p>Con tradición, el Denning se refiere a la forma en la que se ha desarrollado históricamente el área. Cada una de estas tradiciones ha desarrollado el área de una forma diferente, pero todas son importantes para entender la computación. Para que seamos profesionales completos, debemos entender lo suficiente de cada una de las áreas.</p>\n\n<h2 id=\"los-límites-de-la-computación\">Los límites de la computación</h2>\n\n<p>Algunas personas piensan que todo es posible dentro de una computadora. Sin embargo, “The Great Principles of Computing” nos dice que:</p>\n\n<blockquote>\n  <p>Computing is governed by scientific principles and laws that tell us what computers can and cannot do. - <strong>Peter Denning</strong></p>\n</blockquote>\n\n<p>Que podemos traducir como:</p>\n\n<blockquote>\n  <p>La computación <strong>está gobernada por principios</strong> y leyes científicas que nos dicen qué pueden y qué no pueden hacer las computadoras. - Peter Denning</p>\n</blockquote>\n\n<p>Así que las computación tiene límites y estos están dictados por los principios científicos que conocemos de otras áreas como la física y las matemáticas.</p>\n\n<h2 id=\"historia-y-nacimiento-de-la-computación-moderna\">Historia y nacimiento de la computación moderna</h2>\n\n<p>Aunque la computación en sí misma es mucho más que las computadoras que usamos, es importante entender cómo llegamos a este punto y junto con eso, las limitaciones que esto nos ha creado, así como las oportunidades que tenemos.</p>\n\n<p>Entender esta historia no te dará súper poderes de programación, pero te ayudará a saber donde estás parado en el flujo del tiempo.</p>\n\n<p>Este contexto te dará más bases para buscar por diferentes lados.</p>\n\n<h2 id=\"modelos-de-computación\">Modelos de computación</h2>\n\n<p>Un modelo de computación es una forma de representar una  mediante un sistema matemático. Esto nos permite analizar el problema y encontrar soluciones.</p>\n\n<h2 id=\"comunicación\">Comunicación</h2>\n\n<p>Gran parte de la computación tiene que ver con transmitir datos entre diferentes partes que ejecutan los cálculos, pueden ser diferentes computadoras o diferentes ejecutores de una misma computadora. También puede incluir mover información entre diferentes lugares de almacenamiento.</p>\n\n<p>Asegurarnos de que la información llegue a su destino consistentemente y sin errores (o poder detectarlos y corregirlos) es uno de los problemas que la computación tiene que resolver. Esto es especialmente importante en los sistemas distribuidos.</p>\n\n<h2 id=\"cálculos-o-computación\">Cálculos o Computación</h2>\n\n<p>En este “cristal” queremos entender que es lo que puede ser calculado o resuelto usando una computadora. Esto incluye conocer la complejidad de las soluciones y en general, si es posible resolver el problema, en qué tiempo y en <strong>qué medios de cómputo</strong>.</p>\n\n<p>Para esto se necesita un poco de matemáticas, pero además creatividad e inventiva, ya que hay que pensar en las diferentes formas en las que un algoritmo se puede comportar. Además, hay que saber notar y demostrar cuando un problema no tiene solución, o las soluciones que existen no son factibles.</p>\n\n<h2 id=\"coordinación\">Coordinación</h2>\n\n<p>No es siempre cierto que <em>“el orden de los factores no altera el producto”</em>. Además, para aprovechar el poder completo de un sistema, normalmente se necesita coordinar las diferentes partes que lo componen. Esto es cierto sobre todo con los sistemas de cómputo actuales, pero además con los sistemas de software que ocupan muchas computadoras.</p>\n\n<p>La coordinación tiene que ver con la concurrencia, el paralelismo y la forma de compartir datos y ponerse de acuerdo entre múltiples ejecutores para realizar una tarea de forma correcta.</p>\n\n<h2 id=\"recolección\">Recolección</h2>\n\n<p>¿Cómo conseguimos los datos para procesar? ¿O cómo recogemos los resultados de la computación? ¿Cómo los almacenamos y acomodamos? Esto es la recolección de datos. Además en dónde guardarla, en qué estructura ponerla y cómo recuperarla, es parte importante de este pilar de la computación.</p>\n\n<h2 id=\"evaluación\">Evaluación</h2>\n\n<p>Comprobar que los resultados de la computación son correctos, diseñar sistemas que puedan verificar los resultado y además medir el desempeño de los sistemas es una parte fundamental para hacer sistemas útiles.</p>\n\n<h2 id=\"diseño\">Diseño</h2>\n\n<p>No sólo se trata de echar código, también hay que pensarlo bien antes de ponerlo. El tiempo gastado en el diseño de un sistemas puede pagar dividendos grandes en el futuro. Los sistemas complejos, que son todos los que existen hoy, deben descomponerse en módulos para que sean manejables por los seres humanos.</p>\n\n<p>Cómo descomponerlos, qué interfaces crear y qué tipo módulos tendrá el sistema es dominio del diseño de la computación.</p>\n\n<h2 id=\"más-recursos\">Más recursos</h2>\n\n<p>En  este blog tenemos un post dedicado a los libros que te pueden servir para aprender más acerca de las ciencias de la computación: <a href=\"https://blog.thedojo.mx/2023/05/13/libros-que-todo-desarrollador-de-software-deberia-leer-cs.html\">Libros para aprender ciencias de la computación</a>.</p>\n\n<p>También puedes visitar la página <a href=\"https://teachyourselfcs.com/\">Teach Yourself Computer Science</a>, que tiene una lista de los temas que debes aprender y los recursos que puedes usar para aprenderlos.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>Aprender ciencias de la computación es algo que todo desarrollador debe <strong>aprender en su carrera</strong>. Te puede ayudar a ser más eficiente, a disfrutar mucho más de tu trabajo y resolver problemas que antes no creías posibles. Pero como acabas de ver, es un camino largo, que requiere de bastante esfuerzo sostenido.</p>\n\n<p>Sigue aprendiendo y verás cómo cada cosa nueva que le sumes a tus bases de conocimiento te ayudará a ser un <strong>mejor profesional</strong>.</p>\n\n<h2 id=\"referencias\">Referencias</h2>\n\n<p>A continuación algunas de las fuentes usadas para este artículo:</p>\n\n<ul>\n  <li>The Great Principles of Computing, Peter Denning y Craig Martell</li>\n  <li>Teach Yourself Computer Science, https://teachyourselfcs.com/</li>\n  <li>Concrethe Mathematics, Ronald L. Graham, Donald E. Knuth y Oren Patashnik</li>\n  <li>The Art of Computer Programming, Donald E. Knuth</li>\n</ul>\n",
      "date_published": "Tue, 30 May 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/05/25/libros-que-todo-desarrollador-de-software-deberia-leer-desarrollo.html",
      "url": "https://blog.thedojo.mx/2023/05/25/libros-que-todo-desarrollador-de-software-deberia-leer-desarrollo.html",
      "title": "Libros que todo desarrollador de software debería leer: desarrollo",
      "content_html": "<p>Ya hablamos en un <a href=\"https://blog.thedojo.mx/2023/05/13/libros-que-todo-desarrollador-de-software-deberia-leer-cs.html\">artículo anterior</a> sobre\nlos libros que te haría bien leer en el tema de ciencias de la computación.\nAhora vamos a hablar sobre el tema de desarrollo de software, cómo crear mejor software y con mejor calidad.\nEn este artículo también se incluyen libros sobre ingeniería de software por ser la disciplina más\nconfiable para crear software de calidad.</p>\n\n<p>Empecemos con las recomendaciones, espero que te sirvan.</p>\n\n<h3 id=\"a-philosophy-of-software-design---john-ousterhout\">A Philosophy of Software Design - John Ousterhout</h3>\n\n<p><a href=\"https://web.stanford.edu/~ouster/cgi-bin/book.php\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_350/v1684113024/Screen_Shot_2023-05-14_at_19.10.08_ocrzmo.png\" alt=\"Portada de a Philosophy of Software Design\" class=\"align-center\" /></a></p>\n\n<p>Este es un libro que te da muchos consejos sobre cómo crear bases de código que sean más fáciles de evolucionar, mantener y sobre todo, de entender. Está escrito por <a href=\"https://web.stanford.edu/~ouster/cgi-bin/home.php\">John Ousterhout</a>, el creador de RAMCloud, TCL/TK y co-autor del algoritmo de consenso para sistemas distribuidos <a href=\"https://raft.github.io/\">Raft</a>.</p>\n\n<p>Es un libro muy práctico y corto, que da consejos concretos <em>sin grandes ínfulas de superioridad</em> sobre cómo escribir mejor código. El tema principal es la complejidad, cuáles son sus síntomas y cómo puedes evitarla o manejarla. El libro se centra en <em>en la experiencia del autor</em> tanto escribiendo código y haciendo sistemas, como enseñando a otros a hacerlo en su clase <strong>“Software Design Studio”</strong>.</p>\n\n<p>Esto último (lo de dar clases) le da una visión privilegiada: ver los errores comunes que cometen los principiantes le permite atacar directamente los problemas en los que nos metemos por un mal <strong>diseño</strong>.</p>\n\n<p>Ousterhout se centra en los temas que para mi son los fundamentales de desarrollo de software:</p>\n\n<ol>\n  <li>La complejidad y sus causas</li>\n  <li>La abstracción</li>\n  <li>La modularidad y los criterios para dividir un sistema en módulos</li>\n  <li>Ocultar información de forma efectiva</li>\n  <li>La mejor forma de comunicar información al resto del equipo</li>\n</ol>\n\n<p>Si quieres darle una probada antes de comprarlo, puedes leer el <a href=\"https://web.stanford.edu/~ouster/cgi-bin/book.php\" target=\"_blank\" rel=\"noopener\">primer capítulo</a>.</p>\n\n<p>Y en este blog tenemos varios artículos hablando de sus ideas, puedes buscarlos con la etiqueta <a href=\"https://blog.thedojo.mx/tags/#aposd\" target=\"_blank\">APoSD</a>.</p>\n\n<p>Puedes comprarlo aquí: <a href=\"https://amzn.to/3q4NEwd\" target=\"_blank\">A Philosophy of Software Design</a></p>\n\n<h3 id=\"making-software---editado-por-andy-oram--greg-wilson\">Making Software - Editado por Andy Oram &amp; Greg Wilson</h3>\n\n<p><a href=\"https://www.oreilly.com/library/view/making-software/9780596808310/\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_350/v1684245311/Screen_Shot_2023-05-16_at_7.54.35_djc8uk.png\" alt=\"Portada de Making Software\" class=\"align-center\" /></a></p>\n\n<p>En este libro se habla de las prácticas <em>comunes</em> que <strong>creemos que nos ayudarán</strong> a desarrollar mejor software, pero desde el punto de vista del escepticismo. Se analizan estas prácticas y nos dice si realmente nos ayudan o no, y <strong>por qué</strong>, todo esto con base en estudios realizados a lo largo del tiempo en muchos equipos, junto con las opiniones de expertos en el tema.</p>\n\n<p>Los resultados probablemente te sorprendan, pero hay que recordar que ninguna práctica se comporta de la misma manera universalmente, es decir, lo que te sirva a ti puede no servirle a otro equipo. Así que aunque es una buena guía, nada es una verdad absoluta.</p>\n\n<p>Creo que este libro es <strong>fundamental</strong> para desarrollar una relación sana con las “buenas prácticas” y cuestionarte todas las cosas que te dicen respecto al desarrollo de software.</p>\n\n<p>Puedes comprarlo aquí: <a href=\"https://amzn.to/3oxZHBK\" target=\"_blank\">Making Software</a></p>\n\n<h3 id=\"modern-software-engineering---dave-farley\">Modern Software Engineering - Dave Farley</h3>\n\n<p><a href=\"https://www.davefarley.net/?p=352\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_350/v1684993243/61qXAFawZVL._AC_UF1000_1000_QL80__mbrnes.jpg\" alt=\"Portada de Modern Software Engineering\" class=\"align-center\" /></a></p>\n\n<p>Escrito por un gran ingeniero de software con mucha experiencia, explica técnicas efectivas para la organización del trabajo y la liberación de software lo más rápido posible. Dave es un proponente muy fuerte de la entrega continua y de la automatización de pruebas, y en este libro explica las técnicas asociadas a estos temas.</p>\n\n<p>Además explica por qué la ingeniería de software no tiene que ser una carga burocrática. La premisa básica es que toda práctica que no nos ayude a hacer mejor software más rápido, es una mala idea y no debería contar como “ingeniería”.</p>\n\n<p>Puedes comprarlo aquí: <a href=\"https://amzn.to/3MzYXnD\" target=\"_blank\">Modern Software Engineering</a></p>\n\n<h2 id=\"the-mythical-man-month---frederick-brooks\">The Mythical Man-Month - Frederick Brooks</h2>\n\n<p><a href=\"https://en.wikipedia.org/wiki/The_Mythical_Man-Month\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_350/v1684992740/51Al66uQmcL._SX433_BO1_204_203_200__f2yws3.jpg\" alt=\"Portada de The Mythical Man-Month\" class=\"align-center\" /></a></p>\n\n<p>Frederick Brooks era un ingeniero de la computación que trabajó en el IBM System/360 y en el OS/360, sistemas muy grandes y que le dieron para después describir su experiencia en la serie de ensayos que conforman este libro.</p>\n\n<p>Como te lo podrás imaginar, aprendió mucho en los proyectos que realizó, sobre todo de la administración de equipos. En estos ensayos podrás llevarte sus aprendizajes. El además es el autor de otros ensayos como “No Silver Bullet” y de la famosa frase:</p>\n\n<blockquote>\n  <p>“Adding manpower to a late software project makes it later.”</p>\n</blockquote>\n\n<blockquote>\n  <p>“Añadir personal a un proyecto de software atrasado, lo atrasa más.”</p>\n</blockquote>\n\n<p>Puedes comprar el libro aquí: <a href=\"https://amzn.to/3q8IG1D\" target=\"_blank\">The Mythical Man-Month</a>, pero también puedes leer la primera edición de forma gratuita aquí: <a href=\"https://web.eecs.umich.edu/~weimerw/2018-481/readings/mythical-man-month.pdf\" target=\"_blank\">The Mythical Man-Month en la universidad de Virginia</a>.</p>\n\n<h3 id=\"refactoring---martin-fowler\">Refactoring - Martin Fowler</h3>\n\n<p><a href=\"https://martinfowler.com/books/refactoring.html\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/v1684994739/refact2_og8gz8.jpg\" alt=\"Portada de Refactoring\" class=\"align-center\" /></a></p>\n\n<p>Uno de los grandes clásicos en el desarrollo de software, establece la importancia y la forma en la que puedes refactorizar tu código. Refactorizar significa cambiar la implementación de tu código, haciéndola mejor, sin cambiar su funcionamiento externo, o la función que provee.</p>\n\n<p>Martin Fowler también es uno de los más grandes nombres en el campo del desarrollo de software por su gran experiencia tanto desarrollando software como escribiendo, por lo que puedes estar seguro de que sus consejos son de gran valor.</p>\n\n<p>Puedes comprarlo aquí: <a href=\"https://amzn.to/3osHZj6\" target=\"_blank\">Refactoring</a></p>\n\n<h3 id=\"software-engineering-at-google--titus-winters-tom-manshreck-hyrum-wright\">Software Engineering at Google | Titus Winters, Tom Manshreck, Hyrum Wright</h3>\n\n<p><a href=\"https://abseil.io/resources/swe-book\" target=\"_blank\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1685757582/swe_at_google.2.cover_y3khmc.jpg\" alt=\"Portada de Software Engineering at Google\" class=\"align-center\" /></a></p>\n\n<p>Este libro explica la forma en la que se practica la ingeniería de software\nen Google, uno de los más grandes creadores de software de la historia. El libro abarca tres grandes áreas:</p>\n\n<ul>\n  <li>La cultura</li>\n  <li>Los procesos</li>\n  <li>Las herramientas</li>\n</ul>\n\n<p>El libro no habla tanto de código sino que se centra más en el <em>desarrollo de software</em>.</p>\n\n<p>Algo que hay que tener en cuenta es que Google no tiene el monopolio de la verdad sobre el desarrollo de software, así que esta es una perspectiva que te va a dar ideas, y una visión más amplia de cómo desarrollar software.</p>\n\n<p>Puedes comprarlo en <a href=\"https://amzn.to/43EiOJt\" target=\"_blank\">Amazon</a> o leerlo gratis aquí: <a href=\"https://abseil.io/resources/swe-book/html/toc.html\" target=\"_blank\">Software Engineering at Google</a></p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>Estos son los libros que pude pensar como las mejores recomendaciones para aprender desarrollo de software.</p>\n\n<p>No incluyo deliberadamente el más famoso de todos por lo menos entre los desarrolladores latinoamericanos: Clean Code. ¿Por qué? Aunque dice cosas útiles, muchas son obvias, explicadas mejor en otros libros y además el tono de superioridad que tiene el autor es muy molesto. Quienes lo han interiorizado se creen mejores simplemente por conocer esos consejos, que (<em>aquí viene lo peor</em>) a veces son contraproducentes.</p>\n\n<p>Si tienes alguna recomendación extra, puedes dejarla en los comentarios.</p>\n",
      "date_published": "Thu, 25 May 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/05/13/libros-que-todo-desarrollador-de-software-deberia-leer-cs.html",
      "url": "https://blog.thedojo.mx/2023/05/13/libros-que-todo-desarrollador-de-software-deberia-leer-cs.html",
      "title": "Libros que todo desarrollador de software debería leer: ciencias de la computación",
      "content_html": "<p>Hablemos de algunos libros que te pueden ayudar a avanzar en tu carrera como desarrollador de software, por diferentes razones, por ejemplo te ayudarán a fortalecer tus bases, o te darán ideas para hacer mejor software, mejores arquitecturas o a mejorar como profesional en general.<sup id=\"fnref:1\" role=\"doc-noteref\"><a href=\"#fn:1\" class=\"footnote\" rel=\"footnote\">1</a></sup></p>\n\n<p>Empecemos por los fundamentos mismos de lo que hacemos. Los siguientes libros te ayudarán a entender mejor cómo  funciona la computación desde sus raíces.</p>\n\n<p>Aunque esta sección está en primer lugar, no significa que debas leerlos antes que todo. Por ejemplo, cuando aprendiste español no aprendiste primero teoría de lenguajes, semántica, semiótica y todas las cosas que soportan el lenguaje. Aprendiste a hablar y a escribir, y luego, para profundizar aprendiste los soportes teóricos, por gusto o por necesidad. Lo mismo pasa con la computación.</p>\n\n<p>Lamentablemente, la mayoría de los libros de este artículo están en inglés. Pero aquí viene otro consejo que hemos aprendido con los golpes de los años: <strong>la gran mayoría de la información en ciencias de la computación está en inglés, y es un idioma indispensable para un desarrollador de software.</strong></p>\n\n<p>Empecemos con la lista de libros.</p>\n\n<h2 id=\"computational-thinking---peter-j-denning-y-matti-tedre\">Computational Thinking - Peter J. Denning y Matti Tedre</h2>\n\n<p><a href=\"https://mitpress.mit.edu/9780262536561/computational-thinking/\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_350/v1683954800/content_ylyx0g.png\" alt=\"Portada de Computational Thinking\" class=\"align-center\" /></a></p>\n\n<p>Este libro me parece una lectura fundamental para todos los estudiantes de ciencias de la computación pero también para desarrolladores de software con más experiencia práctica.</p>\n\n<p>Está escrito por <strong>Matti Tedre</strong> y <strong>Peter J. Denning</strong>, y es una lectura muy amena y fácil de entender. Pero no por eso es superficial, trata profundamente una pregunta: ¿qué es el pensamiento computacional? Explora el tema por varios aspectos:</p>\n\n<ul>\n  <li>Las máquinas y el nacimiento de la computación como disciplina</li>\n  <li>La ingeniería y el diseño de software</li>\n  <li>La educación de las ciencias de la computación</li>\n  <li>La relación de la ciencia tradicional con la computación</li>\n</ul>\n\n<p>Los dos autores son parte del grupo que se encarga de la recomendación de los temarios de ciencias de la computación de la ACM. Por lo que tienen una visión muy amplia de lo que es la computación y cómo se enseña. Este libro te dejará claro de lo que hablamos con “computación” y el tipo de pensamiento que se requiere para hacerla. También aclarará si todos necesitan estudiarla y algunos mitos alrededor de ella.</p>\n\n<p>Puedes comprarlo aquí: <a href=\"https://amzn.to/3M3Tg2l\" target=\"_blank\" rel=\"noopener\">https://amzn.to/3LJf95S</a></p>\n\n<h2 id=\"computer-science-distilled---wladston-ferreira-filho\">Computer Science Distilled - Wladston Ferreira Filho</h2>\n\n<p><a href=\"https://code.energy/computer-science-distilled/\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_350/v1683955925/book_ipakcs.jpg\" alt=\"Portada de Computer Science Distilled\" class=\"align-center\" /></a></p>\n\n<p>Para muchos esto parecerá una mala elección, sin embargo, para mi este libro tiene todo lo que se necesita para ser una buena introducción a los temas principales de la ciencias de la computación, de manera práctica y sencilla. Es cierto que por su extensión no puede tratar ninguno a profundidad, pero te da una visión amplia de todos los temas que tienes que conoces.</p>\n\n<p>Explica de manera sencilla los pilares principales de las ciencias de la computación y lo mejor es que te da referencias para que puedas profundizar en cada uno de los temas. Te servirá más si eres un principiante, pero aún si eres un desarrollador experimentado te puede servir para reforzar algunos temas que no tengas claro o para tener una referencia rápida de algunos temas.</p>\n\n<p>Este es un libro que creo que <strong>sí debes leer lo más temprano posible en tu carrera</strong>.</p>\n\n<p>Puedes comprarlo en <a href=\"https://amzn.to/3nZVHKb\" target=\"_blank\" rel=\"noopener\">Amazon</a> o en su <a href=\"https://code.energy/computer-science-distilled/\" target=\"_blank\" rel=\"noopener\">página oficial</a>.</p>\n\n<h3 id=\"the-elements-of-computing-systems-building-a-modern-computer-from-first-principles---noam-nisan-y-shimon-schocken\">The Elements of Computing Systems: building a modern computer from first principles - Noam Nisan y Shimon Schocken</h3>\n\n<p><a href=\"https://www.nand2tetris.org/book\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_350/v1683954809/Screen_Shot_2023-05-12_at_8.38.27_nzachg.png\" alt=\"Portada de The Elements of Computing Systems\" class=\"align-center\" /></a></p>\n\n<p>En este libro encontrarás un entendimiento básico del funcionamiento de una computadora digital, pero desde el mismísimo fondo. Es un libro MUY profundo, en el que contruirás una computadora digital desde cero, tanto el hardware como el software.</p>\n\n<p>No es un libro que recomiende leer al principio de la carrera ni mucho menos como un prerrequisito para empezar a trabajar, es más bien, algo que ir consumiendo con los años, para entender cada vez mejor cómo funciona fundamentalmente el aparato que usas a diario.</p>\n\n<p>El principio más fundamental de este libro es “aprender haciendo”, por que lo que mejor se aprende es <strong>mediante la práctica</strong>.</p>\n\n<p>Lo puedes comprar aquí: <a href=\"https://amzn.to/3nXJvJR\" target=\"_blank\" rel=\"noopener\">The Elements of Computing Systems</a></p>\n\n<h2 id=\"the-great-principles-of-computing---peter-j-denning\">The Great Principles of Computing - Peter J. Denning</h2>\n\n<p><a href=\"https://amzn.to/3O8gk1u\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_350/v1684031325/great_principles_i5btll.jpg\" alt=\"Portada de The Great Principles of Computing\" class=\"align-center\" /></a></p>\n\n<p>En este libro, Peter J. Denning y Craig H. Martell explican los principios que le dan forma e influyen en el campo de la coputación. Estos principios están divididos en 6 categorías:</p>\n\n<ul>\n  <li>Cálculos</li>\n  <li>Comunicación</li>\n  <li>Coordinación</li>\n  <li>Recolección</li>\n  <li>Diseño</li>\n  <li>Evaluación</li>\n</ul>\n\n<p>Cada uno de estos principios limitan y le dan formas a las tecnologías que usamos, por lo que entenderlos profundamente sin duda te ayudará a ser mejor usando las computadoras y más específicamente, a ser un mejor desarrollador de software.</p>\n\n<p>No creo que este libro se tenga que leer antes de cualquier otra cosa, pero sí siento que mientras más temprano lo hagas en tu carrera, mejor.</p>\n\n<p>Lo puedes comprar aquí: <a href=\"https://amzn.to/3O8gk1u\" target=\"_blank\" rel=\"noopener\">The Great Principles of Computing</a></p>\n<h3 id=\"the-algorithm-design-manual---steven-s-skiena\">The Algorithm Design Manual - Steven S. Skiena</h3>\n\n<p><a href=\"https://amzn.to/42GGAnv\" target=\"_blank\" rel=\"noopener\"><img src=\"https://res.cloudinary.com/hectorip/image/upload/c_scale,w_350/v1683777664/Screen_Shot_2023-05-10_at_21.48.04_cwmr6v.png\" alt=\"Portada de The Algorithm Design Manual\" class=\"align-center\" /></a></p>\n\n<p>Este es uno de los mejores libros para aprender sobre algoritmos y estructuras de datos, es una lectura que te ayudará mucho.</p>\n\n<p>Está escrito por <strong>Steven S. Skiena</strong> y va en su 3ra edición. Y es una lectura que puede ayudarte de manera <em>no tan compleja</em> a aprender sobre algoritmos y estructuras de datos. Es un libro bastante extenso y que va avanzando poco a poco en los temas relacionados con algoritmos y estructuras de datos, bellamente ilustrado, sin demasiada carga matemática.</p>\n\n<p>Tampoco es un libro que te tengas que leer de principio a fin, o muy temprano en la carrera. Puedes empezar con los primeros capítulos lo más pronto posible e irlo estudiando con el tiempo, o dejando los temas más avanzados para cuando los necesites puntualmente.</p>\n\n<p>Puedes comprarlo aquí: <a href=\"https://amzn.to/42GGAnv\" target=\"_blank\" rel=\"noopener\">The Algorithm Design Manual</a></p>\n\n<p>También puedes leer de manera gratuita la segunda edición en <a href=\"https://mimoza.marmara.edu.tr/~msakalli/cse706_12/SkienaTheAlgorithmDesignManual.pdf\">este link</a></p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>Estas son mis recomendaciones en este apartado importante de nuestra área del conocimiento. Si tienes alguna recomendación, no dudes en ponerte en contacto conmigo para que la agregue.</p>\n\n<p>Personalmente, siento que los libros son los mejores maestros que puedes tener. Un libro serio, bien escrito y bien editado es un maestro que acumula la experiencia de muchas personas, principalmente del autor, pero también de los editores, correctores y otras personas que participan en su creación.</p>\n\n<p>Un libro acumula muchos años de experiencia, y es la forma más directa de “parte en hombros de gigantes”. Es cierto, leerlos cuesta trabajo, pero es algo que te va a devolver mucho más de lo que inviertes en ellos.</p>\n\n<p>En los próximos artículos hablaremos de libros de otras áreas relacionadas con el desarrollo de software, como la ingeniería de software, la arquitectura y otros temas variados.</p>\n\n<div class=\"footnotes\" role=\"doc-endnotes\">\n  <ol>\n    <li id=\"fn:1\" role=\"doc-endnote\">\n      <p>Algunos de los links son links de afiliado de Amazon, por lo que puede que me lleve una pequeña comisión si compras el libro a través de ellos. Esto no afecta el precio que pagas por el libro además de que no afecta para NADA mi recomendación. <a href=\"#fnref:1\" class=\"reversefootnote\" role=\"doc-backlink\">&#8617;</a></p>\n    </li>\n  </ol>\n</div>\n",
      "date_published": "Sat, 13 May 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/05/06/por-que-deberias-leer-data-and-reality.html",
      "url": "https://blog.thedojo.mx/2023/05/06/por-que-deberias-leer-data-and-reality.html",
      "title": "¿Por qué deberías leer Data and Reality?",
      "content_html": "<p>Gran parte de nuestro trabajo como desarrolladores consiste en <strong>modelar entidades</strong> del mundo real en el código, transformarlas, guardarlas y recuperarlas. Estas entidades se pasan entre diferentes procesos para producir un resultado. A veces también nos tenemos que inventar entidades para representar conceptos abstractos que no existen físicamente.</p>\n\n<p><strong>Modelar datos</strong> es una de las habilidades <strong>fundamentales</strong> cuando estamos desarrollando.Cuando estás programando un algoritmo, estás modelando un <em>procedimiento</em> de la vida real en código. Este proceso normalmente incluye <strong>datos</strong>, que son representaciones de <em>entidades</em> del mundo real.</p>\n\n<p>Por lo anterior, cualquier cosa que puedas aprender sobre modelado de datos, te ayudará directamente en tu carrera como desarrollador. En este artículo hablaremos de un libro muy especial que te puede ayudar a ser mejor en esta área, independientemente del nivel en el que te encuentres en tu carrera. Y si después de leerlo lo meditas más profundamente, puede que te ayude a desarrollar una forma de pensar más adecuada a los problemas que queremos resolver en la actualidad.</p>\n\n<p><strong>Data and Reality</strong> trata sobre modelado de datos, escrito po William Kent, alguien con mucha experiencia en el tema. El libro tiene tres ediciones la primera es de 1978, la segunda (una actualización) es de 2000 y la tercera, después que Kent murió, es de 2012.</p>\n\n<p>La mejor de todas es segunda edición, ya que la tercera se podría considerar un libro completamente diferente, recortado y con comentarios de <a href=\"https://technicspub.com/steve-hoberman/\">Steve Hoberman</a>, otro modelador de datos pero siento que con un enfoque bastante diferente al de Kent.</p>\n\n<p>Hablemos de los temas principales del libro y por qué te conviene leerlo. Pero antes, veamos algo de lo que se habla en el prefacio de la edición de 2012 que me parece muy relevante.</p>\n\n<h2 id=\"buscando-las-respuestas-donde-parece-más-sencillo\">Buscando las respuestas donde parece más sencillo</h2>\n\n<p>Hay muchas cosas difíciles de resolver en el desarrollo de software y parece que siempre estamos buscando la respuesta en el lugar que parece más obvio o en el que es más fácil buscar, en lugar de donde es más probable que encontremos las respuestas.</p>\n\n<p>El ejemplo que utilizan en el libro para explicarlo y que me parece acertado es una broma acerca de un borracho que pierde sus llaves y se la pasa toda la noche buscando bajo una farola. Cuando alguien le pregunta por qué no busca en otro lado, <strong>el borracho responde que es porque AHÍ HAY MÁS LUZ.</strong></p>\n\n<p>En el desarrollo de software podría parecer que a veces hacemos exactamente lo mismo. Para buscar la solución a un problema siempre nos vamos a los mismos lados porque es donde nos sentimos cómodos o porque <strong>SIEMPRE SE HA BUSCADO AHÍ</strong>. Por ejemplo, nos centramos en la tecnología, en las plataformas o en los lenguajes. Pero es muy probable que el problema no esté ahí, sino en lugares más profundos.</p>\n\n<p>Es por eso que este libro se enfoca en cuestiones profundas del modelado de datos. No en los lugares comunes, ni siquiera en hablar de cómo hacerlo, sino en preguntas que te llevaran a pensar cosas de las que se habla poco y que probablemente modifiquen tu visión del mundo y tu forma de trabajar <strong>permanentemente</strong>.</p>\n\n<p>La intención de este artículo es dejarte con más dudas, pero llevarte a lugares en los que tal ve no habías estado antes, tal como avanzar a un nuevo lugar en el mapa en un juego de video.</p>\n\n<h2 id=\"cuestiones-principales\">Cuestiones principales</h2>\n\n<p>Hablemos de los conceptos principales de representación de información en los sistemas electrónicos.</p>\n\n<h3 id=\"entidades\">Entidades</h3>\n\n<p>Cuando guardamos cosas en una base de datos o las representamos en código, casi siempre nos referimos a ellas como <strong>entidades</strong>.</p>\n\n<p>Por eso el libro empieza cuestionando, <strong>¿qué es una entidad?</strong></p>\n\n<p>La primera respuesta es que una entidad “es un <strong><em>estado</em></strong> de la mente”. <strong>¿Cómo?</strong> Está bastante rara esa definición. Esta frase significa que una <strong>entidad</strong> más allá de algo que exista en la <strong>realidad</strong> como algo identificable e indivisible, algo que tiene límites fijos, es algo a lo que nosotros le damos significado, y que nosotros delimitamos o entendemos en ciertos contextos. Esta delimitación normalmente no es singular, tiene que ser compartida por un grupo de personas para que tenga sentido.</p>\n\n<p>Pongamos algunos ejemplos para entender eso. La leyenda del barco de <strong>Teseo</strong> relata que cuando él regresó de Creta, donde había matado al Minotauro, el pueblo de Atenas le rindió honores y conservó su barco en lo alto de una colina como un monumento para recordar su hazaña.</p>\n\n<p>Con el tiempo, el barco se fue deteriorando y se le fueron cambiando las partes, hasta que ya no quedó ninguna parte original.</p>\n\n<p>La pregunta es: ¿sigue siendo el <em>“Barco de Teseo”</em>? ¿Es el mismo barco si no tiene ninguna parte original? ¿Es el mismo barco si se le cambia una sola parte, o muy pocas?</p>\n\n<p>Esta historia sirve para ilustrar que las entidades como objetos inmutables y permanentes no existen en la vida real, sino que son cosas que en nuestra mente delimitamos y que, junto con otras personas, les asignamos una identidad y un significado. El <em>“Barco de Teseo”</em> sigue siendo el mismo mientras nosotros lo consideremos así.</p>\n\n<p>Exactamente así se comportan las entidades que como desarrolladores modelamos en nuestros programas. No son cosas permanentes, a veces ni siquiera cosas completamente definidas, sino que nosotros les asignamos límites y <strong>significado</strong>.</p>\n\n<p>Las personas, los objetos e incluso los conceptos están en constante evolución y parte de nuestro trabajo es capturar esa evolución en nuestros sistemas.</p>\n\n<h2 id=\"identidad-y-cambio\">Identidad y cambio</h2>\n\n<p>Cuando queremos registrar algo en una computadora, normalmente necesitamos una forma de referirnos a ese registro para después poder recuperarlo. Esto que usamos para referirnos a las entidades se llama <strong>identificador</strong>.</p>\n\n<p>Un identificador es un elemento inmutable y único entre todas las entidades de nuestro sistemas. Aquí nos podemos encontrar con varios casos:</p>\n\n<ul>\n  <li>La entidad no tiene nada único por lo que podamos referirnos a ella (elementos que se repiten, por ejemplo libros producidos en serie)</li>\n  <li>El conjunto de todos los <em>atributos</em> de la entidad puede constituir una identidad</li>\n  <li>Las entidades tienen varios atributos únicos y hay que escoger uno</li>\n</ul>\n\n<p>Pensar en la naturaleza de nuestro problema, en los términos de arriba nos puede llevar a la solución de seleccionar un elemento identificador. Piensa en el primer caso, por ejemplo: cuando algo no tiene identificador natural, tendemos a asignar un identificador único arbitrario a la entidad cuando la metemos en el sistema.</p>\n\n<p>Por ejemplo, es un práctica muy común asignar identificadores numéricos incrementales. La primera entidad registrada del tipo es la 1, la segunda es la 2, etc. También se pueden usar los UUIDs, que son identificadores únicos generados aleatoriamente, y que por lo general evitan problemas como el de permitir que alguien adivine el identificador de otra entidad.</p>\n\n<p>Pero si la entidad tiene un identificador único inmutable, ¿por qué no usarlo? <strong>¿Puede ser una solución más <em>natural</em>?</strong></p>\n\n<p>¿Qué pasa cuando lo que creíamos inmutable cambia? Eso es algo que normalmente rompe lo que hicimos y tenemos que idear formas de componerlo. Todo este tipo de preguntas pensadas por adelantado te pueden llevar a crear sistemas de software que soporten mejor el paso del tiempo y te den menos problemas cuando estén funcionando en producción.</p>\n\n<h2 id=\"relaciones\">Relaciones</h2>\n\n<p>Will Kent afirma que las relaciones son el tejido de la información que representamos en nuestros sistemas. Se puede entender una relación como una asociación o una conexión entre mínimo dos entidades.</p>\n\n<p>Las relaciones tienen varias características que las pueden definir:</p>\n\n<ul>\n  <li>Grado: El número de entidades de diferentes tipos que participan en la relación</li>\n  <li>Dominios: El conjunto de valores que son válidos en cada lado de la relación</li>\n  <li>Rol: El papel que juega cada entidad en la relación</li>\n  <li>Complejidad (cardinalidad): el número de entidades de cada tipo que participan en la relación</li>\n</ul>\n\n<p>Aquí en las relaciones y su representación empezan a surgir diferentes preguntas y problemas ya de definición, por ejmplo: ¿cómo identificas una relación? Algunas relaciones sólo son significativas con un contexto, ¿cómo lo representas? ¿Deberían ser las relaciones entidades también?</p>\n\n<p>Sin duda, leer este capítulo del libro te ayudará a plantearte todas estas cuestiones y a entender mejor cómo representar la información en tus sistemas.</p>\n\n<h3 id=\"atributos\">Atributos</h3>\n\n<p>Los atributos son los datos que “pertenecen” a una entidad. Forman el conjunto de información que tenemos sobre esta.</p>\n\n<p>Los atributos en el mundo real pueden ser infinitos, pero a nosotros normalmente sólo nos interesa un subconjunto de ellos. Data and Reality propone que los atributos son un conjunto de tres elementos:</p>\n\n<ul>\n  <li>El sujeto, la entidad a la que pertenece el atributo</li>\n  <li>El objeto, el valor del atributo</li>\n  <li>La <em>relación</em>, que es por lo que el sujeto y el objeto están conectados</li>\n</ul>\n\n<p>Supongamos por ejemplo el atributo <code class=\"language-plaintext highlighter-rouge\">nombre</code> de una persona. “Él se llama Héctor”: El sujeto es la persona a la que nos estamos refiriendo, el objeto es el nombre “Héctor” y la relación es el hecho de que la persona se llama así.</p>\n\n<p>Si puedes ver, esto nos empieza a meter en problemas de definición. Son realmente los atributos, ¿relaciones?</p>\n\n<h2 id=\"símbolos-y-valores\">Símbolos y valores</h2>\n\n<p>Otra cosa que hay que aprender a distinguir cuando estamos modelando entidades y registrándolas es la diferencia entre el valor y el <strong>símbolo</strong>. Cuando ponemos un valor para representarlo en una computadora usamos una representación, esto es el símbolo. El valor es la entidad que estamos representando.</p>\n\n<p>Por ejemplo, hablando de atributos podemos querer expresar la altura de una persona. Esta altura se puede expresar como “172cm”, “1.72m”, “5’8’’”, <code class=\"language-plaintext highlighter-rouge\">172</code> (como entero) etc. Todos estos son símbolos que representan el valor de la altura de la persona. Lo que en realidad queremos expresar es la distancia que existe entre dos puntos.</p>\n\n<h2 id=\"categorías\">Categorías</h2>\n\n<p>Cuando guardamos información en los sistemas informáticos normalmente queremos organizarla. Las categorías son una forma de hacerlo, y la manera intuitiva de entenderlo parece suficiente.</p>\n\n<p>Sin embargo, la creación de categorías es algo que también se debe pensar muy bien, ya que esto repercutirá en la forma en que guardamos información y en cómo la recuperamos.</p>\n\n<p>Algunos de los problemas en los que tienes que pensar:</p>\n\n<ul>\n  <li>¿Qué pasa cuando una entidad puede pertenecer a más de una categoría?</li>\n  <li>¿Qué clasificación es más conveniente para el problema que estás resolviendo?</li>\n</ul>\n\n<p>Las respuestas a estas preguntas son completamente arbitrarias y finalmente dependen del problema y del campo para el que estés programando.</p>\n<h2 id=\"filosofía-del-conocimiento\">Filosofía del conocimiento</h2>\n\n<p>Finalicemos este resumen hablando de la cosa más profunda o analítica que el libro trata: la naturaleza del conocimiento mismo. Hay varias posturas con respecto a “la realidad”. Las dos extremas son:</p>\n\n<ol>\n  <li>No existe una realidad objetiva, todo es subjetivo, y los seres humanos construyen esta realidad con su mente.</li>\n  <li>Existe una realidad objetiva, y los seres humanos la perciben y la pueden conocer siempre.</li>\n</ol>\n\n<p>En el libro se habla sobre una postura intermedia, y que me parece completamente razonable: es que existe una realidad objetiva, pero que los seres humanos <strong>no la pueden conocer completamente</strong>, la accedemos a través de la percepción, pero como en mucha posturas filosóficas, la percepción es imperfecta.</p>\n\n<h3 id=\"qué-es-un-modelo\">¿Qué es un modelo?</h3>\n\n<p>De esto ya hemos hablado repetidas veces en este blog, pero vamos a decirlo una vez más: uno modelo es una abstracción, una representación simplificada de la realidad.</p>\n\n<p>Lo que el análisis de este libro nos hace entender es que esa <strong>representación simplificada</strong> tiene más que ver con NUESTRA VISIÓN y NUESTROS INTERESES que con una visión objetiva de la realidad.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>La conclusión más grande que me gustaría sacar de este libro es esta:</p>\n\n<p><strong>La realidad es compleja, confusa y no tiene los límites que nos imaginamos</strong>. Todo el orden que intentamos poner en nuestros sistemas es en realidad <strong>uno de los múltiples</strong> órdenes posibles que podemos ponerle a la realidad, es un punto de vista, y eso no quiere decir que sea el mejor o el más correcto, o que los demás son incorrectos. La representación de la realidad en los sistemas de información dependerá siempre de para quién lo estemos haciendo, y del uso que se le vaya a dar.</p>\n\n<p>Hablando del dominio de modelado de datos, no hay una distinción clara entre lo que es un atributo, una categoría y una relación, nosotros definimos cuándo un aspecto del mundo real se comporta como uno u otro.</p>\n\n<p>Las entidades, su naturaleza y permanencia, están completamente definidos por el uso que les vayamos a dar.</p>\n\n<p>En resumen: <strong>gran parte de lo que creemos que es una representación objetiva, en realidad es una representación subjetiva y arbitraria</strong>. Pero eso no es malo, es como las cosas funcionan y tenerlo en cuenta nos ayudará a tener discusiones más productivas y a entender mejor los sistemas que construimos.</p>\n\n<p>Algunas representaciones son más útiles que otras desde el punto de vista de otras personas, así que esforzarnos por entender lo que otros están viendo es muy buena idea.</p>\n\n<h3 id=\"qué-sigue\">¿Qué sigue?</h3>\n\n<p>Pensar en todas estas cuestiones te ayudará a notar que no todo lo que tiene que ver con la tecnología y más importante aún: <strong>no siempre hay una respuesta correcta</strong>. Sigue flexibilizando tu pensamiento y abriéndolo, sigue pensando más allá de lo establecido y no te centres en la tecnología.</p>\n\n<p>No seas como el borracho que busca las llaves perdidas bajo el poste porque ahí hay más luz, busca las llaves donde sea más probable encontrarlas.</p>\n",
      "date_published": "Sat, 06 May 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/04/22/el-principio-de-inversion-de-dependencias.html",
      "url": "https://blog.thedojo.mx/2023/04/22/el-principio-de-inversion-de-dependencias.html",
      "title": "El principio de Inversión de Dependencias",
      "content_html": "<p>Este es el artículo final sobre el análisis de los principios SOLID. En este artículo veremos el principio de <strong>Inversión de Dependencias</strong>, el cual nos dice que las clases de alto nivel no deben depender de las clases de bajo nivel, sino que ambas deben <strong>depender de abstracciones</strong>.</p>\n\n<p>Veamos qué tan útil es en la vida real, aplicándolo día a día, cuáles son las formas de implementarlo y algunos ejemplos, asó como <strong>algunas críticas</strong>.</p>\n\n<h2 id=\"principio-de-inversión-de-dependencias\">Principio de Inversión de Dependencias</h2>\n\n<p>El principio se establece en dos partes:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>A. Los módulos de alto nivel no deberían depender de los módulos de bajo nivel, ambos deben depender de abstracciones.\n\nB. Las abstracciones no deberían depender de los detalles, los detalles deben depender de las abstracciones.\n</code></pre></div></div>\n\n<p>Esto es el principio de <strong>Sustitución de Liskov</strong>, pero llevado al extremo. Veamos algunos ejemplos en Python.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>\n<span class=\"k\">class</span> <span class=\"nc\">Database</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">connect</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">disconnect</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">query</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">sql</span><span class=\"p\">):</span>\n        <span class=\"k\">pass</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MySQLDatabase</span><span class=\"p\">(</span><span class=\"n\">Database</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">connect</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"Connecting to MySQL\"</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">disconnect</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"Disconnecting from MySQL\"</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">query</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">sql</span><span class=\"p\">):</span>\n        <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"Querying MySQL\"</span><span class=\"p\">)</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">PostgreSQLDatabase</span><span class=\"p\">(</span><span class=\"n\">Database</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">connect</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"Connecting to PostgreSQL\"</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">disconnect</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"Disconnecting from PostgreSQL\"</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">query</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">sql</span><span class=\"p\">):</span>\n        <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"Querying PostgreSQL\"</span><span class=\"p\">)</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">DatabaseManager</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">database</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">database</span> <span class=\"o\">=</span> <span class=\"n\">database</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">connect</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">database</span><span class=\"p\">.</span><span class=\"n\">connect</span><span class=\"p\">()</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">disconnect</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">database</span><span class=\"p\">.</span><span class=\"n\">disconnect</span><span class=\"p\">()</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">query</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">sql</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">database</span><span class=\"p\">.</span><span class=\"n\">query</span><span class=\"p\">(</span><span class=\"n\">sql</span><span class=\"p\">)</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Model</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">database_manager</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">database_manager</span> <span class=\"o\">=</span> <span class=\"n\">database_manager</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">save</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">database_manager</span><span class=\"p\">.</span><span class=\"n\">query</span><span class=\"p\">(</span><span class=\"s\">\"INSERT INTO ...\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">my_model</span> <span class=\"o\">=</span> <span class=\"n\">Model</span><span class=\"p\">(</span><span class=\"n\">DatabaseManager</span><span class=\"p\">(</span><span class=\"n\">MySQLDatabase</span><span class=\"p\">()))</span>\n</code></pre></div></div>\n\n<p>En este ejemplo vemos claramente como la clase <code class=\"language-plaintext highlighter-rouge\">Model</code> no depende directamente de una clase concreta de base de datos, sino que depende de una abstracción, la clase <code class=\"language-plaintext highlighter-rouge\">DatabaseManager</code>. De esta manera el código de “alto nivel”, es decir, el modelo, no depende de un código de “bajo nivel”, la base de datos.</p>\n\n<p>Aquí <strong>alto nivel</strong>, se refiere a la lógica de negocio, mientras que <strong>bajo nivel</strong> se refiere a la implementaciones de cosas no diferenciadas, como conexiones a base de datos y otras cosas similares.</p>\n\n<p>Esto se ve muy sencillo aquí, justo en un lenguaje de tipado dinámico. Pero en lenguajes de tipado estático, como Java, esto se vuelve un poco más complicado, sobre todo cuando quieres que las clases se puedan cambiar de manera dinámica.</p>\n\n<p>Es por esto que nació la técnica de <strong>Inyección de Dependencias</strong>, la cual consiste en inyectar una dependencia en una clase, en lugar de crearla dentro de la clase (la cuál tiene múltiples formas de aplicación). También se puede usar la <strong>Inversión de Control</strong>, que consiste en que en vez de que sea la clase o el método principal el que instancie alguna dependencia, sea un “contenedor”, que normalmente es un framework, el que se encargue de instanciar las dependencias y pasarlas a la clase o método que las necesita. Puedes leer más sobre <a href=\"https://medium.com/ssense-tech/dependency-injection-vs-dependency-inversion-vs-inversion-of-control-lets-set-the-record-straight-5dc818dc32d1\">DI vs IoC</a>.</p>\n\n<p>Finalmente, existe también el descubrimiento de servicios, en el que se “pide” an <strong>Localizador de Servicios</strong> que nos de lo que necesitamos para trabajar. Puedes leer sobre la aplicación de esto aquí, en un artículo de Martin Fowler: <a href=\"https://martinfowler.com/articles/injection.html\">Inversion of Control Containers and the Dependency Injection pattern</a></p>\n\n<p>A mi gusto, todo esto es muy complicado. Veamos algunas críticas a este principio.</p>\n\n<h2 id=\"crítica-de-dan-north\">Crítica de Dan North</h2>\n\n<p>Analicemos la crítica de <a href=\"https://dannorth.net/about/\">Dan North</a> (un reconocido desarrollador de software, consultor y coach) a este principio, al que no le parecen útiles los principios SOLID, sino que prefiere el código simple:</p>\n\n<blockquote>\n  <p>While there is nothing fundamentally wrong with DIP, I don’t think it is an overstatement to say that our obsession with dependency inversion has single-handedly caused billions of dollars in irretrievable sunk cost and waste over the last couple of decades. - <strong>Dan North</strong></p>\n</blockquote>\n\n<p>En resumen, <a href=\"https://dannorth.net/2021/03/16/cupid-the-back-story/\">Dan North</a> dice que aunque el principio en sí mismo no tiene nada de malo, el hecho de que nos obsesionemos con la <em>inversión de dependencias</em> ha causado miles de millones de dólares en pérdidas irreversibles.</p>\n\n<p>Veamos otra cita de <strong>Dan North</strong>:</p>\n\n<blockquote>\n  <p><strong>Most dependencies don’t need inverting, because most dependencies aren’t options, they are just the way we are going to do it this time.</strong> So my - by now entirely unsurprising - suggestion is to write simple code, by focusing on use rather than reuse.</p>\n</blockquote>\n\n<p>Esta cita la podemos traducir como:</p>\n\n<blockquote>\n  <p>La mayoría de las dependencias no necesitan invertirse, porque la mayoría de las dependencias no son opciones, son simplemente la forma en que lo haremos esta vez. Así que mi - en este momento, completamente predecible - sugerencia <strong>es escribir código simple, centrándose en el uso en lugar de en la reutilización</strong>.</p>\n</blockquote>\n\n<p>Estoy completamente de acuerdo con esta crítica. La mayoría de veces no vas a necesitar reemplazar algo. Es mejor enfocarse en lo que va a suceder 98% de las veces que hacer algo súper complejo o que requiera de una gran cantidad de código en sí mismo como pegamento para que funcione.</p>\n\n<p>Según el que propuso este principio, debería aplicarse siempre. Siempre deberías conectar cosas abstractas con otras cosas abstractas y luego hay algo que “rellena” estas cosas abstractas, o a lo que le puedes pedir que te de una implementación concreta de algo abstracto. <strong>Repito:</strong> a mi gusto es muy complicado y no es necesario en la mayoría de los casos.</p>\n\n<p>Sin embargo, creo que hay casos, sobre todo aquellos en los que tienes concretamente los casos en las que las implementaciones pueden variar, en los que sí es útil. Por ejemplo imagina algo que tenga que conectarse a diferentes API’s para proveer el mismo servicio, como por ejemplo, para enviar mensajes de texto a través de múltiples canales. En este caso, sí es útil, porque puedes tener una interfaz que defina el comportamiento de un servicio de mensajería, y luego múltiples implementaciones de esta interfaz, una para cada canal de mensajería, e inyectar las implementaciones de forma dinámica o mediante configuración.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>En este artículo hemos visto el principio de Inversión de Dependencias, el cual nos dice que las clases de alto nivel no deben depender de las clases de bajo nivel, sino que ambas deben depender de abstracciones.</p>\n\n<p>Aunque puede ser útil en ciertos casos, para mi <strong>bastante específicos</strong>, creo que intentar aplicarlo siempre ha creado más problemas que luego hacen código difícil de entender y mantener, agregándole complejidad al código innecesariamente. Es mejor tener interfaces bien diseñadas, que sea fácil entenderlas y mantener en la cabeza.</p>\n\n<p>En general, respecto a los principios <strong>SOLID</strong>, opino algo muy similar a lo que Dan North menciona: es más importante escribir código simple, que se entienda fácilmente.</p>\n\n<p>Todos los principios se pueden resumir en estos que son el fundamento de la buena programación:</p>\n\n<ol>\n  <li>Código simple, lo más simple posible (Single Responsiility Principle)</li>\n  <li>Ocultar información detrás de interfaces bien diseñadas (Single Responsibility Principle, Open/Closed Principle, Liskov Substitution Principle, Interface Segregation Principle)</li>\n  <li>Pensar bien las abstracciones que se usarán y mejorarlas constantemente (Dependency Inversion Principle)</li>\n</ol>\n\n<p>Nunca tendrás el diseño perfecto y siempre podrás mejorar tanto la arquitectura como tu código. Mientras más simple sea el código original, más probable es que tu código evolucione en algo que cumpla con lo que se espera de él. Por eso, siempre debes estar mejorando tu diseño en lo que puedas, revisando el diseño y creando mejores abstracciones.</p>\n\n<p>Por último, siempre se habla de los principios SOLID como si fueran los dogmas de una religión y se habla de “violarlos” como si estos fueran obligatorios, o principios morales que siempre se deben seguir. Además, siempre se habla de ellos como si fueran las reglas que definen lo bueno y lo malo.</p>\n\n<p>Para mi, conviene más seguir principios más generales, que un acrónimo creado con nombres de principios rimbombantes, que muchas veces son tan ambiguos que nadie qué significan exactamente, y cuando tienen aplicaciones reales, son tan complicadas que no se conviene aplicar en la mayoría de los casos.</p>\n",
      "date_published": "Sat, 22 Apr 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/04/20/creando-agentes-con-langchain-y-gpt-4.html",
      "url": "https://blog.thedojo.mx/2023/04/20/creando-agentes-con-langchain-y-gpt-4.html",
      "title": "Creando agentes con LangChain y GPT-4",
      "content_html": "<p>En este pequeño tutorial vamos a hablar de cómo puedes crear agentes que interactúen con el mundo exterior, usando LangChain y como modelo de lenguaje GPT-4. Como siempre, la mejor manera de aprender es haciendo algo, por lo que vamos a crear un agente</p>\n\n<h3 id=\"qué-es-un-agente\">¿Qué es un agente?</h3>\n\n<p>En este contexto, además de una cosa que puede actuar por sí mismo, se entiende que un agente puede hacer dos cosas más:</p>\n\n<ul>\n  <li>Decidir qué hacer y qué herramienta usar</li>\n  <li>Aprender a usar herramientas automáticamente (si le proporcionas las cosas que necesita)</li>\n</ul>\n\n<p>Los agentes tradicionalmente se entienden como programas que trabajan de manera autónoma y con su propio espacio de memoria, con los que te comunicas por medio de mensajes, pero que no tienes el control completo sobre ellos. Un agente puede decidir qué hacer con tu mensaje.</p>\n\n<p>Combinando ambos contextos, un agente es un pedazo del programa que actúa autónomamente, que decide cómo lograr lo que has pedido y que aprende a hacerlo por su cuenta. Al estar basado en un LLM, no está garantizado su éxito.</p>\n\n<h2 id=\"agentes-en-langchain\">Agentes en LangChain</h2>\n\n<p><strong>LangChain</strong> provee de un conjunto de agentes prefabricados. Los más fáciles de usar están basados en un framework llamado ReAct, que propone una forma de crear estos agentes. Puedes ver el documento en el que se habla de ReAct en el siguiente documento: <strong><a href=\"https://arxiv.org/abs/2210.03629\">ReAct: Synergizing Reasoning and Acting in Language Models\n</a></strong>.</p>\n\n<p>Básicamente este framework da las guías para crear agentes que usen herramientas de manera efectiva. LangChain provee tres agentes básicos:</p>\n\n<ul>\n  <li>\n    <p><strong>zero-shot-react-description</strong>: este tipo de agentes determinan qué tipo de herramientas usar basándose en la descripción de las herramientas proporcionadas.</p>\n  </li>\n  <li>\n    <p><strong>react-docstore</strong>: basado completamente en el framework ReAct, este tipo de agentes usan herramientas para buscar documentos y luego buscar términos en esos documentos. Recibe una herramienta de búsqueda y una de consulta.</p>\n  </li>\n  <li>\n    <p><strong>self-ask-with-search</strong>: utiliza una sola herramienta llamada ‘Intermediate Answer’ que debe ser capaz de buscar respuestas correctas a preguntas. En el paper original de ReAct se usa Google como herramienta de búsqueda.</p>\n  </li>\n  <li>\n    <p><strong>conversational-react-description</strong>: está pensado para ser usado de manera conversacional, puede decidir qué herramienta usar y tiene memoria para recordar lo que ya se ha hablado.</p>\n  </li>\n</ul>\n\n<h3 id=\"creando-un-agente\">Creando un agente</h3>\n\n<p>El siguiente código crea un agente que puede usar herramientas para lograr sus objetivos:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"c1\"># Creando un agente con LangChain\n</span>\n<span class=\"kn\">from</span> <span class=\"nn\">langchain.agents</span> <span class=\"kn\">import</span> <span class=\"n\">load_tools</span>\n<span class=\"kn\">from</span> <span class=\"nn\">langchain.agents</span> <span class=\"kn\">import</span> <span class=\"n\">initialize_agent</span>\n<span class=\"kn\">from</span> <span class=\"nn\">langchain.agents</span> <span class=\"kn\">import</span> <span class=\"n\">AgentType</span>\n<span class=\"kn\">from</span> <span class=\"nn\">langchain.llms</span> <span class=\"kn\">import</span> <span class=\"n\">OpenAI</span>\n\n<span class=\"n\">llm</span> <span class=\"o\">=</span> <span class=\"n\">OpenAI</span><span class=\"p\">(</span><span class=\"n\">temperature</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n\n<span class=\"n\">tools</span> <span class=\"o\">=</span> <span class=\"n\">load_tools</span><span class=\"p\">([</span><span class=\"s\">\"serpapi\"</span><span class=\"p\">,</span> <span class=\"s\">\"llm-math\"</span><span class=\"p\">],</span> <span class=\"n\">llm</span><span class=\"o\">=</span><span class=\"n\">llm</span><span class=\"p\">)</span>\n\n<span class=\"n\">agent</span> <span class=\"o\">=</span> <span class=\"n\">initialize_agent</span><span class=\"p\">(</span>\n    <span class=\"n\">tools</span><span class=\"p\">,</span> <span class=\"n\">llm</span><span class=\"p\">,</span> <span class=\"n\">agent</span><span class=\"o\">=</span><span class=\"n\">AgentType</span><span class=\"p\">.</span><span class=\"n\">ZERO_SHOT_REACT_DESCRIPTION</span><span class=\"p\">,</span> <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"bp\">True</span>\n<span class=\"p\">)</span>\n\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"Este agente puede buscar en Google y hacer aritmética básica.\"</span><span class=\"p\">)</span>\n<span class=\"k\">while</span> <span class=\"bp\">True</span><span class=\"p\">:</span>\n    <span class=\"n\">query</span> <span class=\"o\">=</span> <span class=\"nb\">input</span><span class=\"p\">(</span><span class=\"s\">\"Pregunta algo: \"</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">query</span><span class=\"p\">:</span>\n        <span class=\"k\">break</span>\n    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">agent</span><span class=\"p\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">query</span><span class=\"p\">))</span>\n\n</code></pre></div></div>\n\n<p>El código anterior es suficiente para crear una agente que tiene dos capacidades: buscar en internet con Google y hacer operaciones matemáticas básicas. El código es bastante simple, pero vamos a explicarlo paso a paso.</p>\n\n<p>Como siempre, la primera parte es importar las funciones y tipos necesarios:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">from</span> <span class=\"nn\">langchain.agents</span> <span class=\"kn\">import</span> <span class=\"n\">load_tools</span> <span class=\"c1\"># Es una función que te ayuda a cargar las herramientas que los agentes serán capaces de usar\n</span>\n<span class=\"kn\">from</span> <span class=\"nn\">langchain.agents</span> <span class=\"kn\">import</span> <span class=\"n\">initialize_agent</span> <span class=\"c1\"># Es una función que te ayuda a crear un agente de manera sencilla\n</span>\n<span class=\"kn\">from</span> <span class=\"nn\">langchain.agents</span> <span class=\"kn\">import</span> <span class=\"n\">AgentType</span> <span class=\"c1\"># Es un tipo que te ayuda a especificar el tipo de agente que quieres crear, contiene todos los tipos de agentes que LangChain provee\n</span>\n<span class=\"kn\">from</span> <span class=\"nn\">langchain.llms</span> <span class=\"kn\">import</span> <span class=\"n\">OpenAI</span> <span class=\"c1\"># Es la clase que abstrae la conexión con el LLM que usaremos: GPT, creado por OpenAI\n</span>\n</code></pre></div></div>\n\n<p>Después, creamos una instancia de conexión con el LLM:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">llm</span> <span class=\"o\">=</span> <span class=\"n\">OpenAI</span><span class=\"p\">(</span><span class=\"n\">temperature</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>El que le digamos que queremos cero de temperatura significa que la respuesta será menos aleatoria, por lo que podemos pensar que será menos “creativa” o arriesgada. Esto es buena idea cuando quieres crear planes, usar herramientas con una interfaz formal, como una API. Para poder usarlo, tienes que poner en el entorno de ejecución la variable de entorno <code class=\"language-plaintext highlighter-rouge\">OPENAI_API_KEY</code> con tu API key de OpenAI.</p>\n\n<p>Seguido de esto, cargamos las herramientas que queremos que el agente pueda usar, indicando el modelo de lenguaje que usará para interactuar con ellas:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">tools</span> <span class=\"o\">=</span> <span class=\"n\">load_tools</span><span class=\"p\">([</span><span class=\"s\">\"serpapi\"</span><span class=\"p\">,</span> <span class=\"s\">\"llm-math\"</span><span class=\"p\">],</span> <span class=\"n\">llm</span><span class=\"o\">=</span><span class=\"n\">llm</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>La primera es una herramienta para buscar en Google, se llama <a href=\"https://serpapi.com/\">SerpApi</a>, y permite usar la búsqueda que nosotros hacemos en Google mediante una interfaz más amigable para programas. La versión gratuita te da 100 búsquedas mensuales.</p>\n\n<p>La segunda herramienta, <code class=\"language-plaintext highlighter-rouge\">llm-math</code>, tiene como objetivo permitir que el agente haga matemáticas básicas, aunque tampoco están garantizadas porque se ejecuta código que el LLM devuelve. El prompt que usa es (lo traduzco a español después):</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>You are GPT-3, and you can't do math.\n\nYou can do basic math, and your memorization abilities are\nimpressive, but you can't do any complex calculations that\na human could not do in their head. You also have an annoying\ntendency to just make up highly specific, but wrong, answers.\n\nSo we hooked you up to a Python 3 kernel, and now you can execute\ncode. If you execute code, you must print out the final answer\nusing the print function. You MUST use the python package\nnumpy to answer your question. You must import numpy as np.\n\n\nQuestion: ${Question with hard calculation.}\n\n```python\n${Code that prints what you need to know}\nprint(${code})\n```\n```output\n${Output of your code}\n```\nAnswer: $\n\nBegin.\n\nQuestion: What is 37593 * 67?\n\n```python\nimport numpy as np\nprint(np.multiply(37593, 67))\n```\n```output\n2518731\n```\nAnswer: 2518731\n\nQuestion: {question}\n\n</code></pre></div></div>\n\n<p>Traducido al español:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>\nEres GPT-3, y no puedes hacer matemáticas.\n\nPuedes hacer matemáticas básicas, y tus habilidades de\nmemorización son impresionantes, pero no puedes hacer ningún\ncálculo complejo que un humano no pudiera hacer en su cabeza.\nTambién tienes una tendencia molesta a inventar respuestas\nespecíficas, pero incorrectas.\n\nAsí que te conectamos a un kernel de Python 3, y ahora puedes\nejecutar código. Si ejecutas código, debes imprimir el resultado\nfinal usando la función print. DEBES usar el paquete Python\nnumpy para responder tu pregunta. Debes importar numpy como np.\n\nPregunta: ${Pregunta con cálculos duros.}\n\n```python\n${Código que imprime lo que necesitas saber}\nprint(${código})\n```\n```output\n${Salida de tu código}\n```\n```\nRespuesta: ${Respuesta}\n\nComienza.\n\nPregunta: ¿Cuánto es 37593 * 67?\n\n```python\nimport numpy as np\nprint(np.multiply(37593, 67))\n```\n```output\n2518731\n```\nRespuesta: 2518731\n\nPregunta: {Pregunta}\n</code></pre></div></div>\n\n<p>Este módulo después extrae la respuesta de la salida del LLM y la ejecuta en un ejecutor de Python y extrae de aquí la respuesta.</p>\n\n<p>Aunque por ser un ejecutor de Python tenemos garantizado que el cálculo es correcto, no tenemos garantizado que el código introducido sea adecuado, así que no confíes siempre en sus cálculos.</p>\n\n<p>Después de eso inicializamos un agente, al que le pasamos las herramientas que usará, el modelo de lenguaje y el tipo de agente que queremos crear. Además, le decimos que escriba en la salida estándar todo su proceso con la opción <code class=\"language-plaintext highlighter-rouge\">verbose=True</code>:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">agent</span> <span class=\"o\">=</span> <span class=\"n\">initialize_agent</span><span class=\"p\">(</span>\n    <span class=\"n\">tools</span><span class=\"p\">,</span>\n    <span class=\"n\">llm</span><span class=\"p\">,</span>\n    <span class=\"n\">agent</span><span class=\"o\">=</span><span class=\"n\">AgentType</span><span class=\"p\">.</span><span class=\"n\">ZERO_SHOT_REACT_DESCRIPTION</span><span class=\"p\">,</span>\n    <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"bp\">True</span>\n<span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>De este modo LangChain hará todo lo necesario para inicializar un agente que use actúe de manera autónoma. Ahora le podemos preguntar cosas:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"Este agente puede buscar en Google y hacer aritmética básica.\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Creamos un loop para que\n</span>\n<span class=\"k\">while</span> <span class=\"bp\">True</span><span class=\"p\">:</span>\n    <span class=\"n\">query</span> <span class=\"o\">=</span> <span class=\"nb\">input</span><span class=\"p\">(</span><span class=\"s\">\"Pregunta algo: \"</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">query</span><span class=\"p\">:</span>\n        <span class=\"k\">break</span>\n    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">agent</span><span class=\"p\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">query</span><span class=\"p\">))</span>\n</code></pre></div></div>\n\n<p>Recuerda que esto puede contestar preguntas que se puedan encontrar en internet y hacer aritmética.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n\n<p>En este tutorial hemos visto cómo crear un agente básico. Falta explorar los demás tipos de agentes, así como las demás herramientas que LangChain provee para que podamos crear agentes más complejos y funcionales. Además, hay que probar con diferentes agentes y ver cómo se comportan.</p>\n",
      "date_published": "Thu, 20 Apr 2023 00:00:00 -0600"
      },
    
    {
      "id": "https://blog.thedojo.mx/2023/04/17/instrumentando-microservicios-con-X-Ray.html",
      "url": "https://blog.thedojo.mx/2023/04/17/instrumentando-microservicios-con-X-Ray.html",
      "title": "Instrumentando microservicios en Go con Gin y AWS X-Ray",
      "content_html": "<p>En una arquitectura de microservicios, las operaciones muchas veces abarcan múltiples servicios y recursos tales como gateways, microservicios, balanceadores de carga, bases de datos entre otros. La naturaleza distribuida de los microservicios es lo que hace invaluable la instrumentazión de software.</p>\n\n<p>Si nuestro código provee información de traceo para requests, y logs, podemos decir que está instrumentado y que podemos observar cómo se está desempeñando nuestro sistema.</p>\n\n<p>La instrumentación de servicios es especialmente útil para identificar y resolver problemas de rendimiento y errores. Los datos recolectados pueden ser usados para planear la capacidad de nuestros servicios al ayudarnos a entender el tráfico y patrones de uso en nuestras aplicaciones.</p>\n\n<p>Existen varias soluciones para instrumentar nuestros servicios, como <a href=\"https://opentelemetry.io/\">OpenTelemetry</a>, <a href=\"https://zipkin.io/\">Zipkin</a> y <a href=\"https://www.datadoghq.com/\">datadog</a>. AWS también ofrece una <a href=\"https://aws-otel.github.io/\">Distribución de OpenTelemetry</a> para poder usar OpenTelemetry como backend de obserbabilidad mientras usas X-Ray o cualquier otra solución de terceros para recibir datos de telemetría y proveer procesamiento, agregación y visualización de éstos.</p>\n\n<p>En este post, les voy a contar sobre mi experiencia al instrumentar un microservicio en Go usando Gin y AWS X-Ray.</p>\n\n<h2 id=\"gin\">Gin</h2>\n\n<p>Gin es un framework para el lenguaje de programación Go para crear aplicaciones web, se destaca por ser ligero y tener un alto rendimiento, diseñado para facilitar la creación de aplicaciones web escalables de una manera rápida.</p>\n\n<p>Ofrece una API minimalista, un router robusto, soporte para middleware y características de seguridad integradas, lo que lo convierte en una opción ideal para construir microservicios y otras aplicaciones web de alto rendimiento.</p>\n\n<p>Si bien Gin puede tener una curva de aprendizaje empinada y características limitadas integradas, su simplicidad y capacidad de extensión lo convierten en una opción popular para los desarrolladores que priorizan el rendimiento y la escalabilidad.</p>\n\n<p><strong>Crear un servicio de Gin desde cero está fuera del alcance de esta publicación</strong>, pero puedes leer más sobre Gin en la <a href=\"(https://gin-gonic.com/docs/)\">página oficial de su documentación</a>.</p>\n\n<h2 id=\"aws-x-ray\">AWS X-Ray</h2>\n\n<p>AWS X-Ray es un servicio de AWS que recolecta datos sobre los requests servidos por tu aplicación y provee herramientas para ver, filtrar y obtener información sobre esos datos para identificar problemas y oportunidades de optimización.</p>\n\n<p>Algunos puntos a favor de X-Ray sobre otras herramientas similares son:</p>\n\n<ul>\n  <li>Facilidad de integración con otros servicios de AWS.</li>\n  <li>No hay infraestructura extra qué mantener (el daemon de X-Ray está incluído en las plataformas AWS Elastic Beanstalk y AWS Lambda).</li>\n  <li>Puede funcionar sólo como visualizador (usando OpenTelemetry como tracer).</li>\n  <li>Para servicios soportados, el SDK de X-Ray puede enviar y rastrear automáticamente los “ID de request” entre los servicios.</li>\n  <li>Es administrado por AWS.</li>\n  <li>Los primeros 100k rastreos del mes son gratis.</li>\n  <li>El primer millón de rastreos obtenidos o escaneados cada mes es gratis.</li>\n</ul>\n\n<p>Sin embargo algunos puntos en contra son:</p>\n\n<ul>\n  <li>AWS X-Ray sólo puede ser usado con aplicaciones corriendo en Amazon EC2, Amazon EC2 containser service, AWS Lambda, y AWS Elastic Beanstalk.</li>\n  <li>Después de agotar los rastreos gratuitos del mes, cada rastreo indexado y consultado tiene un costo.</li>\n  <li>Soporte limitado de lenguajes: Mientras que el SDK de X-Ray tiene soporte para varios lenguajes de programación, no soporta todos los lenguajes o plataformas, lo cual puede limitar su utilidad en algunos casos.</li>\n  <li>Vendor lock-in: El uso de X-Ray puede llevar a la dependencia exclusiva de AWS, ya que es un servicio propietario disponible sólo en la plataforma de AWS. Esto puede limitar su capacidad para cambiar a otros proveedores de nube o herramientas en el futuro.</li>\n</ul>\n\n<p>Si, después de leer algunos de los pros y contras, aún estás inclinado a usar X-Ray, entonces puedes seguir leyendo.</p>\n\n<h3 id=\"requerimientos\">Requerimientos</h3>\n\n<p>Para ver la información de rastreo en AWS X-Ray, necesitas una cuenta de AWS y una aplicación corriendo en la infraestructura de AWS o que esté integrada con los servicios de AWS. Además, necesitarás:</p>\n\n<ul>\n  <li>Una instancia del X-Ray daemon, que se puede ejecutar como un binario o como un contenedor de Docker. Puedes encontrar instrucciones detalladas sobre cómo ejecutar y configurar el daemon <a href=\"https://docs.aws.amazon.com/xray/latest/devguide/xray-daemon-local.html\">aquí</a>. Para éste artículo, estaré usando el binario para OS X.</li>\n  <li>Tu aplicación debe de tener los permisos necesarios para interactuar con AWS X-Ray y otros servicios que use.</li>\n</ul>\n\n<h4 id=\"iam-role\">IAM Role</h4>\n\n<p>Para permitir que tu aplicación mande información sobre tus requests a X-Ray, tienes que proveerle al daemon de X-Ray un rol. Para crear un rol, vamos a entrar a nuestra consola web de AWS y de allí navegamos a la página principal de IAM y allí encontraremos el botón “Create Role” (o “Crear Rol” si tienes configurado tu panel de AWS en español).</p>\n\n<p><img src=\"https://raw.githubusercontent.com/makkoman/blogposts/main/x-ray/images/create-role.png\" alt=\"Crear nuevo rol\" /></p>\n\n<p>En el asistente, selecciona “AWS Account” para Trusted Entity y da click en “Next”/”Siguiente”. En la siguiente pantalla, busca por la política de permisos llamada “AWSXRayDaemonWriteAccess”. Da click en “Next”/”Siguiente” para continuar..</p>\n\n<p><img src=\"https://raw.githubusercontent.com/makkoman/blogposts/main/x-ray/images/name-review-create.png\" alt=\"Nombra, Revisa y Crea\" /></p>\n\n<p>Agrega un nombre y descripción para el rol, y después da click en “Create Role”. Ésto te llevará a la lista de roles. Busca el rol que acabas de crear para ver y copiar su ARN.</p>\n\n<p><img src=\"https://raw.githubusercontent.com/makkoman/blogposts/main/x-ray/images/role-details.png\" alt=\"Detalles del rol\" /></p>\n\n<h3 id=\"x-ray-daemon\">X-Ray Daemon</h3>\n\n<p>Ahora que ya tenemos el rol para el daemon, vamos a configurarlo.</p>\n\n<p>Para mi proyecto de prueba, solo tuve que cambiar algunos valores de la configuración, como el nivel del logger, especificar el modo local a verdadero, y agregar el ARN del rol que creamos y la región de AWS en la que estamos operando nuestros servicios.</p>\n\n<p>Aquí está la configuración que usé:</p>\n\n<div class=\"language-yaml highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># Send segments to AWS X-Ray service in a specific region</span>\n<span class=\"na\">Region</span><span class=\"pi\">:</span> <span class=\"s2\">\"</span><span class=\"s\">us-west-2\"</span>\n<span class=\"na\">Socket</span><span class=\"pi\">:</span>\n  <span class=\"c1\"># Change the address and port on which the daemon listens for UDP packets containing segment documents.</span>\n  <span class=\"na\">UDPAddress</span><span class=\"pi\">:</span> <span class=\"s2\">\"</span><span class=\"s\">127.0.0.1:2000\"</span>\n  <span class=\"c1\"># Change the address and port on which the daemon listens for HTTP requests to proxy to AWS X-Ray.</span>\n  <span class=\"na\">TCPAddress</span><span class=\"pi\">:</span> <span class=\"s2\">\"</span><span class=\"s\">127.0.0.1:2000\"</span>\n<span class=\"na\">Logging</span><span class=\"pi\">:</span>\n  <span class=\"c1\"># Change the log level, from most verbose to least: dev, debug, info, warn, error, prod (default).</span>\n  <span class=\"na\">LogLevel</span><span class=\"pi\">:</span> <span class=\"s2\">\"</span><span class=\"s\">dev\"</span>\n<span class=\"c1\"># Turn on local mode to skip EC2 instance metadata check.</span>\n<span class=\"na\">LocalMode</span><span class=\"pi\">:</span> <span class=\"no\">true</span>\n<span class=\"c1\"># Assume an IAM role to upload segments to a different account.</span>\n<span class=\"na\">RoleARN</span><span class=\"pi\">:</span> <span class=\"s2\">\"</span><span class=\"s\">arn:aws:iam::269174633178:role/X-Ray_Daemon_role\"</span>\n<span class=\"c1\"># Daemon configuration file format version.</span>\n<span class=\"na\">Version</span><span class=\"pi\">:</span> <span class=\"m\">2</span>\n</code></pre></div></div>\n\n<p>En <a href=\"https://docs.aws.amazon.com/xray/latest/devguide/xray-daemon-configuration.html\">la guía del desarrollador de AWS X-Ray</a> puedes aprender más sobre otros valores que puedes configurar.</p>\n\n<h3 id=\"instrumentando-tu-microservicio-en-go\">Instrumentando tu microservicio en Go</h3>\n\n<p>Ahora que ya tenemos el X-Ray daemon configurado y corriendo, podemos proceder a instrumentar nuestro servicio.</p>\n\n<p>AWS recomienda empezar agregando rastreo para requests entrantes envolviendo los controladores de servicio con <code class=\"language-plaintext highlighter-rouge\">xray.Handler</code>. Pero, como estamos usando Gin, el enfoque que implementaremos es ligeramente diferente.</p>\n\n<p>Mientras buscaba recursos sobre cómo instrumentar una aplicación con Gin, me encontré con éste <a href=\"https://raw.githubusercontent.com/oroshnivskyy/go-gin-aws-x-ray\">middleware</a>, el cual está basado en la función <a href=\"https://raw.githubusercontent.com/aws/aws-xray-sdk-go/1e154184282bb3b0166cb1b154f2b4abed0b1e6f/xray/handler.go#L99\"><code class=\"language-plaintext highlighter-rouge\">xray.Handler</code></a>.</p>\n\n<p>Éste middleware hace el mismo trabajo que <code class=\"language-plaintext highlighter-rouge\">xray.Handler</code>, abrirá y cerrará un segmento para cada request recibido. También se encargará de manejar el header para IDs de rastreo (<code class=\"language-plaintext highlighter-rouge\">\"x-amzn-trace-id\"</code>), que es un header que contiene un identificador que será generado para cada petición nueva y que será propagado a travéz de todos nuestros microservicios.</p>\n\n<p>Así que vamos a agregar el middleware a las rutas que queremos intrumentar:</p>\n\n<div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\">// as part of my gin routes</span>\n<span class=\"n\">v1</span><span class=\"o\">.</span><span class=\"n\">GET</span><span class=\"p\">(</span><span class=\"s\">\"/auth/roles\"</span><span class=\"p\">,</span> <span class=\"n\">xraymid</span><span class=\"o\">.</span><span class=\"n\">Middleware</span><span class=\"p\">(</span><span class=\"n\">xray</span><span class=\"o\">.</span><span class=\"n\">NewFixedSegmentNamer</span><span class=\"p\">(</span><span class=\"s\">\"GetRoles\"</span><span class=\"p\">)),</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">GetRoles</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>Aquí estamos agregando el middleware de X-Ray (con el alias <code class=\"language-plaintext highlighter-rouge\">xraymid</code>) a una ruta del grupo <code class=\"language-plaintext highlighter-rouge\">v1</code>. El valor que estamos pasando como argumento a <code class=\"language-plaintext highlighter-rouge\">NewFixedSegmentNamer</code> debe de ser un nombre descriptivo para tu ruta. Éste será el nombre para el grupo principal de rastreo para éste endpoint.</p>\n\n<p>¡Bien! ¡Ahora veamos si funciona! Inicia tu servicio y verifica que el daemon esté corriendo.</p>\n\n<p>Después de hacer un request, podemos ver en los logs del daemon algo como:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>2023-03-21T13:10:47-06:00 [Debug] Received request on HTTP Proxy server : /GetSamplingRules\n2023-03-21T13:10:48-06:00 [Debug] processor: sending partial batch\n2023-03-21T13:10:48-06:00 [Debug] processor: segment batch size: 1. capacity: 50\n2023-03-21T13:10:48-06:00 [Info] Successfully sent batch of 1 segments (0.109 seconds)\n2023-03-21T13:10:49-06:00 [Debug] Send 1 telemetry record(s)\n</code></pre></div></div>\n\n<p>¡Parece que está funcionando! Vamos a ver qué dice la consola de AWS.</p>\n\n<p>En tu consola web de AWS, ve a CloudWatch y en el panel lateral busca la opción para X-Ray, y da click en la opción “traces”.</p>\n\n<p>Si todo salió bien, deberías estar viendo el número de rastreos recibidos recientemente, y una tabla con la información de esos rastreos.</p>\n\n<p><img src=\"https://raw.githubusercontent.com/makkoman/blogposts/main/x-ray/images/cloudwatch-xray-traces.png\" alt=\"Cloudwatch -&gt; X-Ray -&gt; Traces\" /></p>\n\n<p>En la tabla de registros, da click en alguno. Aparecerá la vista de rastreo/seguimiento, donde puedes ver la información registrada.</p>\n\n<p><img src=\"https://raw.githubusercontent.com/makkoman/blogposts/main/x-ray/images/simple-trace-info.png\" alt=\"Información de rastreo\" /></p>\n\n<p>Aquí podemos ver los datos de seguimiento. Hasta el momento sólo estamos creando un segmento y cerrándolo para cada llamada, por lo que no tenemos mucha otra información, pero podemos ver el código de estado de respuesta, el tiempo que tomó para que se atendiera la solicitud y, por supuesto, el mapa de seguimiento, que por ahora incluye sólo el cliente y el servicio.</p>\n\n<h4 id=\"creando-sub-segmentos\">Creando sub segmentos</h4>\n\n<p>Ahora que tenemos nuestra configuración básica de instrumentación, ¿qué más podemos rastrear?</p>\n\n<p>Hasta el momento, solo estamos rastreando una solicitud y algunos de sus metadatos. Pero, ¿qué pasa si queremos ser más detallados?</p>\n\n<p>Digamos que tenemos un proceso intensivo que se ejecuta como parte de la solicitud; podemos agregar un subsegmento para monitorearlo.</p>\n\n<p>En algún lugar de mi servicio, se ejecuta el siguiente código cuando llamo al endpoint <code class=\"language-plaintext highlighter-rouge\">auth/roles</code>:</p>\n\n<div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\">// dentro de alguna función</span>\n<span class=\"n\">roles</span> <span class=\"o\">:=</span> <span class=\"nb\">make</span><span class=\"p\">([]</span><span class=\"n\">Role</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">rolesList</span><span class=\"p\">))</span>\n<span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">roleItem</span> <span class=\"o\">:=</span> <span class=\"k\">range</span> <span class=\"n\">rolesList</span> <span class=\"p\">{</span>\n\t<span class=\"n\">role</span><span class=\"p\">,</span> <span class=\"n\">err</span> <span class=\"o\">:=</span> <span class=\"n\">u</span><span class=\"o\">.</span><span class=\"n\">buildRole</span><span class=\"p\">(</span><span class=\"n\">roleItem</span><span class=\"p\">)</span>\n\t<span class=\"k\">if</span> <span class=\"n\">err</span> <span class=\"o\">!=</span> <span class=\"no\">nil</span> <span class=\"p\">{</span>\n\t\t<span class=\"k\">return</span> <span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">RoleList</span><span class=\"p\">{},</span> <span class=\"n\">err</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"n\">roles</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">role</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>Aquí podemos envolver el bucle <code class=\"language-plaintext highlighter-rouge\">for</code> en un subsegmento para ver cuánto tiempo del request tarda en ejecutar éste proceso.</p>\n\n<p>Para crear el subsegmento, envolvemos el ciclo:</p>\n\n<div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">err</span> <span class=\"o\">=</span> <span class=\"n\">xray</span><span class=\"o\">.</span><span class=\"n\">Capture</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">,</span> <span class=\"s\">\"BuildRolesDetail\"</span><span class=\"p\">,</span> <span class=\"k\">func</span><span class=\"p\">(</span><span class=\"n\">ctx1</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">Context</span><span class=\"p\">)</span> <span class=\"kt\">error</span> <span class=\"p\">{</span>\n\t<span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">roleItem</span> <span class=\"o\">:=</span> <span class=\"k\">range</span> <span class=\"n\">rolesList</span> <span class=\"p\">{</span>\n\t\t<span class=\"n\">role</span><span class=\"p\">,</span> <span class=\"n\">err</span> <span class=\"o\">:=</span> <span class=\"n\">u</span><span class=\"o\">.</span><span class=\"n\">buildRole</span><span class=\"p\">(</span><span class=\"n\">roleItem</span><span class=\"p\">)</span>\n\t\t<span class=\"k\">if</span> <span class=\"n\">err</span> <span class=\"o\">!=</span> <span class=\"no\">nil</span> <span class=\"p\">{</span>\n\t\t\t<span class=\"k\">return</span> <span class=\"n\">err</span>\n\t\t<span class=\"p\">}</span>\n\t\t<span class=\"n\">roles</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">role</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"k\">if</span> <span class=\"n\">err</span> <span class=\"o\">=</span> <span class=\"n\">xray</span><span class=\"o\">.</span><span class=\"n\">AddMetadata</span><span class=\"p\">(</span><span class=\"n\">ctx1</span><span class=\"p\">,</span> <span class=\"s\">\"No. roles built\"</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">roles</span><span class=\"p\">));</span> <span class=\"n\">err</span> <span class=\"o\">!=</span> <span class=\"no\">nil</span> <span class=\"p\">{</span>\n\t\t<span class=\"k\">return</span> <span class=\"n\">nepErrors</span><span class=\"o\">.</span><span class=\"n\">InternalServerError</span><span class=\"o\">.</span><span class=\"n\">WithDetail</span><span class=\"p\">(</span><span class=\"n\">err</span><span class=\"o\">.</span><span class=\"n\">Error</span><span class=\"p\">())</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"k\">return</span> <span class=\"no\">nil</span>\n<span class=\"p\">})</span>\n</code></pre></div></div>\n\n<p>Vamos a correr nuestro servicio y llamemos de nuevo nuestro endpoint instrumentado.</p>\n\n<p>Éste es el nuevo registro en AWS CloudWatch -&gt; Traces:</p>\n\n<p><img src=\"https://raw.githubusercontent.com/makkoman/blogposts/main/x-ray/images/trace-with-sub-segment.png\" alt=\"Rastreo con subsegmentos\" /></p>\n\n<p>Ahora podemos ver que la petición tomó <strong>215ms</strong>, y de esos, el ciclo <code class=\"language-plaintext highlighter-rouge\">BuildRolesDetail</code> tomó <strong>205ms</strong>.</p>\n\n<p>¿Ya estás pensando en las posibilidades? ¡Deberías! puedes usar <code class=\"language-plaintext highlighter-rouge\">xray.AddMetadata</code> para agregar cualquier dato que te sea de utilidad. Únicamente toma en cuenta que el Daemon de X-Ray sólo envía a AWS <a href=\"https://docs.aws.amazon.com/xray/latest/devguide/xray-api-segmentdocuments.html\">hasta 64KB de metadata por segmento</a>.</p>\n\n<h3 id=\"instrumentando-clientes-de-aws-con-x-ray\">Instrumentando clientes de AWS con X-Ray</h3>\n\n<p>Instrumentar clientes de AWS usando el SDK-V1 es bastante sencillo, puedes seguir la <a href=\"https://docs.aws.amazon.com/xray/latest/devguide/xray-sdk-go-awssdkclients.html\">guía oficial</a> para hacerlo.</p>\n\n<p>No hay mucha documentación sobre cómo instrumentar clientes de AWS usando el AWS SDK-v2, pero la configuración es bastante sencilla.</p>\n\n<p>En algún lugar en el código de tu servicio, estás inicializando tu(s) cliente(s) de AWS. Para instrumentarlos, necesitas proveer a tus clientes con un cliente HTTP de X-Ray y pasar el contexto del request para cada llamada.</p>\n\n<div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">cfg</span><span class=\"p\">,</span> <span class=\"n\">err</span> <span class=\"o\">:=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">LoadDefaultConfig</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">)</span>\n<span class=\"k\">if</span> <span class=\"n\">err</span> <span class=\"o\">!=</span> <span class=\"no\">nil</span> <span class=\"p\">{</span>\n\t<span class=\"k\">return</span> <span class=\"no\">nil</span><span class=\"p\">,</span> <span class=\"n\">err</span>\n<span class=\"p\">}</span>\n\n<span class=\"c\">// Create an HTTP client</span>\n<span class=\"n\">httpClient</span> <span class=\"o\">:=</span> <span class=\"o\">&amp;</span><span class=\"n\">http</span><span class=\"o\">.</span><span class=\"n\">Client</span><span class=\"p\">{}</span>\n\n<span class=\"c\">// Set the HTTP client as the AWS configuration's HTTP client</span>\n<span class=\"n\">cfg</span><span class=\"o\">.</span><span class=\"n\">HTTPClient</span> <span class=\"o\">=</span> <span class=\"n\">httpClient</span>\n\n<span class=\"c\">// Create an X-Ray client</span>\n<span class=\"n\">xrayClient</span> <span class=\"o\">:=</span> <span class=\"n\">xray</span><span class=\"o\">.</span><span class=\"n\">Client</span><span class=\"p\">(</span><span class=\"n\">httpClient</span><span class=\"p\">)</span>\n\n<span class=\"n\">dynamoClient</span> <span class=\"o\">:=</span> <span class=\"n\">dynamodb</span><span class=\"o\">.</span><span class=\"n\">NewFromConfig</span><span class=\"p\">(</span><span class=\"n\">cfg</span><span class=\"p\">,</span> <span class=\"k\">func</span><span class=\"p\">(</span><span class=\"n\">options</span> <span class=\"o\">*</span><span class=\"n\">dynamodb</span><span class=\"o\">.</span><span class=\"n\">Options</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t<span class=\"c\">// Wrap the http.Client with an xray.Client</span>\n\t<span class=\"n\">options</span><span class=\"o\">.</span><span class=\"n\">HTTPClient</span> <span class=\"o\">=</span> <span class=\"n\">xrayClient</span>\n<span class=\"p\">})</span>\n</code></pre></div></div>\n\n<p>Aquí, estoy agregando el cliente HTTP de X-Ray al cliente de AWS DynamoDB.</p>\n\n<p>Una vez hecho esto, llamemos de nuevo a nuestro endpoint instrumentado.</p>\n\n<p><img src=\"https://raw.githubusercontent.com/makkoman/blogposts/main/x-ray/images/instrumenting-ddb-client.png\" alt=\"Instrumentando el cliente de DynamoDB\" /></p>\n\n<p>Yo estoy corriendo DynamoDB localmente, pero ya puedes ver qué tanto tiempo toma cada llamada a DynamoDB. También podemos ver que el mapa de rastreo ha sido acualizado para mostrar mi instancia local de DynamoDB.</p>\n\n<h2 id=\"conclusión\">Conclusión</h2>\n<p>Instrumentar un servicio con X-Ray es relativamente sencillo, pero puede complicarse muy rápido dependiendo de las cosas que queremos monitorear. Debido a esto, el esfuerzo para agregar trazabilidad a su servicio puede variar de caso en caso.</p>\n\n<p>Otra cosa a considerar es el límite de 64KB por segmento. Puede que no sea suficiente si deseas rastrear muchos subsegmentos o agregar más metadatos. Existen formas de evitar esto, pero están fuera del alcance de esta publicación.</p>\n\n<p>En conclusión, implementar X-Ray en un microservicio en Go es un proceso sencillo que puede beneficiar enormemente la observabilidad y las capacidades de resolución de problemas de tu aplicación. El proceso de integración es relativamente fácil, y el SDK de X-Ray proporciona una serie de características útiles que facilitan la trazabilidad de las solicitudes y la identificación de cuellos de botella. Sin embargo, es importante tener en cuenta que X-Ray tiene algunas desventajas, como el costo asociado con su uso y las limitaciones de sus capacidades de muestreo.</p>\n\n<p>No obstante, con una consideración cuidadosa y una implementación adecuada, X-Ray puede ser una herramienta invaluable para la depuración y optimización de tu arquitectura de microservicios. Así que no dudes en probarlo y ver cómo puede mejorar el rendimiento y la confiabilidad de tus microservicios en Go.</p>\n",
      "date_published": "Mon, 17 Apr 2023 00:00:00 -0600"
      }
    
  ]
}
       <div style="border: 1px solid gray; border-radius: 4px; margin: 20px; padding: 5px;">
          Visita nuestro canal de YouTube para encontrar temas similares en video:<a href="https://youtube.com/thedojomx"> The Dojo MX en YouTube </a>
        </div>

        
      </section>

      <footer class="page__meta">
        
        


        


      </footer>

      

      
    </div>

    
  </article>

  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        
<script>
    var sharect = new Sharect();
    sharect.config({
      twitter: true,
      twitterUsername: '@thedojomx',
      backgroundColor: '#4b0082',
      iconColor: '#fff'
    }).init();
</script>
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Seguir:</strong></li>
    

    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2023 The Dojo MX Blog. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
